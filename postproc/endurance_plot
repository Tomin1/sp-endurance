#!/usr/bin/perl
#
# This file is part of sp-endurance.
#
# vim: sw=4
#
# Copyright (C) 2010-2011 by Nokia Corporation
#
# Contact: Eero Tamminen <eero.tamminen@nokia.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA

use Time::Local;
use POSIX qw/ceil WIFSIGNALED WTERMSIG SIGINT SIGTERM SIGKILL/;
use List::Util qw/max sum/;

my $version = "0.38";

# tunables
my $ticks_per_sec = 100;
my $sector_sz = 4096;
my $max_per_graph_twocolumn = 2*75;
my $max_per_graph_onecolumn = 78;
my $page_size = 4;
my $pg_bytes = 4096;
my $MB_bytes = 1024*1024;
my $samples_required = 5;
my $thumb_width = 320;
my $thumb_height = 250;
my $html_name = "index.html";
my $graphs_dir = "graphs";

my ($sw_version, $hw_build, $hw_product);
#stuff keyed by graph name with data for each graph:
my %legend;
my (%unit, %unit_1, %unit_2);
my %thumblegend;

my $secs_per_round = 0;
my $mins_per_round = 0;
my $hours_per_round = 0;
my ($str_hours, $str_minutes, $str_seconds);
my $total_duration;

# names for files by classes, results in grouping,
# as thumbnails are generated using this list sorted
my $graph_memory   = "10_memory"; 
$legend{$graph_memory} = "system-level memory"; 
$thumblegend{$graph_memory} = "SYSTEM MEMORY";
$unit{$graph_memory} = "MB";

my $graph_memory_s = "10_memory_s";
$legend{$graph_memory_s} = "system-level memory smaller values"; 
$thumblegend{$graph_memory_s} = "MEMORY SMALLER";
$unit{$graph_memory_s} = "MB";

my $graph_appmem_swapped = "20_appmem_swapped";
$legend{$graph_appmem_swapped} = "swap used by processes"; 
$thumblegend{$graph_appmem_swapped} = "APPS SWAP USE";
$unit{$graph_appmem_swapped} = "MB";

my $graph_appmem_pss =  "30_appmem_pss";
$legend{$graph_appmem_pss} = "apps PSS"; 
$thumblegend{$graph_appmem_pss} = "APPS PSS";
$unit{$graph_appmem_pss} = "MB";

my $graph_appmem_pss_swap =  "30_appmem_pss_swap";
$legend{$graph_appmem_pss_swap} = "apps PSS+SWAP"; 
$thumblegend{$graph_appmem_pss_swap} = "APPS PSS+SWAP";
$unit{$graph_appmem_pss_swap} = "MB";

#
# legends for pss_swap graphs generated dynamically
#
my $graph_appmem_pss_swap_lines_big =      "30_appmem_pss_swap_lines_big";
$unit{$graph_appmem_pss_swap_lines_big} = "MB";

my $graph_appmem_pss_swap_lines_small =    "30_appmem_pss_swap_lines_small";
$unit{$graph_appmem_pss_swap_lines_small} = "MB";

my $graph_appmem_pss_swap_lines_smaller =  "30_appmem_pss_swap_lines_smaller";
$unit{$graph_appmem_pss_swap_lines_smaller} = "MB";

my $graph_appmem_pss_swap_lines_smallest = "30_appmem_pss_swap_lines_smallest";
$unit{$graph_appmem_pss_swap_lines_smallest} = "MB";

my $graph_appmem_locked = "32_appmem_locked";
$legend{$graph_appmem_locked} = "process locked mem size"; 
$thumblegend{$graph_appmem_locked} = "APPS LOCKED";
$unit{$graph_appmem_locked} = "MB";

my $graph_vmsize = "33_vmsize";
$legend{$graph_vmsize} = "process virtual mem size"; 
$thumblegend{$graph_vmsize} = "VMSIZE";
$unit{$graph_vmsize} = "MB";

#my $graph_appmem_private_dirty = "35_appmem_private_dirty";
#$legend{$graph_appmem_private_dirty} = "private dirty mem by processes"; 
#$thumblegend{$graph_appmem_private_dirty} = "PRIVATE DIRTY";
#$unit{$graph_appmem_private_dirty} = "MB";

my $graph_appmem_heap = "36_appmem_heap";
$legend{$graph_appmem_heap} = "process heap mem size"; 
$thumblegend{$graph_appmem_heap} = "APPS HEAP";
$unit{$graph_appmem_heap} = "MB";

my $graph_appmem_devpvr = "37_appmem_devpvr";
$legend{$graph_appmem_devpvr} = "process /dev/pvrsrvkm"; 
$thumblegend{$graph_appmem_devpvr} = "PVRSRVKM";
$unit{$graph_appmem_devpvr} = "MB";

my $graph_appmem_sysvshared = "38_appmem_sysvshared";
$legend{$graph_appmem_sysvshared} = "process SYSV-shared mem size"; 
$thumblegend{$graph_appmem_sysvshared} = "SYSV-SHAREDMEM";
$unit{$graph_appmem_sysvshared} = "MB";

my $graph_appmem_posixshared = "39_appmem_posixshared";
$legend{$graph_appmem_posixshared} = "process POSIX-shared mem size"; 
$thumblegend{$graph_appmem_posixshared} = "POSIX-SHAREDMEM";
$unit{$graph_appmem_posixshared} = "MB";

my $graph_mem_shared = "40_mem_shared";
$legend{$graph_mem_shared} = "shared memory"; 
$thumblegend{$graph_mem_shared} = "SHMEM";
$unit{$graph_mem_shared} = "MB";

my $graph_mem_shared_cpid = "40_mem_shared_cpid";
$legend{$graph_mem_shared_cpid} = "shared by creator (cpid)"; 
$thumblegend{$graph_mem_shared_cpid} = "SHMEM CREATOR";
$unit{$graph_mem_shared_cpid} = "MB";

my $graph_mem_shared_lpid = "40_mem_shared_lpid";
$legend{$graph_mem_shared_lpid} = "shared by last user (lpid)"; 
$thumblegend{$graph_mem_shared_lpid} = "SHMEM LAST USER";
$unit{$graph_mem_shared_lpid} = "MB";

my $graph_mem_shared_lpid_name = "40_mem_shared_lpid_name";
$legend{$graph_mem_shared_lpid_name} = "shared by last user-pname (lpid)"; 
$thumblegend{$graph_mem_shared_lpid_name} = "SHMEM LAST PNAME";
$unit{$graph_mem_shared_lpid_name} = "MB";

my $graph_mem_shared_number = "40_mem_shared_number";
#$legend{$graph_mem_shared_number} = "shared mem number of segments; nattach-0: real orphans"; 
#$legend{$graph_mem_shared_number} = "shared mem number of segments and attach-avg-age (sec)"; 
$legend{$graph_mem_shared_number} = "left: num of shmem segments by attached proc; right: num of all shmem segments"; 
$thumblegend{$graph_mem_shared_number} = "SHMEM NUMBER";
$unit_1{$graph_mem_shared_number} = "count by attached processes";
$unit_2{$graph_mem_shared_number} = "count of all";

my $graph_mem_shared_size = "40_mem_shared_size";
$legend{$graph_mem_shared_size} = "shared by nattach, size"; 
$thumblegend{$graph_mem_shared_size} = "SHMEM SIZES";
$unit{$graph_mem_shared_size} = "MB";

my $graph_xresource_sz_pxm =    "50_xresource_pixmaps";
$legend{$graph_xresource_sz_pxm} = "X resource pixmaps size"; 
$thumblegend{$graph_xresource_sz_pxm} = "X-RESOURCES-PIXMAPS";
$unit{$graph_xresource_sz_pxm} = "Size of Xres pixmaps, kB";

my $graph_xresource_cnt =    "51_xresource_count";
$legend{$graph_xresource_cnt} = "X resource counts"; 
$thumblegend{$graph_xresource_cnt} = "X-RESOURCES-COUNT";
$unit{$graph_xresource_cnt} = "number of Xres objects";

#my $graph_xresource_sz_misc =    "52_xresource_misc";
#$legend{$graph_xresource_sz_misc} = "X resource misc size"; 
#$thumblegend{$graph_xresource_sz_misc} = "X-RESOURCES-MISC";
#$unit{$graph_xresource_sz_misc} = "Size of Xres misc, kB";

my $graph_mem_slabs =     "55_mem_slabs";
$legend{$graph_mem_slabs} = "kernel slab memory"; 
$thumblegend{$graph_mem_slabs} = "KERNEL SLABS";
$unit{$graph_mem_slabs} = "kB";

my $graph_cpu =  "59_cpu";
$legend{$graph_cpu} = "CPU utilization";
$thumblegend{$graph_cpu} = "CPU UTILIZATION";
$unit{$graph_cpu} = "percent";

my $graph_cpu_totaltime =  "60_cpu_totaltime";
$legend{$graph_cpu_totaltime} = "CPU total time"; 
$thumblegend{$graph_cpu_totaltime} = "TOTAL CPU TIME";
$unit{$graph_cpu_totaltime} = "percent";

my $graph_cpu_usertime = "61_cpu_usertime";
$legend{$graph_cpu_usertime} = "CPU user time"; 
$thumblegend{$graph_cpu_usertime} = "USER CPU TIME";
$unit{$graph_cpu_usertime} = "percent";

my $graph_cpu_systime =  "61_cpu_systime";
$legend{$graph_cpu_systime} = "CPU system time"; 
$thumblegend{$graph_cpu_systime} = "SYSTEM CPU TIME";
$unit{$graph_cpu_systime} = "percent";

my $graph_loadavg =  "62_loadavg";
$legend{$graph_loadavg} = "Load average"; 
$thumblegend{$graph_loadavg} = "LOAD AVG 1m/5m/15m";
$unit{$graph_loadavg} = "loadavg units";

my $graph_events_swap =             "70_events_swap";
$legend{$graph_events_swap} = "swap-related events"; 
$thumblegend{$graph_events_swap} = "SWAP EVENTS";
$unit{$graph_events_swap} = "count per second";

my $graph_ramzswap =             "72_ramzswap";
$legend{$graph_ramzswap} = "compressed swap counters; left:reads/writes right:used amount, bold"; 
$thumblegend{$graph_ramzswap} = "COMPR-SWAP";
$unit_1{$graph_ramzswap} = "MB per second";
$unit_2{$graph_ramzswap} = "MB used";

my $graph_pagetypeinfo_unmovable = "74_pagetypeinfo_unmovable";
$legend{$graph_pagetypeinfo_unmovable} = "pagetype unmovable from /proc/pagetypeinfo"; 
$thumblegend{$graph_pagetypeinfo_unmovable} = "PAGETYPE-UNMOVABLE";
$unit{$graph_pagetypeinfo_unmovable} = "MB";

my $graph_pagetypeinfo_reclaimable = "74_pagetypeinfo_reclaimable";
$legend{$graph_pagetypeinfo_reclaimable} = "pagetype reclaimable from /proc/pagetypeinfo"; 
$thumblegend{$graph_pagetypeinfo_reclaimable} = "PAGETYPE-RECLAIMABLE";
$unit{$graph_pagetypeinfo_reclaimable} = "MB";

my $graph_pagetypeinfo_movable = "74_pagetypeinfo_movable";
$legend{$graph_pagetypeinfo_movable} = "pagetype movable from /proc/pagetypeinfo"; 
$thumblegend{$graph_pagetypeinfo_movable} = "PAGETYPE-MOVABLE";
$unit{$graph_pagetypeinfo_movable} = "MB";

my $graph_pagetypeinfo_reserve = "74_pagetypeinfo_reserve";
$legend{$graph_pagetypeinfo_reserve} = "pagetype reserve from /proc/pagetypeinfo"; 
$thumblegend{$graph_pagetypeinfo_reserve} = "PAGETYPE-RESERVE";
$unit{$graph_pagetypeinfo_reserve} = "MB";

my $graph_events_ctx_total =    "65_ctx_total";
$legend{$graph_events_ctx_total} = "process total context switches"; 
$thumblegend{$graph_events_ctx_total} = "CTX TOTAL";
$unit{$graph_events_ctx_total} = "count per second";

my $graph_events_ctx_nonvolunt =    "66_ctx_nonvolunt";
$legend{$graph_events_ctx_nonvolunt} = "process non-voluntary context switches"; 
$thumblegend{$graph_events_ctx_nonvolunt} = "CTX NONVOLUNTARY";
$unit{$graph_events_ctx_nonvolunt} = "count per second";

my $graph_events_ctx_volunt =       "66_ctx_volunt";
$legend{$graph_events_ctx_volunt} = "process voluntary context switches"; 
$thumblegend{$graph_events_ctx_volunt} = "CTX VOLUNTARY";
$unit{$graph_events_ctx_volunt} = "count per second";

my $graph_diskstats_reads =              "68_diskstats_reads";
$legend{$graph_diskstats_reads} = "diskstats_reads"; 
$thumblegend{$graph_diskstats_reads} = "DISK_READS";
$unit{$graph_diskstats_reads} = "MB per second";

my $graph_diskstats_read_time =              "68_diskstats_read_time";
$legend{$graph_diskstats_read_time} = "diskstats_read_time"; 
$thumblegend{$graph_diskstats_read_time} = "DISKREAD TIME";
$unit{$graph_diskstats_read_time} = "ms per sector";

my $graph_diskstats_writes =              "69_diskstats_writes";
$legend{$graph_diskstats_writes} = "diskstats_writes"; 
$thumblegend{$graph_diskstats_writes} = "DISK_WRITES";
$unit{$graph_diskstats_writes} = "MB per second";

my $graph_diskstats_write_time =              "69_diskstats_write_time";
$legend{$graph_diskstats_write_time} = "diskstats_write_time"; 
$thumblegend{$graph_diskstats_write_time} = "DISKWRITE TIME";
$unit{$graph_diskstats_write_time} = "ms per sector";

my $graph_events_major_pagefaults = "70_events_major_pagefaults";
$legend{$graph_events_major_pagefaults} = "major page faults"; 
$thumblegend{$graph_events_major_pagefaults} = "PAGE FAULTS";
$unit{$graph_events_major_pagefaults} = "count per second";

my $graph_interrupts =              "70_interrupts";
$legend{$graph_interrupts} = "left:specific interrupts; right: sum of all interrupts"; 
$thumblegend{$graph_interrupts} = "INTERRUPTS";
$unit{$graph_interrupts} = "count per second";

my $graph_ctx_global =              "70_ctx_global";
$legend{$graph_ctx_global} = "left: CTX switches; right: num of processes"; 
$thumblegend{$graph_ctx_global} = "CTX-SW,PROC-NUM";
$unit_1{$graph_ctx_global} = "context switches: per second";
$unit_2{$graph_ctx_global} = "num-of-processes: count";

my $graph_processes_global =              "71_processes_created";
$legend{$graph_processes_global} = "Processes/threads created"; 
$thumblegend{$graph_processes_global} = "PROC/THREADS CREATED";
$unit{$graph_processes_global} = "count per minute";

#
# this is part of 70_ctx graph now
#
#my $graph_processes_running =              "72_num_processes";
#$legend{$graph_processes_running} = "Processes running"; 
#$thumblegend{$graph_processes_running} = "PROCESSES RUNNING";
#$unit{$graph_processes_running} = "count";

my $graph_threads_count = "73_threads_count";
$legend{$graph_threads_count} = "number of threads"; 
$thumblegend{$graph_threads_count} = "APPS THREADS";
$unit{$graph_threads_count} = "number";

my $graph_diskspace = "80_diskspace";
$legend{$graph_diskspace} = "file systems and global FD set";
$thumblegend{$graph_diskspace} = "DISK USED, GLOBAL FD %";
$unit{$graph_diskspace} = "percentage used";

my $graph_fdcount = "80_fdcount";
$legend{$graph_fdcount} = "FD use by processes";
$thumblegend{$graph_fdcount} = "FILE DESCR";
$unit{$graph_fdcount} = "number of FD";

my $graph_fdcount_inotify = "80_fdcount_inotify";
$legend{$graph_fdcount_inotify} = "inotify FD use by processes";
$thumblegend{$graph_fdcount_inotify} = "INOTIFY FILE DESCR";
$unit{$graph_fdcount_inotify} = "number of FD";

my $graph_fdcount_pipe = "80_fdcount_pipe";
$legend{$graph_fdcount_pipe} = "pipe FD use by processes";
$thumblegend{$graph_fdcount_pipe} = "PIPE FILE DESCR";
$unit{$graph_fdcount_pipe} = "number of FD";

my $graph_fdcount_socket = "80_fdcount_socket";
$legend{$graph_fdcount_socket} = "socket FD use by processes";
$thumblegend{$graph_fdcount_socket} = "SOCKET FILE DESCR";
$unit{$graph_fdcount_socket} = "number of FD";

my $graph_fdcount_tmpfs = "80_fdcount_tmpfs";
$legend{$graph_fdcount_tmpfs} = "/dev, /sys, /syspart, /proc, /tmp, /var/run FD use by processes";
$thumblegend{$graph_fdcount_tmpfs} = "TMPFS FILE DESCR";
$unit{$graph_fdcount_tmpfs} = "number of FD";

my $graph_fdcount_eventfd = "80_fdcount_eventfd";
$legend{$graph_fdcount_eventfd} = "eventfd FD use by processes";
$thumblegend{$graph_fdcount_eventfd} = "EVENTFD FILE DESCR";
$unit{$graph_fdcount_eventfd} = "number of FD";

my $graph_fdcount_epoll = "80_fdcount_epoll";
$legend{$graph_fdcount_epoll} = "epoll FD use by processes";
$thumblegend{$graph_fdcount_epoll} = "EPOLL FILE DESCR";
$unit{$graph_fdcount_epoll} = "number of FD";

my $graph_fdcount_signalfd = "80_fdcount_signalfd";
$legend{$graph_fdcount_signalfd} = "signalfd FD use by processes";
$thumblegend{$graph_fdcount_signalfd} = "SIGNALFD FILE DESCR";
$unit{$graph_fdcount_signalfd} = "number of FD";

my $graph_fdcount_timerfd = "80_fdcount_timerfd";
$legend{$graph_fdcount_timerfd} = "timerfd FD use by processes";
$thumblegend{$graph_fdcount_timerfd} = "TIMERFD FILE DESCR";
$unit{$graph_fdcount_timerfd} = "number of FD";

my $graph_fdcount_disk = "80_fdcount_disk";
$legend{$graph_fdcount_disk} = "disk FD use by processes";
$thumblegend{$graph_fdcount_disk} = "DISK FILE DESCR";
$unit{$graph_fdcount_disk} = "number of FD";

my $graph_appmem_wx = "85_appmem_wx";
$legend{$graph_appmem_wx} = "executable mem which is writable, security issue"; 
$thumblegend{$graph_appmem_wx} = "WRITABLE-EXEC";
$unit{$graph_appmem_wx} = "MB";

my $graph_battery = "88_battery";
$legend{$graph_battery} = "battery: left:charge left; right: voltage"; 
$thumblegend{$graph_battery} = "BATTERY";
$unit_1{$graph_battery} = "charge-percent, temp-C";
$unit_2{$graph_battery} = "mV";

my $graph_cgroups_mem = "89_cgroups-mem";
$legend{$graph_cgroups_mem} = "memory usage per cgroup";
$thumblegend{$graph_cgroups_mem} = "CGROUPS MEMORY";
$unit{$graph_cgroups_mem} = "MB";

my $graph_cgroups_swap = "89_cgroups-swap";
$legend{$graph_cgroups_swap} = "swap usage per cgroup";
$thumblegend{$graph_cgroups_swap} = "CGROUPS SWAP";
$unit{$graph_cgroups_swap} = "MB";

my $graph_cgroups_memsw = "89_cgroups-memsw";
$legend{$graph_cgroups_memsw} = "memory+swap usage per cgroup";
$thumblegend{$graph_cgroups_memsw} = "CGROUPS MEMORY+SWAP";
$unit{$graph_cgroups_memsw} = "MB";

my $graph_cgroups_cache = "90_cgroups-cache";
$legend{$graph_cgroups_cache} = "page cache per cgroup";
$thumblegend{$graph_cgroups_cache} = "CGROUPS PAGE CACHE";
$unit{$graph_cgroups_cache} = "MB";

my $graph_cgroups_rss = "90_cgroups-rss";
$legend{$graph_cgroups_rss} = "rss (anonymous + swap cache) per cgroup";
$thumblegend{$graph_cgroups_rss} = "CGROUPS RSS";
$unit{$graph_cgroups_rss} = "MB";

my $graph_cgroups_mapped_file = "90_cgroups-mapped_file";
$legend{$graph_cgroups_mapped_file} = "mapped file per cgroup";
$thumblegend{$graph_cgroups_mapped_file} = "CGROUPS MAPPED FILE";
$unit{$graph_cgroups_mapped_file} = "MB";

my $graph_cgroups_unevictable = "90_cgroups-unevictable";
$legend{$graph_cgroups_unevictable} = "unevictable memory per cgroup";
$thumblegend{$graph_cgroups_unevictable} = "CGROUPS UNEVICTABLE";
$unit{$graph_cgroups_unevictable} = "MB";

my $graph_cgroups_inactive_anon = "91_cgroups-inactive_anon";
$legend{$graph_cgroups_inactive_anon} = "anon + swap cache on inactive LRU list per cgroup";
$thumblegend{$graph_cgroups_inactive_anon} = "CGROUPS INACTIVE ANON";
$unit{$graph_cgroups_inactive_anon} = "MB";

my $graph_cgroups_active_anon = "91_cgroups-active_anon";
$legend{$graph_cgroups_active_anon} = "anon + swap cache on active LRU list per cgroup";
$thumblegend{$graph_cgroups_active_anon} = "CGROUPS ACTIVE ANON";
$unit{$graph_cgroups_active_anon} = "MB";

my $graph_cgroups_inactive_file = "92_cgroups-inactive_file";
$legend{$graph_cgroups_inactive_file} = "file-backed memory on inactive LRU list per cgroup";
$thumblegend{$graph_cgroups_inactive_file} = "CGROUPS INACTIVE FILE";
$unit{$graph_cgroups_inactive_file} = "MB";

my $graph_cgroups_active_file = "92_cgroups-active_file";
$legend{$graph_cgroups_active_file} = "file-backed memory on active LRU list per cgroup";
$thumblegend{$graph_cgroups_active_file} = "CGROUPS ACTIVE FILE";
$unit{$graph_cgroups_active_file} = "MB";

my $graph_cgroups_pgpgin = "93_cgroups-pgpgin";
$legend{$graph_cgroups_pgpgin} = "cgroups pages paged in";
$thumblegend{$graph_cgroups_pgpgin} = "CGROUPS PGPGIN";
$unit{$graph_cgroups_pgpgin} = "number of events";

my $graph_cgroups_pgpgout = "93_cgroups-pgpgout";
$legend{$graph_cgroups_pgpgout} = "cgroups pages paged out";
$thumblegend{$graph_cgroups_pgpgout} = "CGROUPS PGPGOUT";
$unit{$graph_cgroups_pgpgout} = "number of events";

my $graph_cgroups_process_cnt = "93_cgroups-process-cnt";
$legend{$graph_cgroups_process_cnt} = "cgroups process count";
$thumblegend{$graph_cgroups_process_cnt} = "CGROUPS PROCESS CNT";
$unit{$graph_cgroups_process_cnt} = "processes";

my $graph_cgroups_task_cnt = "93_cgroups-task_cnt";
$legend{$graph_cgroups_task_cnt} = "cgroups thread (task) count";
$thumblegend{$graph_cgroups_task_cnt} = "CGROUPS THREAD CNT";
$unit{$graph_cgroups_task_cnt} = "tasks";

my $graph_cgroups_mem_failcnt = "94_cgroups-mem_failcnt";
$legend{$graph_cgroups_mem_failcnt} = "cgroups memory fail count";
$thumblegend{$graph_cgroups_mem_failcnt} = "CGROUPS MEMORY FAILCNT";
$unit{$graph_cgroups_mem_failcnt} = "number of events";

my $graph_cgroups_memsw_failcnt = "94_cgroups-memsw_failcnt";
$legend{$graph_cgroups_memsw_failcnt} = "cgroups memory+swap fail count";
$thumblegend{$graph_cgroups_memsw_failcnt} = "CGROUPS MEMORY+SWAP FAILCNT";
$unit{$graph_cgroups_memsw_failcnt} = "number of events";

my $graph_networking_bytes = "95_networking-bytes";
$legend{$graph_networking_bytes} = "RX and TX bytes per interface in kB";
$thumblegend{$graph_networking_bytes} = "NET RX/TX BYTES";
$unit{$graph_networking_bytes} = "kB";

my $graph_networking_packets = "95_networking-packets";
$legend{$graph_networking_packets} = "RX and TX packets per interface in kB";
$thumblegend{$graph_networking_packets} = "NET RX/TX PACKETS";
$unit{$graph_networking_packets} = "packets";

#
# Note: powertop is optional. it's files are not collected
# by standard sp-endurance, but it is easy to use 
# "powertop as sleep" in measurement cycle and save 1xx/powertop.out
# If such was made, we graph something from powertop output
#
my $graph_powertop_wakeups =   "900_powertop_wakeups";
$legend{$graph_powertop_wakeups} = "Powertop-wakeups";
$thumblegend{$graph_powertop_wakeups} = "WAKEUPS";
$unit{$graph_powertop_wakeups} = "count per second";

my $graph_powertop_timers =   "905_powertop_timers";
$legend{$graph_powertop_timers} = "Powertop-timers";
$thumblegend{$graph_powertop_timers} = "TIMERS";
$unit{$graph_powertop_timers} = "count per second";

my $graph_powertop_activity_1 =   "901_powertop_activity";
$legend{$graph_powertop_activity_1} = "Powertop-activity";
$thumblegend{$graph_powertop_activity_1} = "P-ACTIVITY";
$unit{$graph_powertop_activity_1} = "events per second";

my $graph_powertop_activity_2 =   "902_powertop_activity";
$legend{$graph_powertop_activity_2} = "Powertop-activity-2";
$thumblegend{$graph_powertop_activity_2} = "P-ACTIVITY 2";
$unit{$graph_powertop_activity_2} = "events per second";

my $graph_powertop_activity_3 =   "903_powertop_activity";
$legend{$graph_powertop_activity_3} = "Powertop-activity-3";
$thumblegend{$graph_powertop_activity_3} = "P-ACTIVITY 3";
$unit{$graph_powertop_activity_3} = "events per second";

my $graph_powertop_activity_4 =   "904_powertop_activity";
$legend{$graph_powertop_activity_4} = "Powertop-activity-4";
$thumblegend{$graph_powertop_activity_4} = "P-ACTIVITY 4";
$unit{$graph_powertop_activity_4} = "events per second";

my $graph_powertop_cf_states =   "910_powertop_cf";
$legend{$graph_powertop_cf_states} = "Powertop CF-states";
$thumblegend{$graph_powertop_cf_states} = "CF-STATES";
$unit{$graph_powertop_cf_states} = "percentage";

my $graph_powertop_domain_states_1 =   "920_powertop_domain";
$legend{$graph_powertop_domain_states_1} = "Powertop Domain states";
$thumblegend{$graph_powertop_domain_states_1} = "POWERDOMAIN-STATES 1";
$unit{$graph_powertop_domain_states_1} = "percentage";

my $graph_powertop_domain_states_2 =   "921_powertop_domain";
$legend{$graph_powertop_domain_states_2} = "Powertop Domain states";
$thumblegend{$graph_powertop_domain_states_2} = "POWERDOMAIN-STATES 2";
$unit{$graph_powertop_domain_states_2} = "percentage";

# optional, swap-fragmentation is generated by another tool 
# gen_swapfrag-for-apps.pl which is not part of standard sp-endurance;
# but we put it's thumbnail on same page, if present
# note different numbering, it survives the removal of previous
# other graphs when this script deletes graphs/??_* before run
my @graph_fragmentation = (
"951_fragmentation",
"952_fragmentation",
"953_fragmentation");

my $num_of_rounds;
my @dirs;
my $show_kernelstack = 0;
my $show_shmem = 0;
my %val;
my %all_apps;
my %pid_by_namepid;
my %name_by_pid;
my (%has_threads, %has_threads_samples);
my %all_slabs;
my (%shared_lpid, %shared_cpid);
my (%shared_lpid_cnt, %shared_lpid_cnt_oneround);
my (%shared_cpid_cnt, %shared_cpid_cnt_oneround);
my %shared_lpid_names_all_sz;
my (%shared_num, %shared_size, %shared_used);
my (%fd_count, %fd_count_samples, %fd_count_diff, %fd_count_prev);
my %pss_swap_num_samples;
my %lapsed_time;
my $global_ctx_prev = 0;
my $global_processes_prev;
my $memfree_plot_file_name = "e/memfree";
my $buffers_plot_file_name = "e/buffers";
my $cached_plot_file_name = "e/cached";
my $swapcached_plot_file_name = "e/swapcached";
my $kernelstack_plot_file_name = "e/kernelstack";
my $shmem_plot_file_name = "e/shmem";
my $swapused_plot_file_name = "e/swapused";
my $dirty_plot_file_name = "e/dirty";
my $active_file_plot_file_name = "e/active_file";
my $inactive_file_plot_file_name = "e/inactive_file";
my $mlocked_plot_file_name = "e/mlocked";
my $mpixmaps_plot_file_name = "e/mpixmaps";
my $mapped_plot_file_name = "e/mapped";
my $slabreclaim_plot_file_name = "e/slabreclaim";
my $slabunreclaim_plot_file_name = "e/slabunreclaim";
my $pagetables_plot_file_name = "e/pagetables";
my $pswp_in_plot_file_name = "e/pswp_in";
my $pswp_out_plot_file_name = "e/pswp_out";
my $pgscan_kswapd_normal_plot_file_name = "e/pgscan_kswapd_normal";
my $pgscan_direct_normal_plot_file_name = "e/pgscan_direct_normal";
my $slabs_scanned_plot_file_name = "e/slabs_scanned";
my $kswapd_steal_plot_file_name = "e/kswapd_steal";
my $shared_locked_plot_file_name = "e/shared_locked";
my $shared_unlocked_plot_file_name = "e/shared_unlocked";
#my $unaccount_swapped_plot_file_name = "e/unaccount_swapped";
my $app_swapped_plot_file_name = "e/all_apps_swapped";
my $app_pss_plot_file_name = "e/all_apps_pss";
my $load_1_file_name = "e/load_1_min";
my $load_5_file_name = "e/load_5_min";
my $load_15_file_name = "e/load_15_min";
my $fd_perc_file_name = "e/global-FD-percentage";

my $batt_charge_left_file_name = "e/batt-charge-left";
#my $batt_reporting_file_name = "e/batt-reporting";
my $batt_voltage_file_name = "e/batt-voltage";
my $batt_temperature_file_name = "e/batt-temp";

my $ramzswap_bdreads_file_name = "e/ramzswap-bdreads";
my $ramzswap_reads_file_name = "e/ramzswap-reads";
my $ramzswap_bdwrites_file_name = "e/ramzswap-bdwrites";
my $ramzswap_writes_file_name = "e/ramzswap-writes";
my $ramzswap_zerop_file_name = "e/ramzswap-zerop";
my $ramzswap_used_file_name = "e/ramzswap-used";

my $pswp_in_prev = 0;
my $pswp_out_prev = 0;
my $pgscan_kswapd_normal_prev = 0;
my $pgscan_direct_normal_prev = 0;
my $slabs_scanned_prev = 0;
my $kswapd_steal_prev = 0;

my (%int_prev, %int_total);
my (%dev_reads_total, %dev_reads_prev);
my (%dev_writes_total, %dev_writes_prev);
my (%dev_time_per_read_prev, %dev_time_per_write_prev);
my %cumul_vol_ctx;
my %cumul_nonvol_ctx;
my %cumul_total_ctx;
my %param_prev_vol_ctx;
my %param_prev_nonvol_ctx;
my %majflt_prev;
my %majflt_cumul;
my %param_prev_utime;
my %param_prev_stime;
my %utime_cumul;
my %stime_cumul;
my %totaltime_cumul;
my %prev_cpu_ticks;
my %prev_cgroups_stats;
my %prev_cgroups_mem_failcnt;
my %prev_cgroups_memsw_failcnt;

my %fd_samples;
my %fd_inotify;
my %fd_pipe;
my %fd_socket;
my %fd_tmpfs;
my %fd_dev;
my %fd_sys;
my %fd_syspart;
my %fd_proc;
my %fd_eventfd;
my %fd_epoll;
my %fd_signalfd;
my %fd_timerfd;
my %fd_disk;

my %app_pss;
my %app_swapped;
my %app_sum_locked;
my (%app_sum_vmsz, %prev_vmsize, %changed_vmsize);
#my %app_private_dirty;
my %app_sysv_shared;
my %app_posix_shared;
my %app_rwxp;
my %app_dev_pvr;

my %app_cumul_pss;
my %app_cumul_swp;
#my %app_cumul_private_dirty;
my %app_cumul_pss_swp;
my %app_cumul_rwxp;
my %app_cumul_sysv_shared;
my %app_cumul_posix_shared;

my %avg_pss;
my %avg_heap;
#my %avg_private_dirty;
my %avg_swp;
my %avg_pss_swp;
my %avg_shared_lpid;
my %avg_sysv_shared;
my %avg_posix_shared;

my %devcount_pss;
my %devcount_swp;
#my %devcount_private_dirty;
my %devcount_heap;
my %devcount_pss_swp;
my %devcount_shared_lpid;
my %devcount_shared_cpid;

my %sumdev_pss;
my %sumdev_swp;
#my %sumdev_private_dirty;
my %sumdev_heap;
my %sumdev_pss_swp;
my %sumdev_shared_lpid;
my %sumdev_shared_cpid;

my %show_this;
my %xresource_latest_cnt;
my %xresource_latest_sz_pxm;
my %xresource_latest_sz_misc;
my %xres_pxm_size_total;
my %filesystem_names;
my $max_nattach = 0;

my (%images, %thumbnames);
my %xres_samples;
my %xres_atoms_seen;
my %p_activity;
my $powertop_data_found = 0;
my %seen_powertop_c_levels;
my %seen_powertop_f_levels;
my %p_activity_max;

my %sum_heap;
my %num_heap_samples;
my %max_heap;
my %num_activity_samples;

my %files;
my %secval;
my %cnt_per_file;
my %round_date;

my $have_diskstats = 0;
my $have_ramzswap = 0;
my $have_bme = 0;
my $have_pagetypeinfo = 0;

my $swapused_total = 0;
my $swap_pgout_total = 0;

my %num_of_smaps_segments;
my %max_smaps_segments;
my $steps_files = 0;

my %cgroups;
my %interfaces_seen;
my %interfaces_prev_rx_packets;
my %interfaces_prev_tx_packets;
my %interfaces_prev_rx_kB;
my %interfaces_prev_tx_kB;

my %time_in_state_freqs_seen;
my %prev_time_in_state_pcpu;

sub date2seconds($)
{
    my $linex = shift;
    my $line = $linex;
    chop $line;
    my (undef, undef, $date, $time) = split(' ', $line, 4);
    my ($year, $mon, $day) = split('-', $date, 3);
    my ($hour, $min, $sec) = split(':', $time, 3);

#    print "call timelocal d=[$date] f2=[$time] $sec, $min, $hour, $day, $mon, $year\n";                                                                             
    my $retsec = timelocal($sec, $min, $hour, $day, $mon-1, $year-1900);
#    print "call timelocal returned  $retsec\n";                                                                                                                     
    return $retsec;
}

sub one_plot_set($$$$$)
{
    my $fn = shift;
    my $lw = shift;
    my $plot = shift;
    my $r_cnt = shift;
    my $emit_zeroes = shift;

    my $num = value_emit($fn, $emit_zeroes);

    if ($num) {
	if ($$r_cnt > 0) {
	    print $plot ", ";
	}
#
# linewidth also used as flag. If not zero, it is line width
# If zero, generate histogram plot cmd instead, "using 2"
#
	if ($lw) {
	    print $plot "'$fn' lw $lw";
	} else {
	    print $plot "'$fn' using 2";
	}
	$$r_cnt += 1;
    }
}

sub value_exists($)
{
    my $fn = shift;

    if($files{$fn}) {
	return 1;
    } else {
	return 0;
    }
}

sub value_store_zeropad($$$)
{
    my $fn = shift;
    my $rnd = shift;
    my $val = shift;
    my $z;

    if (!value_exists($fn)) {
	for ($z = 0 ; $z < $rnd ; $z++) {
	    value_store($fn, $z, 0);
	}
    }
    value_store($fn, $rnd, $val);
}

sub value_store($$$)
{
    my $fn = shift;
    my $rnd = shift;
    my $val = shift;

    my $rnd_val = $rnd . ":" . $val;
    my $ra;
#    print "store: i=[$i] fn[$fn] rnd[$rnd] val[$val] rndval=[$rnd_val]\n";

    if (!value_exists($fn)) {
	$ra = [ ];
#	print "  ** store: create new array ra=$ra\n";
#	print "  ** store: store ref $ra in hash\n";
	$files{$fn} = $ra;
    } else {
	$ra = $files{$fn};
	if (! $ra) {
	    print STDERR "\nINTERNAL ERROR: *** store[$fn rnd=$rnd]: no ref in hash ?????\n";
	    exit(1);
	} else {
#	    print "  ** store: use existing ra=$ra\n";
	}
    }
#    print "  store: store idx=$rnd val=$val\n";
#    $ra[$rnd] = $val;
    push (@$ra, $rnd_val);
#    my $idx = 0;
#    foreach my $item (@{$files{$fn}}) {
#	print "  store [$fn]: i=$idx contents=$item\n";
#	$idx += 1;
#    }
}

sub count_nonzero_entries
{
    my ($ofile) = @_;
    my $ra = $files{$ofile};
    if (not $ra) {
	return 0;
    }
    my $num = 0;
    foreach (@$ra) {
	my (undef, $val) = split(':' , $_, 2);
	if ($val) {
	    $num += 1;
	}
    }
    return $num;
}

sub changes_found
{
    my ($ofile) = @_;
    my $ra = $files{$ofile};
    if (not $ra) {
	return 0;
    }
    my $changed = 0;
    my $prev_value;
    foreach (@$ra) {
	my (undef, $value) = split(':' , $_, 2);
	if ($prev_value && $value ne $prev_value) {
	    $changed = 1;
	    last;
	}
	$prev_value = $value;
    }
    return $changed;
}

sub changes_found_ignore_zeroes
{
    my ($ofile) = @_;
    my $ra = $files{$ofile};
    if (not $ra) {
	return 0;
    }
    my $changed = 0;
    my $prev_value;
    foreach (@$ra) {
	my (undef, $value) = split(':' , $_, 2);
	next if not $value;
	if ($prev_value && $value ne $prev_value) {
	    $changed = 1;
	    last;
	}
	$prev_value = $value;
    }
    return $changed;
}

sub value_emit_all_entries($$)
{
    my $ofile = shift;
    my $ra = shift;

    my $num = 0;
    foreach my $item (@$ra) {
	my ($rnd, $val) = split(':' , $item, 2);
#	print "emit: item[$item] rnd=[$rnd] val[$val]\n";
	print $ofile "$rnd, $val\n";
	$num += 1;
    }
    return $num;
}

sub value_emit_nonzero_entries($$)
{
    my $ofile = shift;
    my $ra = shift;

    my $num = 0;
    foreach my $item (@$ra) {
	my ($rnd, $val) = split(':' , $item, 2);
	if ($val) {
	    print $ofile "$rnd, $val\n";
	    $num += 1;
	}
    }
    return $num;
}

sub value_emit($$)
{
    my $fn = shift;
    my $emit_zeroes = shift;
    my $num = 0;

    my $ra = $files{$fn};
    if (! $ra) {
	print "*** emit[$fn]: no ref in hash!?\n";
	return $num;
    }
    unless (open ($ofile, "> $fn")) {
	print STDERR "ERROR: unable to create $fn: $!\n";
	exit(1);
    }

#    print "*** emit file=[$fn]\n";
    if ($emit_zeroes) {
	$num = value_emit_all_entries($ofile, $ra);
    } else {
	$num = value_emit_nonzero_entries($ofile, $ra);
    }
    close $ofile;
    if (!$num) {
	print "*** emit: file=[$fn] turned out empty, deleting\n";
	unlink($fn);
    }
    return $num;
}

#
# Data for histogram-style graph needs pre-padded zero lines
# or otherwise columns get shifted, (even if entries are numbered!)
# Line-style graphs in turn shows better without zero entries,
# or graphs starting not from start would show
# zero line and then rise to first real sample.
# In cases we re-use same data file for both,
# we delete zero lines for line graph generation
# (which happen come after histogram generation)
#
# with new store & emit technique, (starting in 0.22)
# we always have zero-padded-at-start data files,
# so we need to "clean" them from zeroes
# for cases where this is meaningful: threads

sub delete_zero_lines($)
{
    my $fn = shift;
    my $tmpf = "zeroing-tmp";
    my $sz = 0;

    if(! -s $fn) { 
	print "file $fn is empty zeros-delete!!\n";
	return $sz;
    }
#    printf("zero $fn before:\n==================\n");
#    system("cat $fn");
    rename($fn, $tmpf);
    system("grep -v \', 0\$\' zeroing-tmp > $fn");
#    printf("after:\n==================\n");
#    system("cat $fn");
#    printf("==================\n");
    $sz = -s $fn;
#
# this should not happen if files are generated correctly,
# but watch out anyway since we delete lines
# 
    if(! $sz) { 
	print "file $fn got truncated by zeros-delete!!\n";
    }
    unlink($tmpf);
    return $sz;
}

sub split_values($)
{
    my $lin = shift;
    my @values = split(',' , $lin);
    $num_values = @values;
#    print "split_val: names=$num_names [@names] values=$num_values [@values]\n";
    my $vidx = 0;
    %val = undef;
    foreach $n (@names) {
	$val{$n} = $values[$vidx];
#	print "line: assign val[$n]=$values[$vidx]\n";
	$vidx++;
    }
}

sub parse_name_state_block($)
{
    my $handle= shift;
    chop $_;
    chop $_;
    @names = split(',' , $_);
    $num_names = @names;
    while (<$handle>) {
	$line = $_;
	chop $line;
	if ($line eq "") {
	    last;
	}
	split_values($line);

	my $Name = $val{"Name"};
	my $Pid = $val{"Pid"};
	$Name =~ s/\///g;
	my $pname = $Name . "-" . $Pid;

	###############
	my $param = $val{"nonvoluntary_ctxt_switches"};
	my $nonvol_ctx = 0;
	if ($param_prev_nonvol_ctx{$pname}) {
	    $nonvol_ctx = $param  - $param_prev_nonvol_ctx{$pname};
	}
	$cumul_nonvol_ctx{$pname} += $nonvol_ctx;
	if ($lapsed_time{$i}) {
	    $nonvol_ctx /= $lapsed_time{$i};
	} else {
	    $nonvol_ctx /= $secs_per_round;
	}
	if (defined $param_prev_nonvol_ctx{$pname}) {
	    my $fn = "e/nonvol-ctx-$pname";
	    value_store($fn, $i, $nonvol_ctx);
	}
	$param_prev_nonvol_ctx{$pname} = $param;
	###############
	$param = $val{"voluntary_ctxt_switches"};
	my $vol_ctx = 0;
	if ($param_prev_vol_ctx{$pname}) {
	    $vol_ctx = $param  - $param_prev_vol_ctx{$pname};
	}
	$cumul_vol_ctx{$pname} += $vol_ctx;
	if($lapsed_time{$i}) {
	    $vol_ctx /= $lapsed_time{$i};
	} else {
	    $vol_ctx /= $secs_per_round;
	}
	my $total_ctx = $nonvol_ctx + $vol_ctx;
	if (defined $param_prev_vol_ctx{$pname}) {
	    my $fn = "e/vol-ctx-$pname";
	    value_store($fn, $i, $vol_ctx);
	    $fn = "e/total-ctx-$pname";
	    value_store($fn, $i, $total_ctx);
	}
	$cumul_total_ctx{$pname} += $total_ctx;
	$param_prev_vol_ctx{$pname} = $param;
    }
}

sub parse_shmem_block($)
{
    my $handle= shift;
    my $shared_locked = 0;
    my $shared_unlocked = 0;
    my $a_age_sum = 0;
    my $a_age_cnt = 0;
    my $d_age_sum = 0;
    my $d_age_cnt = 0;
    my $shared_cnt = 0;

    my $line = <$handle>;
    chop $line;
    @names = split(',' , $line);
    $num_names = @names;
    while (<$handle>) {
	$line = $_;
	chop $line;
	if ($line eq "") {
	    last;
	}
#		    print "use line=[$line]\n";

	$shared_cnt += 1;
	split_values($line);
	my $perms = $val{"perms"};
	my $size = $val{"size"};
	my $lpid = $val{"lpid"};
	my $cpid = $val{"cpid"};
	my $nattach = $val{"nattch"};
	my $atime = $val{"atime"};
	my $dtime = $val{"dtime"};
	#my $ctime = $val{"ctime"};

#	print "use $atime $dtime $ctime $secval\n";
	if (($nattach == 1) && (($lpid == $cpid) && ($dtime == 0))) {
	    my $a_age = $secval{$d} - $atime;
	    $a_age_sum += $a_age;
	    $a_age_cnt += 1;

	    if ($dtime) {
		my $d_age = $secval{$d} - $dtime;
		$d_age_sum += $d_age;
		$d_age_cnt += 1;
	    }
	}

	my $szxx = ($size/1024)/1024;
	$shared_num{$nattach} += 1;
	$shared_size{$nattach} += $szxx;
	$shared_used{$nattach} = 1;
	if($nattach > $max_nattach) {
	    $max_nattach = $nattach;
	}
	if ($nattach == 1) {
	#
        # only one attached process in shared segment, suspicious..
        #
#	    print "$d: 1 nattach, cpid=$cpid lpid=$lpid dtime=$dtime perms=$perms size=$size\n";
	    if (($lpid == $cpid) && ($dtime == 0)) {
		#
		# but it is really orphan only if no other process has attached
		# than creator, so we count those separately as "class zero"
		#
#		print "   *** orphan: dtime=0\n";
		my $xnattach = 0;
		$shared_num{$xnattach} += 1;
		$shared_used{$xnattach} = 1;
	    }
	}
	my $xperms = hex($perms);
	if ($xperms & 0x2000) {
#		    print "$d: xperm=[$xperms] perm=[$perms], locked\n";
	    $shared_locked += $szxx;
	} else {
#		    print "$d: xperm=[$xperms] perm=[$perms], unlocked\n";
	    $shared_unlocked += $szxx;
#		print "$d: unlocked+=$szxx, now $shared_unlocked\n";
	}
	$shared_lpid{$lpid} += $szxx;
	$shared_cpid{$cpid} += $szxx;
	# by pid only as here we dont see name, will get re-assigned
	# to name-pid hash at the end of one round
	$shared_lpid_cnt_oneround{$lpid} += 1;
	$shared_cpid_cnt_oneround{$cpid} += 1;
#		print "$d: memfree=$mfree buf=$buffers cached=$cached\n";
    }
#    if ($a_age_cnt) {
#	$a_age_avg = $a_age_sum / $a_age_cnt;
#	$fn = "e/nattach-a-age-shm";
#	value_store($fn, $i, $a_age_avg);
#    }
#    if ($d_age_cnt) {
#	$d_age_avg = $d_age_sum / $d_age_cnt;
#	$fn = "e/nattach-d-age-shm";
#	value_store($fn, $i, $d_age_avg);
#    }
    value_store_zeropad($shared_locked_plot_file_name, $i, $shared_locked);
    value_store_zeropad($shared_unlocked_plot_file_name, $i, $shared_unlocked);
    value_store_zeropad("e/count-shm", $i, $shared_cnt);
}

sub parse_pid_fd_block($)
{
    my $handle= shift;
    while (<$handle>) {
	$line = $_;
	chop $line;
	if ($line eq "") {
	    last;
	}
	my ($Pid, $FD_count, $cmdline) = split(',' , $line, 3);
	my ($Name, undef) = split(' ' , $cmdline);
	my $last_slash = rindex($Name, '/');
#		    print "fdcount:[$Name]: lastsl=$last_slash\n";
	if ($last_slash > 0) {
	    $Name = substr($Name, $last_slash + 1);
	}
#		$Name =~ s/\//\_/g;
	if ($Name) {
	    my $pname = $Name . "-" . $Pid;
#		    print "fdcount: $pname: count=$FD_count\n";
	    $fd_count{$pname} = $FD_count;
	    $fd_count_samples{$pname} += 1;
	    my $fn = "e/fd-$pname";
	    value_store($fn, $i, $FD_count);
	    if ($i > 0) {
		my $fd_diff = $fd_count_prev{$pname} - $FD_count;
		if ($fd_diff < 0) {
		    $fd_diff *= -1;
		}
		$fd_count_diff{$pname} += $fd_diff;
	    }
	    $fd_count_prev{$pname} = $FD_count;
	}
    }
}

sub parse_process_status_block($)
{
    my $handle= shift;
#    chop $_;
#    chop $_;
#    @names = split(',' , $_);
#    $num_names = @names;
    while (<$handle>) {
	$line = $_;
	chop $line;
	if ($line eq "") {
	    last;
	}
# it should go like this but here usage.csv does not have legend line
#	split_values($line);
	my ($Pid, $Name, $State, $PPid, $PGrp, $Session, $Tty, $TpGid, $Flags, $MinFlt, $CMinFlt, $MajFlt, $CMajFlt, $Utime, $Stime, $CUtime, $CStime, $Prio, $Nice, $NumThreads, $Itrealvalue, $Starttime, $Vsize, $Rss, $Rsslim, $Startcode, $Endcode, $startstack, $kstkesp, $kstkeip, $Signal, $Blocked, $Sigignore, $sigcatch, $wchan, $nswap, $cnswap, $exitsignal, $processor, $rt_prio, $policy, $delaycct_blkio_ticksm, $guest_time, $cguest_time) = split(',' , $line, 44);
#	$Name = $val{"Name"};
#	$Pid = $val{"Pid"};

	$Name =~ s/\(//g;
	$Name =~ s/\)//g;
	$Name =~ s/\///g;
	my $pname = $Name . "-" . $Pid;

	my ($param, $param_show);
	$param = $MajFlt;
#	$param = $val{"MajFlt"};
#	print "$pname: majflt=$param\n";
	if(!$majflt_prev{$pname}) {
	    $param_show = 0;
	} else {
	    $param_show = $param  - $majflt_prev{$pname};
	}
	$majflt_cumul{$pname} += $param_show;
	if ($lapsed_time{$i}) { 
	    $param_show = $param_show/$lapsed_time{$i};
	} else {
	    $param_show = 0;
	}
	if (defined $majflt_prev{$pname}) {
	    my $fn = "e/majflt-$pname";
	    value_store($fn, $i, $param_show);
	}
	$majflt_prev{$pname} = $param;

###########################
	$param = $Utime;
	my $utim = 0;
	if($param_prev_utime{$pname}) {
	    $utim = $param  - $param_prev_utime{$pname};
	}
	$utime_cumul{$pname} += $utim;
	if ($lapsed_time{$i}) {
	    $utim /= $lapsed_time{$i};
	} else {
	    $utim /= $secs_per_round;
	}
	# to make it percent value 0..100%
	$utim *= 100;
	$utim /= $ticks_per_sec;
	if (defined $param_prev_utime{$pname}) {
	    my $fn = "e/utime-$pname";
	    value_store($fn, $i, $utim);
	}
	$param_prev_utime{$pname} = $param;

###########################
	$param = $Stime;
	my $stim = 0;
	if($param_prev_stime{$pname}) {
	    $stim = $param  - $param_prev_stime{$pname};
	}
	$stime_cumul{$pname} += $stim;
	if ($lapsed_time{$i}) {
	    $stim /= $lapsed_time{$i};
	} else {
	    $stim /= $secs_per_round;
	}
	# to make it percent value 0..100%
	$stim *= 100;
	$stim /= $ticks_per_sec;
	my $ttim = $stim + $utim;
	if (defined $param_prev_stime{$pname}) {
	    my $fn = "e/stime-$pname";
	    value_store($fn, $i, $stim);
	    $fn = "e/$pname-totaltime";
	    value_store($fn, $i, $ttim);
	}
	$totaltime_cumul{$pname} += $ttim;
	$param_prev_stime{$pname} = $param;
###########################
	$param = $NumThreads;
#	$param = $val{"Threads"};
	my $fn = "e/thr-$pname";
	value_store_zeropad($fn, $i, $param);
	if ($param > 1) {
	    $has_threads{$pname} += $param;
	    $has_threads_samples{$pname} += 1;
	}
    }
}

sub parse_xresource_block($)
{
    my $handle= shift;
    chop $_;
    @names = split(',' , $_);
    $num_names = @names;

    my %xres_seen = undef;
    my $sum_all_pixmaps = 0;
    while (<$handle>) {
	$line = $_;
	chop $line;
	if ($line eq "") {
	    last;
	}
	split_values($line);

	my $Identifier = $val{"Identifier"};
	my $xresPid = $val{"PID"};
#		print "xresource line: Id=[$Identifier]\n";
	$Identifier =~ s/ /-/g;
	$Identifier =~ s/\>//g;
	$Identifier =~ s/\<//g;
	$Identifier =~ s/\(//g;
	$Identifier =~ s/\)//g;
	$Identifier =~ s/\//-/g;
	$Identifier =~ s/\|/-/g;
	$Identifier =~ s/\&/-/g;

	#
	# truncate too long names
	#
	my $sz = length $Identifier;
	if($sz > 14) {
	    $Identifier = substr($Identifier, 0, 14);
	}
	if($xresPid != -1) {
	    $Identifier = $Identifier . "-" . $xresPid;
	}
	if ($Identifier) {
	    # there are multiple "unknown" ids, make unique by appending hex value,
	    # otherwise they will added up in same line
	    if ($xres_seen{$Identifier}) {
		$Identifier = $Identifier . '-' . $val{"res-base"};
	    }
	    $xres_seen{$Identifier} = 1;
	    $xres_samples{$Identifier} += 1;

	    # The per-atom plotting is disabled for now, as it can easily
	    # generate dozen of graphs that are in most cases not very
	    # interesting.
	    if (0) {
	    foreach my $resource_atom (keys %val) {
		if ($resource_atom eq 'res-base' ||
			$resource_atom eq 'total_resource_count' ||
			$resource_atom eq 'Pixmap mem' ||
			$resource_atom eq 'Misc mem' ||
			$resource_atom eq 'Total mem' ||
			$resource_atom eq 'PID' ||
			$resource_atom eq 'Identifier') {
		    next;
		}
		$resource_atom =~ tr/ /_/;
		my $fn = "e/xres-cnt-$Identifier-${resource_atom}";
		value_store($fn, $i, $val{$resource_atom});
		$xres_atoms_seen{$resource_atom} = 1;
	    }
	    }

	    my $total_cnt;
	    if ($val{"total_resource_count"}) {
		$total_cnt = $val{"total_resource_count"};
	    } else {
		$total_cnt = $val{"Windows"} + $val{"Pixmaps"} + $val{"GCs"} + $val{"Fonts"} +
		    $val{"Cursors"} + $val{"Colormaps"} + $val{"Map entries"} + $val{"Other clients"} + 
		    $val{"Grabs"} + $val{"Pictures"} + $val{"Pictformats"} + $val{"Glyphsets"} + 
		    $val{"CRTCs"} + $val{"Modes"} + $val{"Outputs"} + $val{"Xi clients"} + $val{"Unknown"};
	    }
	    $xresource_latest_cnt{$Identifier} = $total_cnt;
	    my $fn = "e/xres-cnt-$Identifier";
	    value_store($fn, $i, $total_cnt);
	    my $pixmap_mem = $val{"Pixmap mem"};
	    $pixmap_mem =~ s/B//g;
	    $pixmap_mem /= 1024;
	    $xresource_latest_sz_pxm{$Identifier} = $pixmap_mem;
	    $fn = "e/xres-pxm-$Identifier";
	    value_store($fn, $i, $pixmap_mem);
	    $sum_all_pixmaps += $pixmap_mem;
	    $xres_pxm_size_total{$Identifier} += $pixmap_mem;
	}
    }
# system level file has MB units, so we divide it once more
    $sum_all_pixmaps /= 1024;
    value_store($mpixmaps_plot_file_name, $i, $sum_all_pixmaps);
}

sub parse_filesystem_block($)
{
    my $handle= shift;
    my %fs_entry_seen = undef;
    while (<$handle>) {
	$line = $_;
	chop $line;
	if ($line eq "") {
	    last;
	}
	my ($Filesystem,$blocks,$Used,$Available,$Use_perc,$Mounted) = split(',' , $line, 6);
	if ($Mounted && !$fs_entry_seen{$Mounted}) {
	    $om = $Mounted;
	    chop $Use_perc;
	    $fs_entry_seen{$Mounted} += 1;
	    $Mounted =~ s/\//\_/g;
#	    print "$i: om=[$om] Mounted=[$Mounted] Used=$Used seen=$fs_entry_seen{$Mounted}\n";
	    $filesystem_names{$Mounted} = $Used;
	    my $fn = "e/fs-used-$Mounted";
	    value_store($fn, $i, $Use_perc);
	}
    }
}

sub parse_memtotal_block($)
{
    my $handle= shift;
    chop $_;
    @names = split(',' , $_);
    $num_names = @names;
#		print "names=[@names]\n";

    my $line = <$handle>;
    $line =~ s/kB//g;
    chop $line;
    split_values($line);

    my $mfree = $val{"MemFree"} /1024 ;
    value_store($memfree_plot_file_name, $i, $mfree);
    my $cached = $val{"Cached"} /1024;
    value_store($cached_plot_file_name, $i, $cached);
    my $swapcached = $val{"SwapCached"} / 1024;
    value_store($swapcached_plot_file_name, $i, $swapcached);
    $swaptotal = $val{"SwapTotal"} / 1024;
    $swapfree = $val{"SwapFree"} / 1024;

    my $buffers = $val{"Buffers"} / 1024;
    value_store($buffers_plot_file_name, $i, $buffers);
    my $dirty = $val{"Dirty"} / 1024;
    value_store($dirty_plot_file_name, $i, $dirty);
    my $active_file = $val{"Active(file)"} / 1024;
    value_store($active_file_plot_file_name, $i, $active_file);
    my $inactive_file = $val{"Inactive(file)"} / 1024;
    value_store($inactive_file_plot_file_name, $i, $inactive_file);
    my $mlocked = $val{"Mlocked"} / 1024;
    value_store($mlocked_plot_file_name, $i, $mlocked);
#
# for some reason, (kernel bug?) mlocked gets less
# every few rounds sometimes, until wraps under zero
# and shows as awfully large value then..
# avoid it here and cut to zero as it spoils graph scale
# Note, this is true for Fremantle, and not seen yet on Harmattan
#
    if($mlocked >  1024) {
	$mlocked = 0;
    }
    $pagetables = $val{"PageTables"} / 1024;
    value_store($pagetables_plot_file_name, $i, $pagetables);
    my $kernelstack = $val{"KernelStack"} / 1024;
    if ($kernelstack) {
	value_store($kernelstack_plot_file_name, $i, $kernelstack);
	$show_kernelstack = 1;
    }
    my $shmem = $val{"Shmem"} / 1024;
    if ($shmem) {
	value_store($shmem_plot_file_name, $i, $shmem);
	$show_shmem = 1;
    }
#		print "$d: memfree=$mfree buf=$buffers cached=$cached kernelstack=$kernelstack shmem=$shmem\n";
}

sub parse_pages_block($)
{
    my $handle= shift;
    chop $_;
    chop $_;
    @names = split(',' , $_);
    $num_names = @names;
#		print "names=[@names]\n";

    my $line = <$handle>;
    chop $line;
    split_values($line);

    my $pptablepages = $val{"nr_page_table_pages"};
    my $pslabreclaim = $val{"nr_slab_reclaimable"};
    my $pslabunreclaim = $val{"nr_slab_unreclaimable"};
    my $pswp_in_cumul = $val{"pswpin"};
    my $pswp_out_cumul = $val{"pswpout"};
    my $pgscan_kswapd_normal_cumul = $val{"pgscan_kswapd_normal"};
    my $pgscan_direct_normal_cumul = $val{"pgscan_direct_normal"};
    my $slabs_scanned_cumul = $val{"slabs_scanned"};
    my $kswapd_steal_cumul = $val{"kswapd_steal"};
    
    $ptables = ($pptablepages * $page_size)/1024;
    my $slabreclaim = ($pslabreclaim * $page_size)/1024;
    value_store($slabreclaim_plot_file_name, $i, $slabreclaim);
    my $slabunreclaim = ($pslabunreclaim * $page_size)/1024;
    value_store($slabunreclaim_plot_file_name, $i, $slabunreclaim);

    my $swapused = $swaptotal - $swapfree;
    $swapused_total += $swapused;
    value_store($swapused_plot_file_name, $i, $swapused);

    my $divider;
    if ($lapsed_time{$i}) {
	$divider = $lapsed_time{$i};
    } else {
	$divider = $secs_per_round;
    }

    if ($pswp_in_prev) {
	my $pswp_in = ($pswp_in_cumul - $pswp_in_prev)/$divider;
	value_store_zeropad($pswp_in_plot_file_name, $i, $pswp_in);
    }
    $pswp_in_prev = $pswp_in_cumul;
#		print "$d:swpin_cumul=$pswp_in_cumul this=$pswp_in prev=$pswp_in_prev pptable=$pptablepages\n";
    # check for pagetables value sanity:
    if ((($pptablepages * $page_size)/1024) != $pagetables) {
	print "**********************************************************************************\n";
	print "***** MEM values mismatch. pagetables by mem:$pagetables vs by pages:$pptablepages\n";
	print "**********************************************************************************\n";
    }

    my $pswp_out = 0;
    if ($pswp_out_prev) {
	$pswp_out = ($pswp_out_cumul - $pswp_out_prev)/$divider;
	value_store_zeropad($pswp_out_plot_file_name, $i, $pswp_out);
    }
    $pswp_out_prev = $pswp_out_cumul;
    $swap_pgout_total += $pswp_out;

#		$pgrotated = $pgrotated_cumul - $pgrotated_prev;
#		$pgrotated_prev = $pgrotated_cumul;

    if ($pgscan_kswapd_normal_prev) {
	my $pgscan_kswapd_normal = ($pgscan_kswapd_normal_cumul - $pgscan_kswapd_normal_prev)/$divider;
	value_store_zeropad($pgscan_kswapd_normal_plot_file_name, $i, $pgscan_kswapd_normal);
    }
    $pgscan_kswapd_normal_prev = $pgscan_kswapd_normal_cumul;

    if ($pgscan_direct_normal_prev) {
	my $pgscan_direct_normal = ($pgscan_direct_normal_cumul - $pgscan_direct_normal_prev)/$divider;
	value_store_zeropad($pgscan_direct_normal_plot_file_name, $i, $pgscan_direct_normal);
    }
    $pgscan_direct_normal_prev = $pgscan_direct_normal_cumul;
    
    if ($slabs_scanned_prev) {
	my $slabs_scanned = ($slabs_scanned_cumul - $slabs_scanned_prev)/$divider;
	value_store_zeropad($slabs_scanned_plot_file_name, $i, $slabs_scanned);
    }
    $slabs_scanned_prev = $slabs_scanned_cumul;

    if ($kswapd_steal_prev) {
	my $kswapd_steal = ($kswapd_steal_cumul - $kswapd_steal_prev)/$divider;
	value_store_zeropad($kswapd_steal_plot_file_name, $i, $kswapd_steal);
    }
    $kswapd_steal_prev = $kswapd_steal_cumul;
}

sub process_slabinfo()
{
    $fn = "$d/slabinfo";
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<$f>) {
	my $idx_1 = index($_, "slabinfo");
	my $idx_2 = index($_, "# name");
	if (($idx_1 != -1) || ($idx_2 != -1)) {
	    next;
	}
	$line = $_;
	chop $line;
	my ($slabname, $active_objs, $num_objs, $obj_size,
	 undef, undef, undef, undef, undef, 
	 undef, undef, undef, undef, undef, undef, undef) = split(' ' , $line, 16);

	$slabname =~ s/ //g;
	$slabname =~ s/\>//g;
	$slabname =~ s/\<//g;
	$slabname =~ s/\(//g;
	$slabname =~ s/\)//g;
	$slabname =~ s/\//-/g;
	$slabname =~ s/\|/-/g;

	my $slab_sz = ($active_objs * $obj_size)/1024;
	$fn = "e/slabs-$slabname";
	value_store($fn, $i, $slab_sz);
	$all_slabs{$slabname} += $active_objs;
    }
    close $f;
#	print "   slabinfo_done ";
}

#/proc/12/fd/:
#total 0
#
#/proc/1205/fd/:
#total 0
#lrwx------    1 user     users           64 Feb  4 01:57 0 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 1 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 2 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 3 -> socket:[9304]
#lrwx------    1 user     users           64 Feb  4 01:57 4 -> socket:[9307]
#
#/proc/1213/fd/:
#total 0
#lrwx------    1 user     users           64 Feb  4 01:57 0 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 1 -> /dev/console
#lr-x------    1 user     users           64 Feb  4 01:57 10 -> inotify
#lr-x------    1 user     users           64 Feb  4 01:57 12 -> inotify
#lr-x------    1 user     users           64 Feb  4 01:57 13 -> pipe:[9718]
#l-wx------    1 user     users           64 Feb  4 01:57 14 -> pipe:[9718]
#lr-x------    1 user     users           64 Feb  4 01:57 15 -> pipe:[9719]
#l-wx------    1 user     users           64 Feb  4 01:57 16 -> pipe:[9719]
#lrwx------    1 user     users           64 Feb  4 01:57 17 -> socket:[9735]
#lr-x------    1 user     users           64 Feb  4 01:57 18 -> pipe:[9740]
#l-wx------    1 user     users           64 Feb  4 01:57 19 -> pipe:[9740]
#lrwx------    1 user     users           64 Feb  4 01:57 2 -> /dev/console
sub process_openfds()
{
    my $fn = "$d/open-fds";
    if (not open(OPENFDS, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my $pid;
    while (<OPENFDS>) {
	if (m#/proc/(\d+)/fd/:#) {
	    if ($pid) {
		value_store("e/fd_inotify-$name_by_pid{$pid}-$pid",   $i, $fd_inotify{$pid});
		value_store("e/fd_pipe-$name_by_pid{$pid}-$pid",      $i, $fd_pipe{$pid});
		value_store("e/fd_socket-$name_by_pid{$pid}-$pid",    $i, $fd_socket{$pid});
		value_store("e/fd_tmpfs-$name_by_pid{$pid}-$pid",     $i, $fd_tmpfs{$pid});
		value_store("e/fd_eventfd-$name_by_pid{$pid}-$pid",   $i, $fd_eventfd{$pid});
		value_store("e/fd_epoll-$name_by_pid{$pid}-$pid",     $i, $fd_epoll{$pid});
		value_store("e/fd_signalfd-$name_by_pid{$pid}-$pid",  $i, $fd_signalfd{$pid});
		value_store("e/fd_timerfd-$name_by_pid{$pid}-$pid",   $i, $fd_timerfd{$pid});
		value_store("e/fd_disk-$name_by_pid{$pid}-$pid",      $i, $fd_disk{$pid});
	    }
	    $pid = $1;
	    $fd_samples{$pid} += 1;
	    $fd_inotify{$pid} = 0;
	    $fd_pipe{$pid} = 0;
	    $fd_socket{$pid} = 0;
	    $fd_tmpfs{$pid} = 0;
	    $fd_eventfd{$pid} = 0;
	    $fd_epoll{$pid} = 0;
	    $fd_signalfd{$pid} = 0;
	    $fd_timerfd{$pid} = 0;
	    $fd_disk{$pid} = 0;
	} elsif (m#^.[rwx-]{9}\s+\d+\s+(\S+)\s+\S+\s+.*\d+ -> (\S+)#) {
	    my $username = $1;
	    my $target = $2;
	    if ($target eq 'inotify') {
		$fd_inotify{$pid} += 1;
	    } elsif ($target =~ m/^pipe:\[\d+\]$/) {
		$fd_pipe{$pid} += 1;
	    } elsif ($target =~ m/^socket:\[\d+\]$/) {
		$fd_socket{$pid} += 1;
	    } elsif ($target =~ m#^/dev/# or
	             $target =~ m#^/sys/# or
	             $target =~ m#^/syspart/# or
	             $target =~ m#^/proc/# or
	             $target =~ m#^/tmp/# or
	             $target =~ m#^/var/run/#) {
		$fd_tmpfs{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[eventfd]') {
		$fd_eventfd{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[eventpoll]') {
		$fd_epoll{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[signalfd]') {
		$fd_signalfd{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[timerfd]') {
		$fd_timerfd{$pid} += 1;
	    } elsif ($target =~ m#^/#) {
		$fd_disk{$pid} += 1;
	    } else {
		#print STDERR "UNCLASSIFIED open-fds entry: $_";
	    }
	}
    }
    close(OPENFDS);
}

# Sanitize the Control Group name so that we can use it as a file name:
# "system/applications/standby/" -> "system_applications_standby"
sub sanitize_cgroup_name
{
    my ($name) = @_;
    $name =~ s#/$##;
    $name =~ tr#/#_#;
    if ($name eq "") {
	$name = 'root';
    }
    return $name;
}

sub process_cgroups()
{
    my $fn = "$d/cgroups";
    if (not open(CGROUPS, $fn)) {
	return;
    }
    while (<CGROUPS>) {
	my $cgroup_name;
	if (m#^==> /syspart/(\S*)memory\.memsw\.usage_in_bytes <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $memsw_usage = int(<CGROUPS>) / (1024*1024);
	    value_store_zeropad("e/cgroup-${cgroup_name}-memsw", $i, $memsw_usage);
	} elsif (m#^==> /syspart/(\S*)memory\.usage_in_bytes <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $mem_usage = int(<CGROUPS>) / (1024*1024);
	    value_store_zeropad("e/cgroup-${cgroup_name}-mem", $i, $mem_usage);
	} elsif (m#^==> /syspart/(\S*)memory\.limit_in_bytes <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $mem_limit = int(<CGROUPS>);
	    if ($mem_limit != 9223372036854775807) {
		$mem_limit /= (1024*1024);
		value_store_zeropad("e/cgroup-${cgroup_name}-memlimit", $i, $mem_limit);
	    }
	} elsif (m#^==> /syspart/(\S*)memory\.stat <==#) {
	    # ==> /syspart/system/desktop/memory.stat <==
	    # cache 49410048
	    # rss 68714496
	    # mapped_file 45260800
	    # pgpgin 465491
	    # pgpgout 436652
	    # swap 17645568
	    # inactive_anon 57729024
	    # active_anon 11051008
	    # inactive_file 2899968
	    # active_file 46440448
	    # unevictable 4096
	    # hierarchical_memory_limit 157286400
	    # hierarchical_memsw_limit 9223372036854775807
	    # total_cache 49410048
	    # total_rss 68714496
	    # total_mapped_file 45260800
	    # total_pgpgin 465491
	    # total_pgpgout 436652
	    # total_swap 17645568
	    # total_inactive_anon 57729024
	    # total_active_anon 11051008
	    # total_inactive_file 2899968
	    # total_active_file 46440448
	    # total_unevictable 4096
	    #
	    # ==> ...
	    $cgroup_name = sanitize_cgroup_name($1);
	    my %stat;
	    while (<CGROUPS> =~ m#^([a-z_]+) (\d+)$#) {
		my ($key, $val) = ($1, $2);
		$stat{$key} = int($val);
	    }
	    # pgpgin and pgpgout are event counts, so collect differences
	    # between rounds:
	    if (exists $prev_cgroups_stats{$cgroup_name}) {
		my %prev_stat = %{$prev_cgroups_stats{$cgroup_name}};
		foreach (qw/pgpgin pgpgout/) {
		    my $val_now = $stat{$_};
		    my $val_prev = $prev_stat{$_};
		    my $val = $val_now - $val_prev;
		    $val = 0 if ($val < 0);
		    value_store("e/cgroup-${cgroup_name}-$_", $i, $val);
		}
	    }
	    $prev_cgroups_stats{$cgroup_name} = \%stat;
	    foreach (qw/cache rss mapped_file swap inactive_anon
			active_anon inactive_file active_file unevictable/) {
		value_store_zeropad("e/cgroup-${cgroup_name}-$_", $i,
		    $stat{$_} / (1024*1024));
	    }
	} elsif (m#^==> /syspart/(\S*)cgroup\.procs <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $procs_count = 0;
	    while (<CGROUPS> =~ m#^\d+$#) {
		$procs_count++;
	    }
	    value_store_zeropad("e/cgroup-${cgroup_name}-process-cnt", $i, $procs_count);
	} elsif (m#^==> /syspart/(\S*)tasks <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $task_count = 0;
	    while (<CGROUPS> =~ m#^\d+$#) {
		$task_count++;
	    }
	    value_store_zeropad("e/cgroup-${cgroup_name}-task-cnt", $i, $task_count);
	} elsif (m#^==> /syspart/(\S*)memory\.failcnt <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $failcnt = int(<CGROUPS>);
	    if (exists $prev_cgroups_mem_failcnt{$cgroup_name}) {
		my $failcnt_prev = $prev_cgroups_mem_failcnt{$cgroup_name};
		my $val = $failcnt - $failcnt_prev;
		$val = 0 if ($val < 0);
		value_store("e/cgroup-${cgroup_name}-mem-failcnt", $i, $val);
	    }
	    $prev_cgroups_mem_failcnt{$cgroup_name} = $failcnt;
	} elsif (m#^==> /syspart/(\S*)memory\.memsw\.failcnt <==#) {
	    $cgroup_name = sanitize_cgroup_name($1);
	    my $failcnt = int(<CGROUPS>);
	    if (exists $prev_cgroups_memsw_failcnt{$cgroup_name}) {
		my $failcnt_prev = $prev_cgroups_memsw_failcnt{$cgroup_name};
		my $val = $failcnt - $failcnt_prev;
		$val = 0 if ($val < 0);
		value_store("e/cgroup-${cgroup_name}-memsw-failcnt", $i, $val);
	    }
	    $prev_cgroups_memsw_failcnt{$cgroup_name} = $failcnt;
	}
	if ($cgroup_name) {
	    $cgroups{$cgroup_name} = 1;
	}
    }
    close(CGROUPS);
}

sub process_ifconfig()
{
    my $fn = "$d/ifconfig";
    if (not open(IFCONFIG, $fn)) {
	return;
    }
    while (<IFCONFIG>) {
	if (m/^[^ ]/) {
	    my ($interface, undef) = split(' ', $_, 2);
	    if ($interface eq '') {
		next;
	    }
	    $interface =~ tr/:/_/;
	    $interfaces_seen{$interface} = 1;
	    while (<IFCONFIG>) {
		if ($_ eq "\n") {
		    last;
		}
		my $value;
		if (m/RX packets:([0-9]+)/) {
		    my $rx = int($1);
		    if (defined $interfaces_prev_rx_packets{$interface}) {
			my $prev_rx = $interfaces_prev_rx_packets{$interface};
			if ($prev_rx <= $rx) {
			    $value = $rx - $prev_rx;
			} else {
			    $value = $rx;
			}
			value_store("e/iface-$interface-rx-packets", $i, $value);
		    }
		    $interfaces_prev_rx_packets{$interface} = $rx;
		} elsif (m/TX packets:([0-9]+)/) {
		    my $tx = int($1);
		    if (defined $interfaces_prev_tx_packets{$interface}) {
			my $prev_tx = $interfaces_prev_tx_packets{$interface};
			if ($prev_tx <= $tx) {
			    $value = $tx - $prev_tx;
			} else {
			    $value = $tx;
			}
			value_store("e/iface-$interface-tx-packets", $i, $value);
		    }
		    $interfaces_prev_tx_packets{$interface} = $tx;
		} elsif (m/RX bytes:([0-9]+).*TX bytes:([0-9]+)/) {
		    my $rx = int($1) / 1024;
		    my $tx = int($2) / 1024;
		    if (defined $interfaces_prev_rx_kB{$interface}) {
			my $prev_rx = $interfaces_prev_rx_kB{$interface};
			if ($prev_rx <= $rx) {
			    $value = $rx - $prev_rx;
			} else {
			    $value = $rx;
			}
			value_store("e/iface-$interface-rx-kB", $i, $value);
			my $prev_tx = $interfaces_prev_tx_kB{$interface};
			if ($prev_tx <= $tx) {
			    $value = $tx - $prev_tx;
			} else {
			    $value = $tx;
			}
			value_store("e/iface-$interface-tx-kB", $i, $value);
		    }
		    $interfaces_prev_rx_kB{$interface} = $rx;
		    $interfaces_prev_tx_kB{$interface} = $tx;
		}
	    }
	}
    }
    close(IFCONFIG);
}

sub process_smaps()
{
#
# smaps
#
    my $heap = 0;
    my $nm;

    my $fn = "$d/smaps.cap";
    my $lzoname = $d . "/smaps.cap.lzo";
    my $gzname = $d . "/smaps.cap.gz";
    my $xzname = $d . "/smaps.cap.xz";
    if (-e $lzoname) {
	$fn = "lzop -dc $lzoname |";
    } elsif (-e $gzname) {
	$fn = "zcat $gzname |";
    } elsif (-e $xzname) {
	$fn = "xzcat $xzname |";
    }
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    $sum_app_swapped = 0;
#    $sum_app_private_dirty = 0;
    $sum_app_pss = 0;
    %app_swapped = undef;
#    %app_private_dirty = undef;
    %app_pss = undef;
    %app_sysv_shared = undef;
    %app_posix_shared = undef;
    %app_rwxp = undef;
    %app_dev_pvr = undef;
    %num_of_smaps_segments = undef;
#    %name_by_pid = undef;
    while (<$f>) {
	if (m/^#/) {
	    if( index($_, "#Name: ") != -1) {
		$line = $_;
		chop $line;
		#
		# before taking new name into $nm, store
		# heap for previous.
		# This is because heap comes in multiple segments
		#
		$avg_heap{$nm} = ($avg_heap{$nm} * $i + $heap)/($i+1);
		my $dev = ($avg_heap{$nm} - $heap);
		if ($dev < 0) {
		    $dev = -1 * $dev;
		}
		$sumdev_heap{$nm} += $dev;
		$devcount_heap{$nm} += 1;
		if($heap > $max_heap{$nm}) {
		    $max_heap{$nm} = $heap;
		}
		$fn = "e/heap-$nm";
		$sum_heap{$nm} += $heap;
		$num_heap_samples{$nm} += 1;
		my $xxx = $heap / 1024;
		value_store_zeropad($fn, $i, $xxx);
		$heap = 0;

		###### now start with new name
		(undef, $nm) = split(' ' , $line, 2);

		#
		# some are really long names (hald-bla-bla 384 chars)
		#
		my $sz = length $nm;
		if($sz > 64) {
		    $nm = substr($nm, 0, 64);
		}
		$nm =~ s/\(//g;
		$nm =~ s/\)//g;
		$nm =~ s/\///g;
#		print "length=$sz nm=[$nm]\n";
		next;
	    }
	    if( index($_, "#Pid: ") != -1) {
		$line = $_;
		chop $line;
		my (undef, $s_pid) = split(' ' , $line, 2);
		$name_by_pid{$s_pid} = $nm;
		$nm = $nm . "-" . $s_pid;
		$app_swapped{$nm} = 0;
#		$app_private_dirty{$nm} = 0;
		$app_pss{$nm} = 0;
		# create mapping from pid to name-pid
		$pid_by_namepid{$nm} = $s_pid;
		$all_apps{$nm} = 1;
		next;
	    }
	    if( index($_, "#VmLck: ") != -1) {
		$line = $_;
		chop $line;
		my (undef, $locked) = split(' ' , $line, 2);
		$fn = "e/locked-$nm";
		$app_sum_locked{$nm} += $locked;
		my $xxx = $locked / 1024;
		value_store_zeropad($fn, $i, $xxx);
		next;
	    }
	    if( index($_, "#VmSize: ") != -1) {
		$line = $_;
		chop $line;
		my (undef, $vmsz) = split(' ' , $line, 2);
		$fn = "e/vmsz-$nm";
		$app_sum_vmsz{$nm} += $vmsz;
		my $xxx = $vmsz / 1024;
		value_store_zeropad($fn, $i, $xxx);
		if ($prev_vmsize{$nm} && ($prev_vmsize{$nm} != $vmsz)) {
		    $changed_vmsize{$nm} = 1;
		}
		$prev_vmsize{$nm} = $vmsz;
		next;
	    }
	} elsif (m#^[A-Z]#) {
	    if( index($_, "Pss:") != -1) {
		$line = $_;
		chop $line;
		my (undef, $pss, undef) = split(' ' , $line, 3);
		$sum_app_pss += $pss;
		$app_pss{$nm} += $pss;
		$num_of_smaps_segments{$nm} += 1;
		next;
	    }
#	    if( index($_, "Private_Dirty:") != -1) {
#		$line = $_;
#		chop $line;
#		(undef, $pdirty, undef) = split(' ' , $line, 3);
#		$sum_app_private_dirty += $pdirty;
#		$app_private_dirty{$nm} += $pdirty;
#		next;
#	    }
	    if( index($_, "Swap:") != -1) {
		$line = $_;
		chop $line;
		my (undef, $swapped, undef) = split(' ' , $line, 3);
		$sum_app_swapped += $swapped;
		$app_swapped{$nm} += $swapped;
		next;
	    }
	} else {
	    if( index($_, "[heap]") != -1) {
		my $line = <$f>;
		chop $line;
		my (undef, $xheap, undef) = split(' ' , $line, 3);
		$heap += $xheap;
		# will register this value before new $nm is set
		next;
	    }
	    if( index($_, "/dev/shm/") != -1) {
		my $line = <$f>;
		chop $line;
		my (undef, $posix_shared, undef) = split(' ' , $line, 3);
		$app_posix_shared{$nm} += $posix_shared;
		next;
	    }
	    if( index($_, "/dev/pvrsrvkm") != -1) {
		my $line = <$f>;
		chop $line;
		my (undef, $pvr, undef) = split(' ' , $line, 3);
		$app_dev_pvr{$nm} += $pvr;
		next;
	    }
	    if( index($_, " rwxp ") != -1) {
		my $line = <$f>;
		chop $line;
		my (undef, $sz_wx, undef) = split(' ' , $line, 3);
		$app_rwxp{$nm} += $sz_wx;
		next;
	    }
	    if( m#/SYSV[0-9a-f]{8,}# ) {
		my $line = <$f>;
		chop $line;
		my (undef, $sysv_shared, undef) = split(' ' , $line, 3);
		$app_sysv_shared{$nm} += $sysv_shared;
		next;
	    }
	}
    }
    close $f;
#	print "   smaps_done ";
    $sum_app_swapped /= 1024;
#    $sum_app_private_dirty /= 1024;
    $sum_app_pss /= 1024;
}

sub process_interrupts()
{
#
# interrupts
#
    my $all_ints = 0;

    $fn = $d . "/interrupts";
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<$f>) {
	$line = $_;
	chop $line;
	my ($int_num, $int_cnt, undef, $int_name1, $int_name2, $int_name3, $int_name4) = split(' ' , $line);
	chop $int_num;
	my $iname = $int_num . '-' . $int_name1 . $int_name2 . $int_name3 . $int_name4;
	
	my $ints = 0;
	if (!$int_prev{$iname} or !$lapsed_time{$i}) {
	    $ints = 0;
	} else {
	    $ints = ($int_cnt - $int_prev{$iname})/$lapsed_time{$i};
	}
	$int_prev{$iname} = $int_cnt;
	$int_total{$iname} += $ints;
	$all_ints += $ints;
	$fn = "e/int-$iname";
	value_store($fn, $i, $ints);
#	print "$i: ints-per-sec=$ints int_cnt=$int_cnt num=[$int_num] name=[$iname] nm=[$int_name1] nm2=[$int_name2] nm3=[$int_name3] nm4=[$int_name4]\n";
    }
    close $f;
    value_store("e/count-int", $i, $all_ints);
}

sub process_diskstats()
{
#
# diskstats
#
    my $fn = $d . "/diskstats";
    if (! -e $fn) {
	#
        # this is optional as it was added later to snapshots,
        # just return if not there
        #
	return;
    }
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<$f>) {
	$line = $_;
	chop $line;
	my ($majdev, $mindev, $dname,
	 $xdev_reads, $xdev_reads_merged, $xsector_reads, $xmsec_reading, $xdev_writes, $dxev_writes_merged,
	 $xsector_writes, $xmsec_writing, $xios_in_progress, $xmsec_in_io, $xmsec_weighted_in_io) = split(' ' , $line, 14);
	if (($xdev_reads + $xdev_writes) == 0) {
	    next;
	}
	
	my $nreads = 0;
	my $reads = 0;
	if ($dev_reads_prev{$dname} and $lapsed_time{$i}) {
#	    $reads = ($xdev_reads - $dev_reads_prev{$dname})/$lapsed_time{$i};
	    $nreads = $xsector_reads - $dev_reads_prev{$dname};
	    $reads = ((($nreads * $sector_sz)/($MB_bytes)))/$lapsed_time{$i};
	}
#	$dev_reads_prev{$dname} = $xdev_reads;
	$dev_reads_prev{$dname} = $xsector_reads;
	$dev_reads_total{$dname} += $reads;
	$fn = "e/devreads-$dname";
	value_store($fn, $i, $reads);

	my $nwrites = 0;
	my $writes = 0;
	if ($dev_writes_prev{$dname} and $lapsed_time{$i}) {
#	    $writes = ($xdev_writes - $dev_writes_prev{$dname})/$lapsed_time{$i};
	    $nwrites = $xsector_writes - $dev_writes_prev{$dname};
	    $writes = ((($nwrites * $sector_sz)/($MB_bytes)))/$lapsed_time{$i};
	}
#	$dev_writes_prev{$dname} = $xdev_writes;
	$dev_writes_prev{$dname} = $xsector_writes;
	$dev_writes_total{$dname} += $writes;
	$fn = "e/devwrites-$dname";
	value_store($fn, $i, $writes);

	my $time_per_read = 0;
	if ($dev_time_per_read_prev{$dname}) {
	    if ($nreads) {
		$time_per_read = ($xmsec_reading - $dev_time_per_read_prev{$dname})/$nreads;
	    }
	}
	$dev_time_per_read_prev{$dname} = $xmsec_reading;
	$fn = "e/devreadtime-$dname";
	value_store($fn, $i, $time_per_read);

	my $time_per_write = 0;
	if ($dev_time_per_write_prev{$dname}) {
	    if ($nwrites) {
		$time_per_write = ($xmsec_writing - $dev_time_per_write_prev{$dname})/$nwrites;
	    }
	}
	$dev_time_per_write_prev{$dname} = $xmsec_writing;
	$fn = "e/devwritetime-$dname";
	value_store($fn, $i, $time_per_write);
	$have_diskstats = 1;
    }
    close $f;
}

sub process_bme()
{
#
# bme values (battery mgmt)
#
    my $fn = $d . "/bmestat";
    if (! -e $fn) {
	#
        # as this is new (added in sp-endurance 2.2.1+0m6 in 2011w9), 
	# it may be missing in snapshots, just return silently if not there
        #
	return;
    }
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    $have_bme = 1;
    while (<$f>) {
	if (m/battery pct. level:/) {
	    my (undef, undef, undef, $batt_lev) = split(' ' , $_, 4);
	    chop $batt_lev;
#	    print "$i: batt_lev=[$batt_lev]\n";
	    value_store($batt_charge_left_file_name, $i, $batt_lev);
	} 
	elsif (m/battery cur. voltage:/) {
	    my (undef, undef, undef, $volt) = split(' ' , $_, 4);
	    chop $volt;
#	    print "$i: batt_volt=[$volt]\n";
	    value_store($batt_voltage_file_name, $i, $volt);
	}
	elsif (m/battery temperature:/) {
	    my (undef, undef, $batt_temp) = split(' ' , $_, 3);
	    chop $batt_temp;
#	    print "$i: batt_temp=[$batt_temp]\n";
	    value_store($batt_temperature_file_name, $i, $batt_temp);
	}
    }
    close $f;
}


sub process_ramzswap()
{
#
# Compressed swap values
#
    my $fn = $d . "/ramzswap";
    if (! -e $fn) {
	#
        # as this is optional, may be missing in snapshots,
        # just return silently if not there
        #
	return;
    }
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my $divider;
    if ($lapsed_time{$i}) {
	$divider = $lapsed_time{$i};
    } else {
	$divider = $secs_per_round;
    }
    while (<$f>) {
	if (m/BDevNumReads:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_bdreads = 0;
	    if ($prev_ramzswap_bdreads) {
		$n_bdreads = ($param  - $prev_ramzswap_bdreads)/$divider;
	    }
#	    print "$i: n_bdreads=$n_bdreads\n";
	    value_store($ramzswap_bdreads_file_name, $i, $n_bdreads);
	    $prev_ramzswap_bdreads = $param;
	} elsif (m/NumReads:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_reads = 0;
	    if ($prev_ramzswap_reads) {
		$n_reads = ($param  - $prev_ramzswap_reads)/$divider;
	    }
#	    print "$i: n_reads=$n_reads div=$divider\n";
	    value_store($ramzswap_reads_file_name, $i, $n_reads);
	    $prev_ramzswap_reads = $param;
	} elsif (m/BDevNumWrites:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_bdwrites = 0;
	    if ($prev_ramzswap_bdwrites) {
		$n_bdwrites = ($param  - $prev_ramzswap_bdwrites)/$divider;
	    }
#	    print "$i: n_bdwrites=$n_bdwrites\n";
	    value_store($ramzswap_bdwrites_file_name, $i, $n_bdwrites);
	    $prev_ramzswap_bdwrites = $param;
	} elsif (m/NumWrites:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_writes = 0;
	    if ($prev_ramzswap_writes) {
		$n_writes = ($param  - $prev_ramzswap_writes)/$divider;
	    }
#	    print "$i: n_writes=$n_writes\n";
	    value_store($ramzswap_writes_file_name, $i, $n_writes);
	    $prev_ramzswap_writes = $param;
	} elsif (m/ZeroPages:/) {
	    my (undef, $zerop) = split(' ' , $_, 2);
	    my $zerom = ($zerop * $page_size)/1024;
#	    print "$i: n_zerop=$zerom\n";
	    value_store($ramzswap_zerop_file_name, $i, $zerom);
	} elsif (m/PagesUsed:/) {
	    my (undef, $n_usedp) = split(' ' , $_, 2);
	    my $used = ($n_usedp * $page_size)/1024;
#	    print "$i: nused=$n_usedp used=$used\n";
	    value_store($ramzswap_used_file_name, $i, $used);
	    $have_ramzswap = 1;
	}
    }
    close $f;
}


sub process_stat()
{
#
# CPU stat, global ctxts etc
#
    my $fn = $d . "/stat";
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<$f>) {
	$line = $_;
	chop $line;
	if( m/ctxt /) {
	    my (undef, $ctx) = split(' ' , $_, 2);

	    my $global_ctx = 0;
	    if (!$global_ctx_prev) {
		$global_ctx = 0;
	    } elsif (($ctx - $global_ctx_prev) < 0) {
		$global_ctx = 0;
	    } elsif (!$lapsed_time{$i}) {
		$global_ctx = 0;
	    } else {
		$global_ctx = ($ctx - $global_ctx_prev)/$lapsed_time{$i};
	    }
	    $global_ctx_prev = $ctx;
	    if ($i > 0) {
		value_store("e/all-ctx-switches", $i, $global_ctx);
	    }
	} elsif(m/cpu  (\d+) (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)/) {
	    my %cpu_ticks = (
		sum => $1 + $2 + $3 + $4 + $5 + $6 + $7,
		user => $1,
		nice => $2,
		sys => $3,
		idle => $4,
		iowait => $5,
		irq => $6,
		softirq => $7,
	    );
	    if (%prev_cpu_ticks) {
		foreach (qw/user nice sys idle iowait irq softirq/) {
		    value_store_zeropad("e/cpu-$_", $i,
			100 * (($cpu_ticks{$_} - $prev_cpu_ticks{$_}) /
			    ($cpu_ticks{sum} - $prev_cpu_ticks{sum})));
		}
	    }
	    %prev_cpu_ticks = %cpu_ticks;
	} elsif( m/processes /) {
	    my (undef, $processes) = split(' ' , $line, 2);

	    my $global_processes = 0;
	    if ($global_processes_prev and $lapsed_time{$i}) {
		$global_processes = (60*($processes - $global_processes_prev))/$lapsed_time{$i};
	    }
	    $global_processes_prev = $processes;
	    if ($i > 0) {
		value_store("e/global-processes", $i, $global_processes);
	    }
	    last;
	}
    }
    close $f;
}

sub process_pagetypeinfo()
{
#
# CPU stat, global ctxts etc
#
    my $fn = $d . "/pagetypeinfo";
    if (! -e $fn) {
	#
        # as this is optional, may be missing in snapshots,
        # just return silently if not there
        #
	return;
    }
    unless (open($f, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my (@unmovable, @reclaimable, @movable, @reserve);
    while (<$f>) {
	$line = $_;
	chop $line;
	if( m/Node /) {
	    $have_pagetypeinfo = 1;
	    if (m/Unmovable/) {
		(@unmovable) = split(' ' , $line, 17);
	    } elsif (m/Reclaimable/) {
		(@reclaimable) = split(' ' , $line, 17);
	    } elsif (m/Movable/) {
		(@movable) = split(' ' , $line, 17);
	    } elsif (m/Reserve/) {
		(@reserve) = split(' ' , $line, 17);
	    } 
	}
    }
    close $f;
    for ($ordernum = 0, $order = 1 ; $ordernum <= 10 ; $order *= 2, $ordernum++) {
	$fn = "e/pt-unmov-$ordernum";
	value_store($fn, $i, ($unmovable[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-recl-$ordernum";
	value_store($fn, $i, ($reclaimable[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-mov-$ordernum";
	value_store($fn, $i, ($movable[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-reserve-$ordernum";
	value_store($fn, $i, ($reserve[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
    }
}

# ==> /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state <==
# 1000000 23307374
# 800000 1039046
# 600000 785700
# 300000 1588381
sub process_sysfs_cpu
{
    my $fn = "$d/sysfs_cpu";
    if (not open(SYSFS, $fn)) {
	return;
    }
    while (<SYSFS>) {
	if (m#^==> /sys/devices/system/cpu/cpu(\d+)/cpufreq/stats/time_in_state <==#) {
	    my $cpu_num = $1;
	    if (not $time_in_state_freqs_seen{$cpu_num}) {
		$time_in_state_freqs_seen{$cpu_num} = {};
	    }
	    my %time_in_state;
	    while (<SYSFS> =~ m#(\d+)\s+(\d+)#) {
		my ($freq, $ticks) = (int($1), int($2));
		$freq /= 1000;
		$time_in_state{$freq} = $ticks;
		$time_in_state_freqs_seen{$cpu_num}->{$freq} = 1;
	    }
	    if ($prev_time_in_state_pcpu{$cpu_num}) {
		my %prev_time_in_state = %{$prev_time_in_state_pcpu{$cpu_num}};
		my $total_ticks = sum(values(%time_in_state)) - sum(values(%prev_time_in_state));
		if ($total_ticks != 0) {
		    foreach my $freq (keys(%time_in_state)) {
			my $ticks = $time_in_state{$freq};
			my $prev_ticks = $prev_time_in_state{$freq};
			my $pct = 100 * (($ticks - $prev_ticks) / $total_ticks);
			value_store_zeropad("e/sysfs_cpu${cpu_num}_${freq}mhz", $i, $pct);
		    }
		}
	    }
	    $prev_time_in_state_pcpu{$cpu_num} = \%time_in_state;
	}
    }
    close(SYSFS);
}

sub emit_domain_values($$)
{
    my $line = shift;
    my $domain = shift;
    chop $line;
#    print "powerdomain $domain: line=[$line]\n";
    my (undef, $off, $ret, $ina, $on) = split('\|' , $line, 6);
    (undef, $off) = split(':' , $off, 2);
    (undef, $ret) = split(':' , $ret, 2);
    (undef, $ina) = split(':' , $ina, 2);
    (undef, $on) = split(':' , $on, 2);

    value_store_zeropad("e/p-domain-$domain-off", $i, $off);
    value_store_zeropad("e/p-domain-$domain-ret", $i, $ret);
    value_store_zeropad("e/p-domain-$domain-ina", $i, $ina);
    value_store_zeropad("e/p-domain-$domain-on", $i, $on);
}

sub process_powertop()
{
#
# powertop output if exists
#
    my $fn = $d . "/powertop.out";
    unless (open($f, $fn)) {
	return;
    }
    $powertop_data_found = 1;
    while (<$f>) {
	$line = $_;
	chop $line;
	if( m/Collecting data for /) {
	    (undef, undef, undef, $secs, undef) = split(' ' , $line, 5);
	    next;
	} elsif( index($_, "C#") != -1) {
	    $line = <$f>;
	    while (<$f>) {
		$line = $_;
		if ($line eq "\n") {
		    last;
		}
		chop $line;
		chop $line;
# 
# it used to be like this:
#C#      | Ratio  | Avg/dura | Frequency | Ratio
#--------+--------+----------+-----------+--------+
#     C0 |  95.4% |          |  1000 MHz |  95.4% |
#     C1 |   0.2% |   11.2ms |   800 MHz |   0.0% |
#
#but startin with powertop  1.13.61 changed to separate tables:
#----------------------------+  +--------------------+
#     Available C-States     |  |   Available Freqs  |
#--------+--------+----------+  +-----------+--------+
#C#      | Ratio  | Avg/dura |  | Frequency | Ratio  |
#--------+--------+----------+  +-----------+--------+
#     C0 |   0.4% |          |  |  1000 MHz |   0.0% |
#     C1 |   0.4% |    0.3ms |  |   800 MHz |   0.0% |

#
# so I replace "|  |" with "|" (i.e. to have old style) for uniform parsing
#
#		print "power-c line=[$line]\n";
		$line =~ s/\|  \|/|/g;
#		print "xxxpower-c line=[$line]\n";
		my ($clev, $ratio_c, $dura, $freq, $ratio_f) = split('\|' , $line, 5);
#		if (index($clev, "C") == -1) {
#		    last;
#		}
		$clev =~ s/ //g;
#		print "power-c clev=[$clev]\n";
		value_store_zeropad("e/$clev", $i, $ratio_c);
		$seen_powertop_c_levels{$clev} = 1;
		if (index($freq, "MHz") != -1) {
		    $freq =~ s/ //g;
#		    print "power-c freq=[$freq]\n";
		    value_store_zeropad("e/$freq", $i, $ratio_f);
		    $seen_powertop_f_levels{$freq} = 1;
		}
	    }
	} elsif( index($_, "PID#") != -1) {
	    $line = <$f>;
	    while (true) {
		$line = <$f>;
#		print "$i:line=[$line]\n";
		if ($line eq "\n") {
		    last;
		}
		my ($pid, $activ, $name, $func) = split('\|' , $line, 4);
		($func, undef) = split(' ' , $func, 2);
		my $id = $name . "-" . $pid . "-" . $func; 
		$id =~ s/ //g;
		$id =~ s/\<//g;
		$id =~ s/\>//g;
		$id =~ s/\///g;
#		print "$i:id=[$id] [pid[$pid], activ[$activ], name[$name], func[$func]\n";
		$activ /= $secs;
		value_store("e/$id-activity", $i, $activ);
		$num_activity_samples{$id} += 1;
		$p_activity{$id} += $activ;
		if ($activ > $p_activity_max{$id}) {
		    $p_activity_max{$id} = $activ;
		}
	    }
	} elsif( index($_, "per |OFF:") != -1) {
	    emit_domain_values($_, "periph");
	} elsif( index($_, "core |OFF:") != -1) {
	    emit_domain_values($_, "core");
	} elsif( index($_, "neon |OFF:") != -1) {
	    emit_domain_values($_, "neon");
	} elsif( index($_, "sgx |OFF:") != -1) {
	    emit_domain_values($_, "sgx");
	} elsif( index($_, "dss |OFF:") != -1) {
	    emit_domain_values($_, "dss");
	} elsif( index($_, "mpu |OFF:") != -1) {
	    emit_domain_values($_, "mpu");
	} elsif( index($_, "Total wakeups") != -1) {
	    $line = $_;
	    my (undef, undef, $wakeups, $wakeups_s, undef,
	     undef, $irqs, $irqs_s, undef, 
	     undef, $timers, $timers_s, undef) = split(' ' , $line, 13);
	    $wakeups_s =~ s/s//g;
	    $wakeups_s =~ s/\///g;
	    value_store("e/p-wakeups", $i, $wakeups_s);
	    $timers_s =~ s/s//g;
	    $timers_s =~ s/\///g;
	    value_store("e/p-timers", $i, $timers_s);
	}
    }
    close $f;
}

sub parse_component_version
{
    my $fn = "$d/component_version";
    unless (open(COMPONENT_VERSION, $fn)) {
	print STDERR "ERROR: unable to open $fn: $!\n";
	exit(1);
    }
    while (<COMPONENT_VERSION>) {
	if (m/product/) {
	    chop;
	    (undef, $hw_product) = split(' ', $_, 2);
	    next;
	} elsif (m/hw-build/) {
	    chop;
	    (undef, $hw_build) = split(' ', $_, 2);
	    last;
	}
    }
    close(COMPONENT_VERSION);
#print "hw_product=[$hw_product] hw_build=[$hw_build]\n";
}

sub loop_over_all_apps()
{
    my %shared_lpid_names_sz = undef;
#
# use same hash keys set for two things (and sum of them is 3rd)
#
    foreach my $x (keys %all_apps) {
	my $fn;
	my $xxx;
	if (!$x) {
	    next;
	}
#	    print "$x ";

	###############
	if ($app_pss{$x}) {
	    $app_cumul_pss{$x} += $app_pss{$x};
	    $avg_pss{$x} = ($avg_pss{$x} * $i + $app_pss{$x})/($i+1);
	    my $dev = ($avg_pss{$x} - $app_pss{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_pss{$x} += $dev;
	    $devcount_pss{$x} += 1;
	}
#	    print "$i:$x:PSS: pss=$app_pss{$x} dev=$dev dev_cnt=$devcount_pss{$x} avg=$avg_pss{$x}\n";
#	if ($i == 0) {
#	    print "$app_pss{$x} $x\n";
#	}

	$fn = "e/p-$x";
	$xxx = $app_pss{$x} / 1024;
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_sysv_shared{$x}) {
	    $app_cumul_sysv_shared{$x} += $app_sysv_shared{$x};
	    $avg_sysv_shared{$x} = ($avg_sysv_shared{$x} * $i + $app_sysv_shared{$x})/($i+1);
	    my $dev = ($avg_sysv_shared{$x} - $app_sysv_shared{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_sysv_shared{$x} += $dev;
	    $devcount_sysv_shared{$x} += 1;
	}
#	print "$i:$x:SYSV: pss=$app_sysv_shared{$x} dev=$dev dev_cnt=$devcount_sysv_shared{$x} avg=$avg_sysv_shared{$x}\n";

	$fn = "e/sysvshm-$x";
	$xxx = $app_sysv_shared{$x} / 1024;
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_posix_shared{$x}) {
	    $app_cumul_posix_shared{$x} += $app_posix_shared{$x};
	    $avg_posix_shared{$x} = ($avg_posix_shared{$x} * $i + $app_posix_shared{$x})/($i+1);
	    my $dev = ($avg_posix_shared{$x} - $app_posix_shared{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_posix_shared{$x} += $dev;
	    $devcount_posix_shared{$x} += 1;
	}
#	print "$i:$x:POSIX: pss=$app_posix_shared{$x} dev=$dev dev_cnt=$devcount_posix_shared{$x} avg=$avg_posix_shared{$x}\n";

	$fn = "e/posixshm-$x";
	$xxx = $app_posix_shared{$x} / 1024;
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_dev_pvr{$x}) {
	    $app_cumul_dev_pvr{$x} += $app_dev_pvr{$x};
	    $avg_dev_pvr{$x} = ($avg_dev_pvr{$x} * $i + $app_dev_pvr{$x})/($i+1);
	    my $dev = ($avg_dev_pvr{$x} - $app_dev_pvr{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_dev_pvr{$x} += $dev;
	    $devcount_dev_pvr{$x} += 1;
	}

	$fn = "e/devpvr-$x";
	$xxx = $app_dev_pvr{$x} / 1024;
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_swapped{$x}) {
	    $app_cumul_swp{$x} += $app_swapped{$x};

	    $avg_swp{$x} = ($avg_swp{$x} * $i + $app_swapped{$x})/($i+1);
	    my $dev = ($avg_swp{$x} - $app_swapped{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_swp{$x} += $dev;
	    $devcount_swp{$x} += 1;
	}
	$fn = "e/swp-$x";
	$xxx = $app_swapped{$x} / 1024;
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_rwxp{$x}) {
	    $app_cumul_rwxp{$x} += $app_rwxp{$x};
	}
	$fn = "e/$x-wx";
	$xxx = $app_rwxp{$x} / 1024;
	value_store_zeropad($fn, $i, $xxx);

	###############
#	if ($app_private_dirty{$x}) {
#	    $app_cumul_private_dirty{$x} += $app_private_dirty{$x};
#
#	    $avg_private_dirty{$x} = ($avg_private_dirty{$x} * $i + $app_private_dirty{$x})/($i+1);
#	    my $dev = ($avg_private_dirty{$x} - $app_private_dirty{$x});
#	    if ($dev < 0) {
#		$dev = -1 * $dev;
#	    }
#	    $sumdev_private_dirty{$x} += $dev;
#	    $devcount_private_dirty{$x} += 1;
#	}
#	$fn = "e/$x-pdirty";
#	if ( ! -e $fn) {
#	    for ($z = 0 ; $z < $i ; $z++) {
#		system("echo '$z, 0' >> $fn");
#	    }
#	}
#	$xxx = $app_private_dirty{$x} / 1024;
#	system("echo '$i, $xxx' >> $fn");

	###############
	$pss_swap = ($app_pss{$x} + $app_swapped{$x})/1024;
	if ($pss_swap) {
	    $app_cumul_pss_swp{$x} += $pss_swap;

#		$avg_pss_swp{$x} = ($avg_pss_swp{$x} * $i + $pss_swap)/($i+1);
	    $avg_pss_swp{$x} = ($avg_pss_swp{$x} * $devcount_pss_swp{$x} + $pss_swap)/($devcount_pss_swp{$x} + 1);
	    my $dev = ($avg_pss_swp{$x} - $pss_swap);
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_pss_swp{$x} += $dev;
	    $devcount_pss_swp{$x} += 1;
	    $pss_swap_num_samples{$x} += 1;
	}
	$fn = "e/pswp-$x";
	value_store_zeropad($fn, $i, $pss_swap);

#	if ($i == 0) {
#	    print "$pss_swap $x\n";
#	}
	###############
	my $pid = $pid_by_namepid{$x};
	my $lpid_name = $name_by_pid{$pid} ;
#	print "$i: lpid_name by pid=[$pid] is [$lpid_name]\n";
	if (defined $shared_lpid_cnt_oneround{$pid}) {
	    $shared_lpid_cnt{$x} += $shared_lpid_cnt_oneround{$pid};
	}
	if (defined $shared_cpid_cnt_oneround{$pid}) {
	    $shared_cpid_cnt{$x} += $shared_cpid_cnt_oneround{$pid};
	}

	$shared = $shared_lpid{$pid};
	$fn = "e/shml-$x";
	if ($shared) {
#	    print "$i: lpid shared[x=$x pid=$pid] = $shared\n";
	    value_store_zeropad($fn, $i, $shared);
	    $avg_shared_lpid{$pid} = ($avg_shared_lpid{$pid} * $i + $shared)/($i+1);
	    my $dev = ($avg_shared_lpid{$pid} - $shared);
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_shared_lpid{$x} += $dev/$shared;
	    $devcount_shared_lpid{$x} += 1;
#		print "   lpid: inc devcount[$x] now = $devcount_shared_lpid{$x}\n";
	#
	# also by name-only. sum  up different shm mappings for apps that
	# have carried different PIDs. After this loop we loop over app names
	# and insert values there.
	#
	    if ($shared_lpid_cnt_oneround{$pid}) {
		if ($lpid_name) {
#		print "lpid-name: pid=$pid name=$lpid_name cnt=$shared_lpid_cnt_oneround{$pid};\n";
		    $shared_lpid_names_all_sz{$lpid_name} += $shared;
		    $shared_lpid_names_sz{$lpid_name} += $shared;
		}
		else {
		    print "$i: lpid-name: pid=$pid name=$lpid_name cnt=$shared_lpid_cnt_oneround{$pid};\n";
		}
	    }
	    

	} else {
	    value_store_zeropad($fn, $i, 0);
	    if ($lpid_name) {
		$shared_lpid_names_sz{$lpid_name} += 0;
	    }
	}
	# clear value or it remains there even if that pid has nothing in next round
	$shared_lpid{$pid} = 0;
	
	$shared = $shared_cpid{$pid};
	$fn = "e/shmc-$x";
	if ($shared) {
#	    print "$i: cpid shared[x=$x pid=$pid] = $shared\n";
	    value_store_zeropad($fn, $i, $shared);
	    $avg_shared_cpid{$pid} = ($avg_shared_cpid{$pid} * $i + $shared)/($i+1);
	    my $dev = ($avg_shared_cpid{$pid} - $shared);
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_shared_cpid{$x} += $dev/$shared;
	    $devcount_shared_cpid{$x} += 1;
#		print "   cpid: inc devcount[$x] now = $devcount_shared_lpid{$x}\n";
	} else {
	    value_store_zeropad($fn, $i, 0);
	}
	$shared_cpid{$pid} = 0;

	if (exists $num_of_smaps_segments{$x}) {
	    my $fn = "e/numsegm-$x";
	    value_store($fn, $i, $num_of_smaps_segments{$x});
	    $max_smaps_segments{$x} = max $num_of_smaps_segments{$x}, $max_smaps_segments{$x};
	}
    }
    #
    # loops over shmem lpid names and insert values
    #
    foreach my $x (keys %shared_lpid_names_sz) {
	my $fn = "e/shmln-$x";
	value_store_zeropad($fn, $i, $shared_lpid_names_sz{$x});
    }
}

sub echo_one_img_line($)
{
    my $img = shift;

    my $img_fn   = $graphs_dir . "/" . $img . ".png";
    my $thumb_fn = $graphs_dir . "/" . $img . "_thumb.jpg";
    if (-e $img_fn) {
	system("pngtopnm $img_fn | pnmscalefixed -width=$thumb_width -height=$thumb_height | pnmtojpeg > $thumb_fn");
	if (WIFSIGNALED($?)) {
	    my $sig = WTERMSIG($?);
	    # Ignore thumnail generation problems (SIGSEGV etc), but stop
	    # processing if it looks like the users wants to abort the plot
	    # generation.
	    if ($sig == SIGINT or $sig == SIGTERM or $sig == SIGKILL) {
		kill($sig, $$);
	    }
	}
	system("echo '<table class=\"image\">' >> $html_name");
	system("echo '<caption align=\"bottom\">$thumbnames{$img}</caption>' >> $html_name");
	system("echo '<tr><td><a href=$img_fn><img src=$thumb_fn></a></td></tr>' >> $html_name");
	system("echo '</table>' >> $html_name");
    }
}

sub add_use_case_names()
{
    my $dcnt;
    if (!$steps_files) {
	return;
    }
    system("echo '<p style='float:left'>Steps:<br>' >> $html_name");
    foreach my $d (@dirs) {
	my $dfn = "$d/step.txt";
	if (-e $dfn) {
	    my $step = `cat $dfn`;
	    chop $step;
	    $dcnt = $d - 101;
	    system("echo '$dcnt: [$round_date{$d}] $step<br>' >> $html_name");
	}
    }
}

sub gen_html_page()
{
    system("echo '<head>' > $html_name");
    system("echo '<style>' >> $html_name");
    system("echo 'table { float: left; margin: 20px 5px 0px 0; }' >> $html_name");
    system("echo '</style>' >> $html_name");
    my $verstr = "Endurance graph $version [$hw_product][$sw_version] snapshot avg interval";
    if ($str_hours >= 1) {
	$verstr .= " $str_hours hours";
    } elsif ($str_minutes >= 1) {
	$verstr .= " $str_minutes minutes";
    } else {
	$verstr .= " $str_seconds seconds";
    }
    my $hours = int($total_duration / 3600);
    my $minutes = int(($total_duration % 3600) / 60);
    if ($hours > 0) {
	$verstr .= ", total duration ${hours}h ${minutes}min.";
    } else {
	$verstr .= ", total duration ${minutes}min.";
    }
    system("echo '<title>$verstr</title>' >> $html_name");
    system("echo '</head>' >> $html_name");
    system("echo '<body>' >> $html_name");
    system("echo '<p><b>$verstr</b>' >> $html_name");

# insert link to endurance_report.html (if exsists)

    my $fn = "endurance-report.html";
    if (-e $fn ) {
	system("echo ' <a href='$fn'>$fn</a>' >> $html_name");
    }
    system("echo '</p>' >> $html_name");

    foreach my $img (sort keys %images) {
	echo_one_img_line($img);
    }

# add thumbs of fragmenation.png (if exsists)

    for ($swfr = 1; $swfr <= 3; $swfr++) {
	my $img = $graph_fragmentation[$swfr - 1];
	my $fn = $graphs_dir . "/" . $img . ".png";
	if (-e $fn ) {
	    $thumbnames{$img} = "SWAP FRAGMENTATION " . $swfr;
	    echo_one_img_line($img);
	}
    }

# add names of use cases
    add_use_case_names();
}

sub start_plotfile_common($)
{
    my $key = shift;

    my $title = $legend{$key};
    my $ylabel = $unit{$key};
    my $plot;

    my $cmdfname = "e/" . $key . ".cmd";

    unless (open ($plot, "> $cmdfname")) {
	print STDERR "WARNING: unable to create $cmdfname: $!\n";
    }

    $title = $title . "\\nSW=" . $sw_version . "\\nPRODUCT=" . $hw_product . " BUILD=" . $hw_build;

    print $plot "set label \"$title\" at graph 0.02,0.98\n";
    print $plot "set xlabel \"rounds\"\n";
    print $plot "set ylabel \"$ylabel\"\n";
    print $plot "set grid xtics ytics\n";
    print $plot "set term png small truecolor size $plot_width, 1100\n";
#    print $plot "set term png truecolor size $plot_width, 1100\n";
    return $plot;
}

sub start_plotfile_lines_common($$)
{
    my $key = shift;
    my $style = shift;
    my $plot;

    $plot = start_plotfile_common($key);

    print $plot "set style data $style\n";
    print $plot "set key autotitle\n";
    my $add = $i/4;
    if ($add < 10) {
	$add = 10;
    }
    my $ii = $i + $add;
    print $plot "plot [0:$ii] ";
    return $plot;
}

sub start_plotfile_lines_common_2axes($$)
{
    my $key = shift;
    my $style = shift;
    my $plot;
    my $ylabel = $unit_1{$key};
    my $y2label = $unit_2{$key};

    $plot = start_plotfile_common($key);

    print $plot "set ylabel \"$ylabel\"\n";
    print $plot "set y2label \"$y2label\"\n";
    print $plot "set ytics nomirror\n";
    print $plot "set y2tics\n";
    print $plot "set style data $style\n";
    print $plot "set key autotitle\n";
    my $ii = $i+5;
    print $plot "set xrange [0 : $ii]\n";
    print $plot "set yrange [0 : ]\n";
    print $plot "set x2range [0 : $ii]\n";
    print $plot "set y2range [0 : ]\n";
    print $plot "plot ";
    return $plot;
}

sub start_plotfile_lines($)
{
    my $key = shift;
    return start_plotfile_lines_common($key, "lines")
}

sub start_plotfile_lines_2axes($)
{
    my $key = shift;
    return start_plotfile_lines_common_2axes($key, "lines")
}

sub start_plotfile_linespoints($)
{
    my $key = shift;
    return start_plotfile_lines_common($key, "linespoints")
}

sub start_plotfile_histogram($)
{
    my $key = shift;
    my $plot;

    $plot = start_plotfile_common($key);

    print $plot "set style data histograms\n";
    print $plot "set key invert autotitle\n";
    print $plot "set style histogram rowstacked\n";
    print $plot "set style fill solid 1.00 border -1\n";
    print $plot "set yrange [0 : ]\n";

    my $add = $i/3;
    if ($add < 25) {
	$add = 25;
    }
    my $ii = $i + $add;
    print $plot "plot [-1:$ii] ";

    return $plot;
}

sub start_plotfile_histogram_multi($)
{
    my $key = shift;
    my $plot;

    $plot = start_plotfile_common($key);

    print $plot "set style data histograms\n";
    print $plot "set key invert autotitle\n";
    print $plot "set style histogram rowstacked\n";
    print $plot "set style fill solid 1.00 border -1\n";
    print $plot "set multiplot\n";
    print $plot "unset label\n";

    return $plot;
}

sub close_plot($$$)
{
    my $count = shift;
    my $plot = shift;
    my $key = shift;

    print $plot "\n";
    close $plot;
    if ($count) {
	my $cmdfname = "e/" . $key . ".cmd";
	my $img_fn   = $graphs_dir . "/" . $key . ".png";
	system "gnuplot $cmdfname > $img_fn";
	if (WIFSIGNALED($?)) {
	    my $sig = WTERMSIG($?);
	    # Ignore gnuplot problems (SIGSEGV etc), but stop processing if it
	    # looks like the users wants to abort the plot generation.
	    if ($sig == SIGINT or $sig == SIGTERM or $sig == SIGKILL) {
		kill($sig, $$);
	    }
	}
	$images{$key} = $key;
	$thumbnames{$key} = $thumblegend{$key};
    } else {
#	print "\nNot enough changes/samples for $key, skipped\n";
#	print "(skip $key) ";
	print "(skip) ";
    }
}

sub print_cf_states_plot_cmds($)
{
    my $plot = shift;
    my $cnt_1 = 0;
    my $cnt_2 = 0;
    my $ii = $i+18;

    print $plot "set size 1.0,0.4\n";
    print $plot "set origin 0.0,0.0\n";
    print $plot "set title \"C states\"\n";
    print $plot "plot [-1:$ii] ";
    # need number of entries for 
    # using colors in reverse order so that highest level gets red
    # (which is lowest lt number)
    my $num_entries = 0;
    foreach my $p (reverse sort keys %seen_powertop_c_levels) {
	$num_entries += 1;
    }
    # and we sort them like this to get highest stuff to the top
    foreach my $p (reverse sort keys %seen_powertop_c_levels) {
	if ($cnt_1 > 0) {
	    print $plot ", ";
	}
	print $plot "'e/$p' using 2 lt $num_entries";
	value_emit("e/$p", 1);
	$cnt_1 += 1;
	$num_entries -= 1;
    }
    print $plot "\nset size 1.0,0.4\n";
    print $plot "set origin 0.0,0.5\n";
    print $plot "set title \"Freq states\"\n";
    print $plot "plot [-1:$ii] ";
    $num_entries = 0;
    foreach my $p (reverse sort keys %seen_powertop_f_levels) {
	$num_entries += 1;
    }
    foreach my $p (sort { $a <=> $b } keys %seen_powertop_f_levels) {
	if ($cnt_2 > 0) {
	    print $plot ", ";
	}
	print $plot "'e/$p' using 2 lt $num_entries";
	value_emit("e/$p", 1);
	$cnt_2 += 1;
	$num_entries -= 1;
    }
    return ($cnt_1 + $cnt_2);
}

sub print_domain_plot_cmds($$$$)
{
    my $plot = shift;
    my $domain = shift;
    my $height = shift;
    my $offs = shift;

    my $ii = $i+18;
    value_emit("e/p-domain-$domain-off", 1);
    value_emit("e/p-domain-$domain-ret", 1);
    value_emit("e/p-domain-$domain-ina", 1);
    value_emit("e/p-domain-$domain-on", 1);
    print $plot "set size 1.0,$height\n";
    print $plot "set origin 0.0,$offs\n";
    print $plot "set title \"$domain states\"\n";
#
# here we explicitly code bar color, lt=1:red=ON lt=2:green=OFF, others by enum
#
    print $plot "plot [-1:$ii] 'e/p-domain-$domain-off' using 2 lt 2, ";
    print $plot "'e/p-domain-$domain-ret' using 2 lt 3, ";
    print $plot "'e/p-domain-$domain-ina' using 2 lt 4, ";
    print $plot "'e/p-domain-$domain-on' using 2 lt 1\n";
}

sub generate_plots()
{
    my ($cnt, $cnt_1, $cnt_2);
    my $plot;
    my $fn;

############# MEM ######################
    print "graphs: mem ";
    $plot = start_plotfile_lines($graph_memory);

    if ($swapused_total) {
	value_emit($swapused_plot_file_name, 0);
	print $plot "'$swapused_plot_file_name' lt 1 lw 5,";
	value_emit($app_swapped_plot_file_name, 0);
	print $plot "'$app_swapped_plot_file_name' lt 1 lw 2,";
	value_emit($swapcached_plot_file_name, 0);
	print $plot "'$swapcached_plot_file_name' lw 3, ";
    }

    value_emit($memfree_plot_file_name, 0);
    print $plot "'$memfree_plot_file_name' lw 3, ";
    value_emit($cached_plot_file_name, 0);
    print $plot "'$cached_plot_file_name' lw 3, ";
    value_emit($active_file_plot_file_name, 0);
    print $plot "'$active_file_plot_file_name' lw 3,";
    value_emit($inactive_file_plot_file_name, 0);
    print $plot "'$inactive_file_plot_file_name' lw 3,";
    if ($show_shmem) {
	value_emit($shmem_plot_file_name, 0);
	print $plot "'$shmem_plot_file_name' lw 3, ";
    }
    value_emit($app_pss_plot_file_name, 0);
    print $plot "'$app_pss_plot_file_name' lw 3";

    close_plot($i, $plot, $graph_memory);

############# MEM SMALLER VALUES ######################
    $plot = start_plotfile_lines($graph_memory_s);

    value_emit($dirty_plot_file_name, 0);
    print $plot "'$dirty_plot_file_name' lw 3,";
    value_emit($buffers_plot_file_name, 0);
    print $plot "'$buffers_plot_file_name' lw 3, ";
    value_emit($mlocked_plot_file_name, 0);
    print $plot "'$mlocked_plot_file_name' lw 3,";
    value_emit($mpixmaps_plot_file_name, 0);
    if (-e $mpixmaps_plot_file_name) {
	print $plot "'$mpixmaps_plot_file_name' lw 3,";
    }
    value_emit($pagetables_plot_file_name, 0);
    print $plot "'$pagetables_plot_file_name' lw 3, ";
    if ($show_kernelstack) {
	value_emit($kernelstack_plot_file_name, 0);
	print $plot "'$kernelstack_plot_file_name' lw 3, ";
    }
    value_emit($slabreclaim_plot_file_name, 0);
    print $plot "'$slabreclaim_plot_file_name' lw 3,";
    value_emit($slabunreclaim_plot_file_name, 0);
    print $plot "'$slabunreclaim_plot_file_name' lw 3";

    close_plot($i, $plot, $graph_memory_s);

############# all slabs from slabinfo ######################
    print "slab ";
    $plot = start_plotfile_lines($graph_mem_slabs);
    $cnt = 0;
    foreach my $p (reverse sort {$all_slabs{$a} <=> $all_slabs{$b} } keys %all_slabs) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	if ($all_slabs{$p} == 0) {
	    next;
	}
	one_plot_set("e/slabs-$p", 3, $plot, \$cnt, 0);
    }
    close_plot($cnt, $plot, $graph_mem_slabs);

############# Processes, total ctxt switches  ######################
    print "ctx ";
    $plot = start_plotfile_linespoints($graph_events_ctx_total);

    $cnt = 0;
    foreach my $p (reverse sort {$cumul_total_ctx{$a} <=> $cumul_total_ctx{$b} } keys %cumul_total_ctx) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($cumul_total_ctx{$p} == 0) {
	    last;
	}
	one_plot_set("e/total-ctx-$p", 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_events_ctx_total);

############# Processes, non-voluntary ctxt switches  ######################
    $plot = start_plotfile_linespoints($graph_events_ctx_nonvolunt);

    $cnt = 0;
    foreach my $p (reverse sort {$cumul_nonvol_ctx{$a} <=> $cumul_nonvol_ctx{$b} } keys %cumul_nonvol_ctx) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($cumul_nonvol_ctx{$p} == 0) {
	    last;
	}
	one_plot_set("e/nonvol-ctx-$p", 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_events_ctx_nonvolunt);

############# Processes, voluntary ctxt switches  ######################
    $plot = start_plotfile_linespoints($graph_events_ctx_volunt);

    $cnt = 0;
    foreach my $p (reverse sort {$cumul_vol_ctx{$a} <=> $cumul_vol_ctx{$b} } keys %cumul_vol_ctx) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($cumul_vol_ctx{$p} == 0) {
	    last;
	}
	one_plot_set("e/vol-ctx-$p", 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_events_ctx_volunt);

############# loadavg #####################
    $plot = start_plotfile_lines($graph_loadavg);
    print $plot "'$load_1_file_name' lw 2, ";
    value_emit($load_1_file_name, 1);
    print $plot "'$load_5_file_name' lw 2, ";
    value_emit($load_5_file_name, 1);
    print $plot "'$load_15_file_name' lw 2";
    value_emit($load_15_file_name, 1);

    close_plot($i, $plot, $graph_loadavg);

############# global ctx switched #####################
    $plot = start_plotfile_lines_2axes($graph_ctx_global);
    $fn = "e/all-ctx-switches";
    print $plot "'$fn' lw 2 axes x1y1";
    value_emit($fn, 1);

    $fn = "e/num-processes";
    print $plot ", '$fn' lw 2 axes x2y2";
    value_emit($fn, 1);

    close_plot($i, $plot, $graph_ctx_global);

############# Processes/threads created #####################
    $plot = start_plotfile_lines($graph_processes_global);
    $fn = "e/global-processes";
    print $plot "'$fn' lw 2";
    value_emit($fn, 1);
    close_plot($i, $plot, $graph_processes_global);

############# Processes, major page faults ######################
    print "pfault ";
    $plot = start_plotfile_lines($graph_events_major_pagefaults);

    $cnt = 0;
    foreach my $p (reverse sort {$majflt_cumul{$a} <=> $majflt_cumul{$b} } keys %majflt_cumul) {
#	if ($cnt > $max_per_graph_onecolumn) {
	if ($cnt > 5) {
	    last;
	} 
	if ($majflt_cumul{$p} == 0) {
	    last;
	} 
	$fn = "e/majflt-$p";
	one_plot_set($fn, 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_events_major_pagefaults);


############# CPU utilization  ######################
    print "cputime ";
    $plot = start_plotfile_histogram($graph_cpu);
    $cnt = 0;
    my %cpu_colors = (
	    "cpu-user" => "#3149BD",
	    "cpu-nice" => "#4265FF",
	    "cpu-sys" => "#DE2821",
	    "cpu-irq" => "#FF0000",
	    "cpu-softirq" => "#EF0000",
	    "cpu-iowait" => "#EE00FF",
	    "cpu-idle" => "#ADE739");
    foreach (qw/cpu-sys cpu-irq cpu-softirq cpu-user cpu-nice cpu-iowait cpu-idle/) {
	one_plot_set("e/$_", 0, $plot, \$cnt, 1);
	print $plot " lc rgb '${cpu_colors{$_}}'";
    }
    close_plot($cnt, $plot, $graph_cpu);

############# CPU time in state  ######################
    foreach my $cpu_num (keys(%time_in_state_freqs_seen)) {
	my $graph_cpu_time_in_state = "59_cpu${cpu_num}_time_in_state";
	$legend{$graph_cpu_time_in_state} = "CPU${cpu_num} time in state";
	$thumblegend{$graph_cpu_time_in_state} = "CPU${cpu_num} TIME IN STATE";
	$unit{$graph_cpu_time_in_state} = 'percent';
	$cnt = 0;
	$plot = start_plotfile_histogram($graph_cpu_time_in_state);
	my @freqs = keys(%{$time_in_state_freqs_seen{$cpu_num}});
	foreach my $freq (sort {$a <=> $b} @freqs) {
	    one_plot_set("e/sysfs_cpu${cpu_num}_${freq}mhz",
		0, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_cpu_time_in_state);
    }

############# Processes, utime ######################
    $plot = start_plotfile_linespoints($graph_cpu_usertime);

    $cnt = 0;
    foreach my $p (reverse sort {$utime_cumul{$a} <=> $utime_cumul{$b} } keys %utime_cumul) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($utime_cumul{$p} == 0) {
	    last;
	}
	one_plot_set("e/utime-$p", 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_cpu_usertime);

############# Processes, stime ######################
    $plot = start_plotfile_linespoints($graph_cpu_systime);

    $cnt = 0;
    foreach my $p (reverse sort {$stime_cumul{$a} <=> $stime_cumul{$b} } keys %stime_cumul) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($stime_cumul{$p} == 0) {
	    last;
	}
	one_plot_set("e/stime-$p", 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_cpu_systime);

############# Processes, totaltime=stime+utime ######################
    $plot = start_plotfile_linespoints($graph_cpu_totaltime);

    $cnt = 0;
    foreach my $p (reverse sort {$totaltime_cumul{$a} <=> $totaltime_cumul{$b} } keys %totaltime_cumul) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($totaltime_cumul{$p} == 0) {
	    last;
	}
	one_plot_set("e/$p-totaltime", 3, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_cpu_totaltime);

############### Histogram of shared mem #################
    print "shmem ";
    $plot = start_plotfile_histogram($graph_mem_shared);

    value_emit($shared_locked_plot_file_name, 1);
    print $plot "'$shared_locked_plot_file_name' using 2,";
    value_emit($shared_unlocked_plot_file_name, 1);
    print $plot "'$shared_unlocked_plot_file_name' using 2";

    close_plot($i, $plot, $graph_mem_shared);

############### Histogram of shared mem lpid #################
    $plot = start_plotfile_histogram($graph_mem_shared_lpid);
#    $plot = start_plotfile_lines($graph_mem_shared_lpid);

    foreach my $p (keys %shared_lpid_cnt) {
	if ($devcount_shared_lpid{$p}) {
	    $sumdev_shared_lpid{$p} /= $devcount_shared_lpid{$p};
	    $sumdev_shared_lpid{$p} += (100*($i - $devcount_shared_lpid{$p}));
	}
    }

    $cnt = 0;
    foreach my $p (sort {$sumdev_shared_lpid{$a} <=> $sumdev_shared_lpid{$b} } keys %shared_lpid_cnt) {

#    print "plot_lpid: name=$p, sumdev=$sumdev_shared_lpid{$p} devcount=$devcount_shared_lpid{$p} cnt=$shared_lpid_cnt{$p}\n";
	if ($devcount_shared_lpid{$p}) {
	    one_plot_set("e/shml-$p", 0, $plot, \$cnt, 1);
#	    one_plot_set("e/shml-$p", 1, $plot, \$cnt, 1);
	}
    }
    close_plot($cnt, $plot, $graph_mem_shared_lpid);

############### Histogram of shared mem lpid, combined by name #################
    $plot = start_plotfile_lines($graph_mem_shared_lpid_name);
#    $plot = start_plotfile_histogram($graph_mem_shared_lpid_name);

    $cnt = 0;
    foreach my $p (reverse sort {$shared_lpid_names_all_sz{$a} <=> $shared_lpid_names_all_sz{$b} } keys %shared_lpid_names_all_sz) {
	$fn = "e/shmln-$p";
	one_plot_set($fn, 3, $plot, \$cnt, 1);
#	one_plot_set($fn, 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_mem_shared_lpid_name);

############### Histogram of shared mem cpid #################
    $plot = start_plotfile_histogram($graph_mem_shared_cpid);

    foreach my $p (keys %shared_cpid_cnt) {
	if ($devcount_shared_cpid{$p}) {
	    $sumdev_shared_cpid{$p} /= $devcount_shared_cpid{$p};
	    $sumdev_shared_cpid{$p} += (100*($i - $devcount_shared_cpid{$p}));
	}
    }
    $cnt = 0;
    foreach my $p (sort keys %shared_cpid_cnt) {

	if ($devcount_shared_cpid{$p}) {
#	print "plot_cpid: name-pid=$p, sumdev=$sumdev_shared_cpid{$p} devcount=$devcount_shared_cpid{$p} cnt=$shared_cpid_cnt{$p}\n";
	    one_plot_set("e/shmc-$p", 0, $plot, \$cnt, 1);
	}
    }
    close_plot($cnt, $plot, $graph_mem_shared_cpid);

############### Lines of shared mem segments count, by num of attached proc #################
#    $plot = start_plotfile_lines($graph_mem_shared_number);

#    $cnt = 0;
#    for ($z = 0; $z <= $max_nattach ; $z++) {
#	$fn = "e/nattach-$z-shm";
#	one_plot_set($fn, 2, $plot, \$cnt, 0);
#    }
##    $fn = "e/nattach-a-age-shm";
##    one_plot_set($fn, 3, $plot, \$cnt, 0);
##    $fn = "e/nattach-d-age-shm";
##    one_plot_set($fn, 3, $plot, \$cnt, 0);
#    close_plot($cnt, $plot, $graph_mem_shared_number);
############### Lines of shared mem segments count, by num of attached proc #################
    $plot = start_plotfile_lines_2axes($graph_mem_shared_number);

    $cnt = 0;
    for ($z = 0; $z <= $max_nattach ; $z++) {
#	print "$z: used=$shared_used{$z}\n";
	if (!$shared_used{$z}) {
	    next;
	}
	if ($cnt > 0) {
	    print $plot ", ";
	}
	$fn = "e/nattach-$z-shm";
	print $plot "'$fn' lw 2 axes x1y1";
	$cnt += 1;
	value_emit($fn, 0);
    }
    $fn = "e/count-shm";
    if ($cnt > 0) {
	print $plot ", ";
    }
    print $plot "'$fn' lw 4 axes x2y2";
    $cnt += 1;
    value_emit($fn, 0);
    close_plot($cnt, $plot, $graph_mem_shared_number);

############### Histogram of shared mem size, by num of attached proc #################
    $plot = start_plotfile_histogram($graph_mem_shared_size);

    $cnt = 0;
    for ($z = $max_nattach; $z > 0; $z--) {
	$fn = "e/nattach-$z-shm-sz";
	one_plot_set($fn, 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_mem_shared_size);

############### Histogram of process mlocked #################
    print "mlocked ";
    $plot = start_plotfile_histogram($graph_appmem_locked);

    $cnt = 0;
    foreach my $p (reverse sort {$app_sum_locked{$a} <=> $app_sum_locked{$b} } keys %app_sum_locked) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
	if (!$app_sum_locked{$p}) {
	    last;
	}
	one_plot_set("e/locked-$p", 0, $plot, \$cnt, 1);
	$cnt += 1;
    }
    close_plot($cnt, $plot, $graph_appmem_locked);

############### Lines of changed vmsize #################
    $plot = start_plotfile_linespoints($graph_vmsize);

    $cnt = 0;
    foreach my $p (reverse sort {$app_sum_vmsz{$a} <=> $app_sum_vmsz{$b} } keys %app_sum_vmsz) {
	if ($changed_vmsize{$p}) {
	    $fn = "e/vmsz-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 0);
	}
    }
    close_plot($cnt, $plot, $graph_vmsize);

############### Lines of changed smaps segment count #################
    use constant MAX_SMAPS_PLOTS => 3;
    use constant MAX_SMAPS_PER_PLOT => 15;
    use constant MAX_SMAPS_SPLIT_FACTOR => 5;
    my %max_smaps_segments_to_plot = %max_smaps_segments;
    foreach my $plot_idx (1 .. MAX_SMAPS_PLOTS) {
	my $graph_num_of_smaps_segments = "34_num_smaps_segments_${plot_idx}";
	$legend{$graph_num_of_smaps_segments} = "number of smaps segments";
	$unit{$graph_num_of_smaps_segments} = "count";
	$plot = start_plotfile_linespoints($graph_num_of_smaps_segments);
	my $prev_max;
	my $cnt_this_round = 0;
	my @plotted_this_round;
	foreach my $p (reverse sort { $max_smaps_segments{$a} <=> $max_smaps_segments{$b} } keys %max_smaps_segments_to_plot) {
	    $fn = "e/numsegm-$p";
	    next if not changes_found($fn);
	    if (not $prev_max) {
		$prev_max = $max_smaps_segments{$p};
	    }
	    if ($plot_idx < MAX_SMAPS_PLOTS and $prev_max >= (MAX_SMAPS_SPLIT_FACTOR * $max_smaps_segments{$p})) {
		last;
	    }
	    one_plot_set($fn, 3, $plot, \$cnt_this_round, 0);
	    push(@plotted_this_round, $p);
	    if ($plot_idx < MAX_SMAPS_PLOTS and $cnt_this_round > MAX_SMAPS_PER_PLOT) {
		last;
	    }
	}
	foreach my $p (@plotted_this_round) {
	    delete $max_smaps_segments_to_plot{$p};
	}
	$thumblegend{$graph_num_of_smaps_segments} = "#SMAPS SEGMENTS &mdash; MAX $prev_max";
	close_plot($cnt_this_round, $plot, $graph_num_of_smaps_segments);
    }

############### Histogram of process heaps #################
    print "heap ";
    $plot = start_plotfile_histogram($graph_appmem_heap);

    $cnt = 0;
    %show_this = undef;
#
# on histogram, we show all to get the total size feeling
#
    foreach my $p (reverse sort {$sum_heap{$a} <=> $sum_heap{$b} } keys %sum_heap) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %sum_heap) {
	if ($show_this{$p}) {
	    $sumdev_heap{$p} /= $devcount_heap{$p};
	    $sumdev_heap{$p} += (10000*($i - $devcount_heap{$p}));
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_heap{$a} <=> $sumdev_heap{$b} } keys %sum_heap) {
	if ($show_this{$p} != 1) {
	    next;
	} 
	one_plot_set("e/heap-$p", 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_appmem_heap);

############### Lines of process heaps #################
    use constant MAX_HEAP_PLOTS => 5;
    use constant MAX_HEAP_PER_PLOT => 10;
    use constant MAX_HEAP_SPLIT_CONSTANT => 5;
    %show_this = undef;
    $cnt = 0;
#
# on lines graphs, we show changing ones to detect leaks
#
    foreach my $p (reverse sort {$sum_heap{$a} <=> $sum_heap{$b} } keys %sum_heap) {
	if (!$sumdev_heap{$p}) {
	    next;
	}
	if (!changes_found_ignore_zeroes("e/heap-$p")) {
	    next;
	}
	# if one sample and under 1 MB, do not show
	if (($num_heap_samples{$p} < 2) && ($avg_heap{$p} < 1024)) {
	    next;
	}
	$show_this{$p} = 1;
	$cnt += 1;
    }
    my %max_heap_to_plot = %max_heap;
    foreach my $plot_idx (1 .. MAX_HEAP_PLOTS) {
	my $graph_appmem_heap_lines = "36_appmem_heap_lines_${plot_idx}";
	$legend{$graph_appmem_heap_lines} = "process heap mapping virtual size";
	$unit{$graph_appmem_heap_lines} = "MB";
	$plot = start_plotfile_linespoints($graph_appmem_heap_lines);
	my $prev_max;
	my $cnt_this_round = 0;
	my @plotted_this_round;
	foreach my $p (reverse sort { $max_heap{$a} <=> $max_heap{$b} } keys %max_heap_to_plot) {
	    next if ($show_this{$p} != 1);
	    if (not $prev_max) {
		$prev_max = $max_heap{$p};
	    }
	    if ($plot_idx < MAX_HEAP_PLOTS and $prev_max >= (MAX_HEAP_SPLIT_CONSTANT * $max_heap{$p})) {
		last;
	    }
	    $fn = "e/heap-$p";
	    one_plot_set($fn, 3, $plot, \$cnt_this_round, 0);
	    delete_zero_lines($fn);
	    push(@plotted_this_round, $p);
	    if ($plot_idx < MAX_HEAP_PLOTS and $cnt_this_round > MAX_HEAP_PER_PLOT) {
		last;
	    }
	}
	foreach (@plotted_this_round) {
	    delete $max_heap_to_plot{$_};
	}
	$thumblegend{$graph_appmem_heap_lines} = "APPS HEAP &mdash; MAX " . ceil($prev_max / 1024) . "MB";
	close_plot($cnt_this_round, $plot, $graph_appmem_heap_lines);
    }

############### Histogram of process sysv shared mem #################
    print "sharedmem ";
    $plot = start_plotfile_histogram($graph_appmem_sysvshared);

    $cnt = 0;
    %show_this = undef;
    foreach my $p (reverse sort {$app_cumul_sysv_shared{$a} <=> $app_cumul_sysv_shared{$b} } keys %app_cumul_sysv_shared) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
#	print "sysvshared: $p: sumdev=$sumdev_sysv_shared{$p}\n";
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_sysv_shared) {
	if ($show_this{$p}) {
	    $sumdev_sysv_shared{$p} /= $devcount_sysv_shared{$p};
	    $sumdev_sysv_shared{$p} += (10000*($i - $devcount_sysv_shared{$p}));
#	    print "sysvshared-adj: $p: sumdev=$sumdev_sysv_shared{$p} count=$devcount_sysv_shared{$p}\n";
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_sysv_shared{$a} <=> $sumdev_sysv_shared{$b} } keys %app_cumul_sysv_shared) {
	if ($show_this{$p} != 1) {
	    next;
	} 
	one_plot_set("e/sysvshm-$p", 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_appmem_sysvshared);

############### Histogram of process posix shared mem #################
    $plot = start_plotfile_histogram($graph_appmem_posixshared);

    $cnt = 0;
    %show_this = undef;
    foreach my $p (reverse sort {$app_cumul_posix_shared{$a} <=> $app_cumul_posix_shared{$b} } keys %app_cumul_posix_shared) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
#	print "posixshared: $p: sumdev=$sumdev_posix_shared{$p}\n";
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_posix_shared) {
	if ($show_this{$p}) {
	    $sumdev_posix_shared{$p} /= $devcount_posix_shared{$p};
	    $sumdev_posix_shared{$p} += (10000*($i - $devcount_posix_shared{$p}));
#	    print "posixshared-adj: $p: sumdev=$sumdev_posix_shared{$p} count=$devcount_posix_shared{$p}\n";
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_posix_shared{$a} <=> $sumdev_posix_shared{$b} } keys %app_cumul_posix_shared) {
	if ($show_this{$p} != 1) {
	    next;
	} 
	one_plot_set("e/posixshm-$p", 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_appmem_posixshared);

############### Histogram of process /dev/pvr #################
    print "devpvr ";
    $plot = start_plotfile_histogram($graph_appmem_devpvr);

    $cnt = 0;
    %show_this = undef;
    foreach my $p (reverse sort {$app_cumul_dev_pvr{$a} <=> $app_cumul_dev_pvr{$b} } keys %app_cumul_dev_pvr) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
#	print "sysvshared: $p: sumdev=$sumdev_sysv_shared{$p}\n";
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_dev_pvr) {
	if ($show_this{$p}) {
	    $sumdev_dev_pvr{$p} /= $devcount_dev_pvr{$p};
	    $sumdev_dev_pvr{$p} += (10000*($i - $devcount_dev_pvr{$p}));
#	    print "dev_pvr-adj: $p: sumdev=$sumdev_dev_pvr{$p} count=$devcount_dev_pvr{$p}\n";
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_dev_pvr{$a} <=> $sumdev_dev_pvr{$b} } keys %app_cumul_dev_pvr) {
	if ($show_this{$p} != 1) {
	    next;
	} 
	one_plot_set("e/devpvr-$p", 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_appmem_devpvr);

############### Histogram of process write-exec shared mem #################
    print "write-exec ";
    $plot = start_plotfile_histogram($graph_appmem_wx);
    $cnt = 0;
    foreach my $p (reverse sort {$app_cumul_rwxp{$a} <=> $app_cumul_rwxp{$b} } keys %app_cumul_rwxp) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
	one_plot_set("e/$p-wx", 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_appmem_wx);

############# SWAP EVENT COUNTS ######################
    if (($swapused_total + $swap_pgout_total) > 0) {
	print "swap ";
	$n = 0;
	$plot = start_plotfile_lines($graph_events_swap);
	if (value_emit($pswp_in_plot_file_name, 1)) {
	    print $plot "'$pswp_in_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($pswp_out_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$pswp_out_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($pgscan_kswapd_normal_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$pgscan_kswapd_normal_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($pgscan_direct_normal_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$pgscan_direct_normal_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($slabs_scanned_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$slabs_scanned_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($kswapd_steal_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$kswapd_steal_plot_file_name' lw 3";
	    $n += 1;
	}
	close_plot($n, $plot, $graph_events_swap);
	
############### Histogram of processes swapped #################
	$plot = start_plotfile_histogram($graph_appmem_swapped);

	$cnt = 0;
	%show_this = undef;

	foreach my $p (reverse sort {$app_cumul_swp{$a} <=> $app_cumul_swp{$b} } keys %app_cumul_swp) {
	    if ($cnt > ($max_per_graph_onecolumn - 1)) {
		last;
	    } 
	    $show_this{$p} = 1;
	    $cnt += 1;
#    print "1:cnt=$cnt p=$p\n";
	}
	foreach my $p (sort keys %app_cumul_swp) {
	    if ($show_this{$p}) {
		$sumdev_swp{$p} /= $devcount_swp{$p};
		$sumdev_swp{$p} += (100*($i - $devcount_swp{$p}));
	    }
	}
	$cnt = 0;
	foreach my $p (sort {$sumdev_swp{$a} <=> $sumdev_swp{$b} } keys %app_cumul_swp) {
	    if ($show_this{$p} != 1) {
		next;
	    } 
	    one_plot_set("e/swp-$p", 0, $plot, \$cnt, 1);
#    print "2:cnt=$cnt p=$p show_this=$show_this{$p}\n";
	}
##
## special: add unaccounted swapped (shared??) mem. (diff:total_swap - apps_swap)
##
#	value_emit($unaccount_swapped_plot_file_name, 1);
#	print $plot ", 'e/unaccount_swapped' using 2";
	close_plot($cnt, $plot, $graph_appmem_swapped);

############### Histogram of processes PSS+SWAP #################
	$plot = start_plotfile_histogram($graph_appmem_pss_swap);

	$cnt = 0;
	%show_this = undef;
	foreach my $p (reverse sort {$app_cumul_pss_swp{$a} <=> $app_cumul_pss_swp{$b} } keys %app_cumul_pss_swp) {
	    if ($cnt > $max_per_graph_onecolumn) {
		last;
	    } 
	    $show_this{$p} = 1;
	    $cnt += 1;
	}
	foreach my $p (sort keys %app_cumul_pss_swp) {
	    if ($show_this{$p}) {
		$sumdev_pss_swp_adj{$p} = $sumdev_pss_swp{$p} / $devcount_pss_swp{$p};
		$sumdev_pss_swp_adj{$p} += (100*($i - $devcount_pss_swp{$p}));
	    }
	}
	$cnt = 0;
	foreach my $p (sort {$sumdev_pss_swp_adj{$a} <=> $sumdev_pss_swp_adj{$b} } keys %app_cumul_pss_swp) {
	    if ($show_this{$p} != 1) {
		next;
	    } 
	    one_plot_set("e/pswp-$p", 0, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_appmem_pss_swap);

    }
############### Histogram of processes private dirty #################
#    print "privdirty ";
#    $plot = start_plotfile_histogram($graph_appmem_private_dirty);
#
#    $cnt = 0;
#    %show_this = undef;
#
#    foreach my $p (reverse sort {$app_cumul_private_dirty{$a} <=> $app_cumul_private_dirty{$b} } keys %app_cumul_private_dirty) {
#	if ($cnt > ($max_per_graph_onecolumn - 1)) {
#	    last;
#	} 
#	$show_this{$p} = 1;
#	$cnt += 1;
##    print "1:cnt=$cnt p=$p\n";
#    }
#    foreach my $p (sort keys %app_cumul_private_dirty) {
#	if ($show_this{$p}) {
#	    $sumdev_private_dirty{$p} /= $devcount_private_dirty{$p};
#	    $sumdev_private_dirty{$p} += (100*($i - $devcount_private_dirty{$p}));
#	}
#    }
#    $cnt = 0;
#    foreach my $p (sort {$sumdev_private_dirty{$a} <=> $sumdev_private_dirty{$b} } keys %app_cumul_private_dirty) {
#	if ($show_this{$p} != 1) {
#	    next;
#	} 
#	if ($cnt > 0) {
#	    print $plot ", ";
#	}
#	print $plot "'e/$p-pdirty' using 2";
#	$cnt += 1;
#    }
#    close_plot($cnt, $plot, $graph_appmem_private_dirty);

############### Histogram of processes PSS #################
    print "pss ";
    $plot = start_plotfile_histogram($graph_appmem_pss);

    $cnt = 0;
    %show_this = undef;
    foreach my $p (reverse sort {$app_cumul_pss{$a} <=> $app_cumul_pss{$b} } keys %app_cumul_pss) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_pss) {
	if ($show_this{$p}) {
	    $sumdev_pss{$p} /= $devcount_pss{$p};
	    $sumdev_pss{$p} += (100*($i - $devcount_pss{$p}));
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_pss{$a} <=> $sumdev_pss{$b} } keys %app_cumul_pss) {
	if ($show_this{$p} != 1) {
	    next;
	} 
#    print "pss:$p: sumdev=$sumdev_pss{$p} devcount=$devcount_pss{$p}\n";
	one_plot_set("e/p-$p", 0, $plot, \$cnt, 1);
    }
    close_plot($cnt, $plot, $graph_appmem_pss);

############### Lines of processes PSS+SWAP, 4 graphs #################
# find out how many %app_cumul_pss_swp are there and what are dynamic split points
# to show them on 4 graphs
    $num_of_pss_swp = 0;
    %show_this = undef;
    foreach my $p (keys %app_cumul_pss_swp) {
#	if (($pss_swap_num_samples{$p} < $samples_required) || ($sumdev_pss_swp{$p} < 1)) {
	if (($pss_swap_num_samples{$p} < 1) || ($sumdev_pss_swp{$p} < 1)) {
	    next;
	} 
	$show_this{$p} = 1;
	$num_of_pss_swp += 1;
    }
    use integer;
    $elems_per_graph = $num_of_pss_swp / 4;
#print "num_of_pss_swp_elems = $num_of_pss_swp elems_per_graph=$elems_per_graph\n";
    if ($elems_per_graph == 0) {
	$elems_per_graph = 1;
    }
    if ($elems_per_graph > $max_per_graph_onecolumn) {
	$elems_per_graph = $max_per_graph_onecolumn;
    }
    $divpoint_1 = 1*$elems_per_graph;
    $divpoint_2 = 2*$elems_per_graph;
    $divpoint_3 = 3*$elems_per_graph;
    no integer;
#print "div_1=$divpoint_1 div_2=$divpoint_2 div_3=$divpoint_3\n";
    $cnt = 0;
    if (($swapused_total + $swap_pgout_total) > 0) {
	$pss_txt = "PSS+SWP";
    } else {
	$pss_txt = "PSS";
    }
	
    foreach my $p (reverse sort {$avg_pss_swp{$a} <=> $avg_pss_swp{$b} } keys %avg_pss_swp) {
	if ($show_this{$p}) {
	    $cnt += 1;
	    if ($cnt == $divpoint_1) {
		$div = $avg_pss_swp{$p};
		$sdiv = sprintf("%2.1f", $div);
#	print "div(1)=$div, sdiv(1)=$sdiv\n";
		$legend{$graph_appmem_pss_swap_lines_big} = "apps $pss_txt > $sdiv MB"; 
		$thumblegend{$graph_appmem_pss_swap_lines_big} = "$pss_txt &gt; $sdiv MB";

		$legend{$graph_appmem_pss_swap_lines_small} = "apps $pss_txt < $sdiv MB"; 
		$thumblegend{$graph_appmem_pss_swap_lines_small} = "$pss_txt &lt; $sdiv MB";
	    } elsif ($cnt == $divpoint_2) {
		$div = $avg_pss_swp{$p};
		$sdiv = sprintf("%2.1f", $div);
#	print "div(2)=$div, sdiv(2)=$sdiv\n";
		$legend{$graph_appmem_pss_swap_lines_smaller} = "apps $pss_txt < $sdiv MB"; 
		$thumblegend{$graph_appmem_pss_swap_lines_smaller} = "$pss_txt &lt; $sdiv MB";
	    } elsif ($cnt == $divpoint_3) {
		$div = $avg_pss_swp{$p};
		$sdiv = sprintf("%2.1f", $div);
#	print "div(3)=$div, sdiv(3)=$sdiv\n";
		$legend{$graph_appmem_pss_swap_lines_smallest} = "apps $pss_txt < $sdiv MB"; 
		$thumblegend{$graph_appmem_pss_swap_lines_smallest} = "$pss_txt &lt; $sdiv MB";
	    }
	} 
    }

############### Lines of processes PSS+SWAP >= $lines_pss_swap_divider_1 MB #################
#
# XXX ??? here between _11.1 and _12, mem use jumps high!!
#
    $cnt = 0;
    $plot_1 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_big);
    $plot_2 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_small);
    $plot_3 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_smaller);
    $plot_4 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_smallest);
    $cnt_per_file = undef;
    foreach my $p (reverse sort {$avg_pss_swp{$a} <=> $avg_pss_swp{$b} } keys %avg_pss_swp) {
	if ($show_this{$p}) {
	    if ($cnt < (1*$elems_per_graph)) {
		$handle = $plot_1;
	    } elsif ($cnt < (2*$elems_per_graph)) {
		$handle = $plot_2;
	    } elsif ($cnt < (3*$elems_per_graph)) {
		$handle = $plot_3;
#	    } elsif ($cnt < (4*$elems_per_graph)) {
	    } elsif (true) {
		$handle = $plot_4;
	    } else {
		print "graph_appmem_lines: no handle...p=[$p] cnt=$cnt\n";
		next;
	    }
	    if ($cnt_per_file{$handle} > 0) {
		print $handle ", ";
	    }
#    print "cnt=[$cnt]; p=[$p] cumul=$app_cumul_pss_swp{$p} avg=$avg_pss_swp{$p} samples=$pss_swap_num_samples{$p}\n";
	    $fn = "e/pswp-$p";
#
# re-use existing file from histogram pass (above),
# but data sets may differ so if no file, emit the data set
#
	    if (! -e $fn) {
		value_emit($fn, 0);
	    }
	    delete_zero_lines($fn);
	    print $handle "'e/pswp-$p' lw 3";
	    $cnt += 1;
	    $cnt_per_file{$handle} += 1;
	}
    }
    close_plot($cnt_per_file{$plot_1}, $plot_1, $graph_appmem_pss_swap_lines_big);
    close_plot($cnt_per_file{$plot_2}, $plot_2, $graph_appmem_pss_swap_lines_small);
    close_plot($cnt_per_file{$plot_3}, $plot_3, $graph_appmem_pss_swap_lines_smaller);
    close_plot($cnt_per_file{$plot_4}, $plot_4, $graph_appmem_pss_swap_lines_smallest);

############### num of threads #################
    print "threads ";
    $plot = start_plotfile_histogram($graph_threads_count);

    $cnt = 0;
    foreach my $p ( reverse sort {$has_threads{$a} <=> $has_threads{$b} } keys %has_threads) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	if ($has_threads{$p} && ($has_threads_samples{$p} > 1)) {
#	print "thr: [$p] num=$has_threads{$p}\n";
	    $fn = "e/thr-$p";
	    one_plot_set($fn, 0, $plot, \$cnt, 1);
	}
    }
    close_plot($cnt, $plot, $graph_threads_count);

############# X resource counts ######################
    print "xres ";
    $plot = start_plotfile_linespoints($graph_xresource_cnt);

    $cnt = 0;
    foreach my $p ( reverse sort {$xresource_latest_cnt{$a} <=> $xresource_latest_cnt{$b} } keys %xresource_latest_cnt) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	if ($xres_samples{$p} < $samples_required) {
	    next;
	}
	$fn = "e/xres-cnt-$p";
	one_plot_set($fn, 3, $plot, \$cnt, 0);
    }
    close_plot($cnt, $plot, $graph_xresource_cnt);

############# X resource sizes, pixmaps ######################
    $plot = start_plotfile_linespoints($graph_xresource_sz_pxm);

    $cnt = 0;
    foreach my $p ( reverse sort {$xresource_latest_sz_pxm{$a} <=> $xresource_latest_sz_pxm{$b} } keys %xresource_latest_sz_pxm) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
#	if ($xres_samples{$p} < $samples_required) {
#	    next;
#	}
	if (!$xres_pxm_size_total{$p}) {
	    next;
	}
	$fn = "e/xres-pxm-$p";
	one_plot_set($fn, 3, $plot, \$cnt, 0);
    }
    close_plot($cnt, $plot, $graph_xresource_sz_pxm);

############# X resource atom counts ######################

    foreach my $resource_atom (keys %xres_atoms_seen) {
	my $omit = 1;
	foreach my $Identifier (keys %xres_samples) {
	    if ($xres_samples{$Identifier} < 2) { next; }
	    $fn = "e/xres-cnt-$Identifier-${resource_atom}";
	    if (count_nonzero_entries($fn) <= 0) { next; }
	    if (!changes_found($fn)) { next; }
	    $omit = 0;
	    last;
	}
	if ($omit) { next; }
	my $graph_xresource_atom_cnt = "50_xresource_${resource_atom}";
	$legend{$graph_xresource_atom_cnt} = "X resource count: ${resource_atom}";
	$thumblegend{$graph_xresource_atom_cnt} = "X-RESOURCES-${resource_atom}";
	$unit{$graph_xresource_atom_cnt} = "X resource atom count";
	$cnt = 0;
	$plot = start_plotfile_linespoints($graph_xresource_atom_cnt);
	foreach my $Identifier (keys %xres_samples) {
	    if ($xres_samples{$Identifier} < 2) { next; }
	    $fn = "e/xres-cnt-$Identifier-${resource_atom}";
	    if (count_nonzero_entries($fn) <= 0) { next; }
	    if (!changes_found($fn)) { next; }
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_xresource_atom_cnt);
    }

############# X resource sizes, misc ######################
#$plot = start_plotfile_linespoints($graph_xresource_sz_misc);
#
#$cnt = 0;
#foreach my $p ( reverse sort {$xresource_latest_sz_misc{$a} <=> $xresource_latest_sz_misc{$b} } keys %xresource_latest_sz_misc) {
#    if ($cnt > 0) {
#	print $plot ", ";
#    }
#    print $plot "'e/$p-xres-mem-misc' lw 3";
#    $cnt += 1;
#}
#close_plot($cnt, $plot, $graph_xresource_sz_misc);

############# df ######################
    print "df ";
    $plot = start_plotfile_lines($graph_diskspace);

    $cnt = 0;
    foreach my $p ( reverse sort {$filesystem_names{$a} <=> $filesystem_names{$b} } keys %filesystem_names) {
	one_plot_set("e/fs-used-$p", 3, $plot, \$cnt, 1);
    }
    one_plot_set($fd_perc_file_name, 5, $plot, \$cnt, 0);
    close_plot($cnt, $plot, $graph_diskspace);

############# fd_count for processes #####################
    print "fd ";
    $plot = start_plotfile_lines($graph_fdcount);
    $cnt = 0;
    foreach my $p (reverse sort {$fd_count{$a} <=> $fd_count{$b} } keys %fd_count) {
	if ($fd_count_samples{$p} < $samples_required) {
	    next;
	}
	if ($fd_count_diff{$p} < 1) {
	    next;
	}
	$fn = "e/fd-$p";
	one_plot_set($fn, 3, $plot, \$cnt, 0);
    }
    close_plot($cnt, $plot, $graph_fdcount);

############# fd_count_inotify for processes #####################
    print "fd_inotify ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_inotify{$a} <=> $fd_inotify{$b} } keys %fd_inotify) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_inotify-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$cnt = 0;
	$plot = start_plotfile_linespoints($graph_fdcount_inotify);
	foreach my $p (reverse sort {$fd_inotify{$a} <=> $fd_inotify{$b} } keys %fd_inotify) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_inotify-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_inotify);
    }

############# fd_count_pipe for processes #####################
    print "fd_pipe ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_pipe{$a} <=> $fd_pipe{$b} } keys %fd_pipe) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_pipe-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$cnt = 0;
	$plot = start_plotfile_linespoints($graph_fdcount_pipe);
	foreach my $p (reverse sort {$fd_pipe{$a} <=> $fd_pipe{$b} } keys %fd_pipe) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_pipe-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_pipe);
    }

############# fd_count_socket for processes #####################
    print "fd_socket ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_socket{$a} <=> $fd_socket{$b} } keys %fd_socket) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_socket-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_socket);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_socket{$a} <=> $fd_socket{$b} } keys %fd_socket) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_socket-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_socket);
    }

############# fd_count_tmpfs for processes #####################
    print "fd_tmpfs ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_tmpfs{$a} <=> $fd_tmpfs{$b} } keys %fd_tmpfs) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_tmpfs-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_tmpfs);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_tmpfs{$a} <=> $fd_tmpfs{$b} } keys %fd_tmpfs) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_tmpfs-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_tmpfs);
    }

############# fd_count_eventfd for processes #####################
    print "fd_eventfd ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_eventfd{$a} <=> $fd_eventfd{$b} } keys %fd_eventfd) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_eventfd-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_eventfd);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_eventfd{$a} <=> $fd_eventfd{$b} } keys %fd_eventfd) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_eventfd-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_eventfd);
    }

############# fd_count_epoll for processes #####################
    print "fd_epoll ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_epoll{$a} <=> $fd_epoll{$b} } keys %fd_epoll) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_epoll-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_epoll);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_epoll{$a} <=> $fd_epoll{$b} } keys %fd_epoll) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_epoll-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_epoll);
    }

############# fd_count_signalfd for processes #####################
    print "fd_signalfd ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_signalfd{$a} <=> $fd_signalfd{$b} } keys %fd_signalfd) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_signalfd-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_signalfd);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_signalfd{$a} <=> $fd_signalfd{$b} } keys %fd_signalfd) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_signalfd-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_signalfd);
    }

############# fd_count_timerfd for processes #####################
    print "fd_timerfd ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_timerfd{$a} <=> $fd_timerfd{$b} } keys %fd_timerfd) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_timerfd-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_timerfd);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_timerfd{$a} <=> $fd_timerfd{$b} } keys %fd_timerfd) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_timerfd-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_timerfd);
    }

############# fd_count_disk for processes #####################
    print "fd_disk ";
    %show_this = undef;
    foreach my $p (reverse sort {$fd_disk{$a} <=> $fd_disk{$b} } keys %fd_disk) {
	if ($fd_samples{$p} < $samples_required) { next; }
	$fn = "e/fd_disk-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_disk);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_disk{$a} <=> $fd_disk{$b} } keys %fd_disk) {
	    if ($show_this{$p} != 1) { next; }
	    $fn = "e/fd_disk-$name_by_pid{$p}-$p";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($cnt, $plot, $graph_fdcount_disk);
    }

############# interrupts #####################
    print "interrupt ";
    $plot = start_plotfile_lines_2axes($graph_interrupts);

    $cnt = 0;
    foreach my $p ( reverse sort {$int_total{$a} <=> $int_total{$b} } keys %int_total) {
	if ($int_total{$p} < 1) {
	    next;
	}
	if ($cnt > 0) {
	    print $plot ", ";
	}
	$fn = "e/int-$p";
	print $plot "'$fn' lw 2 axes x1y1";
	$cnt += 1;
	value_emit($fn, 0);

    }
    $fn = "e/count-int";
    if ($cnt > 0) {
	print $plot ", ";
    }
    print $plot "'$fn' lw 4 axes x2y2";
    $cnt += 1;
    value_emit($fn, 0);
    close_plot($cnt, $plot, $graph_interrupts);

    if ($have_diskstats) {
############# diskstats, reads #####################
	print "diskstat ";
	$plot_1 = start_plotfile_lines($graph_diskstats_reads);
	$plot_2 = start_plotfile_lines($graph_diskstats_read_time);

	$cnt_1 = $cnt_2 = 0;
	foreach my $p ( reverse sort {$dev_reads_total{$a} <=> $dev_reads_total{$b} } keys %dev_reads_total) {
	    one_plot_set("e/devreads-$p", 2, $plot_1, \$cnt_1, 1);
	    one_plot_set("e/devreadtime-$p", 2, $plot_2, \$cnt_2, 1);
	}
	close_plot($cnt_1, $plot_1, $graph_diskstats_reads);
	close_plot($cnt_2, $plot_2, $graph_diskstats_read_time);

############# diskstats, writes #####################
	$plot_1 = start_plotfile_lines($graph_diskstats_writes);
	$plot_2 = start_plotfile_lines($graph_diskstats_write_time);

	$cnt_1 = $cnt_2 = 0;
	foreach my $p ( reverse sort {$dev_writes_total{$a} <=> $dev_writes_total{$b} } keys %dev_writes_total) {
	    one_plot_set("e/devwrites-$p", 2, $plot_1, \$cnt_1, 1);
	    one_plot_set("e/devwritetime-$p", 2, $plot_2, \$cnt_2, 1);
	}
	close_plot($cnt_1, $plot_1, $graph_diskstats_writes);
	close_plot($cnt_2, $plot_2, $graph_diskstats_write_time);

    }
############# battery #####################
    if ($have_bme) {
	print "battery ";
	$plot = start_plotfile_lines_2axes($graph_battery);

	print $plot "'$batt_charge_left_file_name' lw 4 axes x1y1";
	value_emit($batt_charge_left_file_name, 1);

	print $plot ", '$batt_temperature_file_name' lw 2 axes x1y1";
	value_emit($batt_temperature_file_name, 1);

	print $plot ", '$batt_voltage_file_name' lw 2 axes x2y2";
	value_emit($batt_voltage_file_name, 1);

	close_plot($i, $plot, $graph_battery);
    }
############# rmazswap (compressed swap) #####################
    if ($have_ramzswap) {
	print "ramzswap ";
	$plot = start_plotfile_lines_2axes($graph_ramzswap);

	if (count_nonzero_entries($ramzswap_bdreads_file_name) > 0) {
	    print $plot "'$ramzswap_bdreads_file_name' lw 2 axes x1y1";
	    value_emit($ramzswap_bdreads_file_name, 1);
	    print $plot ", "
	}
	print $plot "'$ramzswap_reads_file_name' lw 2 axes x1y1";
	value_emit($ramzswap_reads_file_name, 1);
	if (count_nonzero_entries($ramzswap_bdwrites_file_name) > 0) {
	    print $plot ", '$ramzswap_bdwrites_file_name' lw 2 axes x1y1";
	    value_emit($ramzswap_bdwrites_file_name, 1);
	}
	print $plot ", '$ramzswap_writes_file_name' lw 2 axes x1y1";
	value_emit($ramzswap_writes_file_name, 1);

	print $plot ", '$ramzswap_zerop_file_name' lw 4 axes x2y2";
	value_emit($ramzswap_zerop_file_name, 1);
	print $plot ", '$ramzswap_used_file_name' lw 4 axes x2y2";
	value_emit($ramzswap_used_file_name, 1);

	close_plot($i, $plot, $graph_ramzswap);
    }
############# cgroups #####################
    if (%cgroups) {
	print "cgroups ";
	my $omit;
	my @grouplist = sort keys %cgroups;
	# mem:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_mem);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-mem";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	# Plot the limits to the same graph. We want the colors (=linetype) to
	# match the groups, hence manually amend the plotting command.
	$cnt = 1;
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-memlimit";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set($fn, 5, $plot, \$cnt, 1);
		print $plot ' lt ' . ($cnt-1);
	    } else {
		$cnt++;
	    }
	}
	close_plot($i, $plot, $graph_cgroups_mem);
	# swap:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_swap);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-swap";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_swap);
	# mem + swap:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_memsw);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-memsw";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_memsw);
	# cache:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_cache);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-cache";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_cache);
	# rss:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_rss);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-rss";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_rss);
	# mapped_file:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_mapped_file);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-mapped_file";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_mapped_file);
	# unevictable:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_unevictable);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-unevictable";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_unevictable);
	# inactive_anon:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_inactive_anon);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-inactive_anon";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_inactive_anon);
	# active_anon:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_active_anon);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-active_anon";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_active_anon);
	# inactive_file:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_inactive_file);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-inactive_file";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_inactive_file);
	# active_file:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_active_file);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-active_file";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_active_file);
	# pgpgin:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_pgpgin);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-pgpgin";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_pgpgin);
	# pgpgout:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_pgpgout);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-pgpgout";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_pgpgout);
	# process-cnt:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_process_cnt);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-process-cnt";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_process_cnt);
	# task-cnt:
	$cnt = 0;
	$plot = start_plotfile_lines($graph_cgroups_task_cnt);
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-task-cnt";
	    one_plot_set($fn, 3, $plot, \$cnt, 1);
	}
	close_plot($i, $plot, $graph_cgroups_task_cnt);
	# mem-failcnt:
	$cnt = 0;
	$omit = 1;
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-mem-failcnt";
	    if (count_nonzero_entries($fn) > 0) {
		$omit = 0;
		last;
	    }
	}
	if (!$omit) {
	    $plot = start_plotfile_lines($graph_cgroups_mem_failcnt);
	    foreach my $cgroup (@grouplist) {
		$fn = "e/cgroup-${cgroup}-mem-failcnt";
		if (count_nonzero_entries($fn) > 0) {
		    one_plot_set($fn, 3, $plot, \$cnt, 1);
		}
	    }
	    close_plot($i, $plot, $graph_cgroups_mem_failcnt);
	}
	# memsw-failcnt:
	$cnt = 0;
	$omit = 1;
	foreach my $cgroup (@grouplist) {
	    $fn = "e/cgroup-${cgroup}-memsw-failcnt";
	    if (count_nonzero_entries($fn) > 0) {
		$omit = 0;
		last;
	    }
	}
	if (!$omit) {
	    $plot = start_plotfile_lines($graph_cgroups_memsw_failcnt);
	    foreach my $cgroup (@grouplist) {
		$fn = "e/cgroup-${cgroup}-memsw-failcnt";
		if (count_nonzero_entries($fn) > 0) {
		    one_plot_set($fn, 3, $plot, \$cnt, 1);
		}
	    }
	    close_plot($i, $plot, $graph_cgroups_memsw_failcnt);
	}
    }
############# ifconfig #####################
    if (%interfaces_seen) {
	print "networking ";
	$plot = start_plotfile_lines($graph_networking_bytes);
	$cnt = 0;
	foreach my $interface (keys %interfaces_seen) {
	    $fn = "e/iface-$interface-rx-kB";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set($fn, 3, $plot, \$cnt, 1);
	    }
	    $fn = "e/iface-$interface-tx-kB";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set($fn, 3, $plot, \$cnt, 1);
	    }
	}
	close_plot($i, $plot, $graph_networking_bytes);
	$plot = start_plotfile_lines($graph_networking_packets);
	$cnt = 0;
	foreach my $interface (keys %interfaces_seen) {
	    $fn = "e/iface-$interface-rx-packets";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set($fn, 3, $plot, \$cnt, 1);
	    }
	    $fn = "e/iface-$interface-tx-packets";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set($fn, 3, $plot, \$cnt, 1);
	    }
	}
	close_plot($i, $plot, $graph_networking_packets);
    }
############# pagetypeinfo #####################
    if ($have_pagetypeinfo) {
	print "pagetypeinfo ";
	$plot_1 = start_plotfile_histogram($graph_pagetypeinfo_unmovable);
	$plot_2 = start_plotfile_histogram($graph_pagetypeinfo_reclaimable);
	$plot_3 = start_plotfile_histogram($graph_pagetypeinfo_movable);
	$plot_4 = start_plotfile_histogram($graph_pagetypeinfo_reserve);

	for ($ordernum = 0; $ordernum <= 10 ; $ordernum++) {
	    if ($ordernum > 0) {
		print $plot_1 ", ";
		print $plot_2 ", ";
		print $plot_3 ", ";
		print $plot_4 ", ";
	    }
	    $fn = "e/pt-unmov-$ordernum";
	    value_emit($fn, 1);
	    print $plot_1 "'$fn' using 2";

	    $fn = "e/pt-recl-$ordernum";
	    value_emit($fn, 1);
	    print $plot_2 "'$fn' using 2";

	    $fn = "e/pt-mov-$ordernum";
	    value_emit($fn, 1);
	    print $plot_3 "'$fn' using 2";

	    $fn = "e/pt-reserve-$ordernum";
	    value_emit($fn, 1);
	    print $plot_4 "'$fn' using 2";
	}
	close_plot($i, $plot_1, $graph_pagetypeinfo_unmovable);
	close_plot($i, $plot_2, $graph_pagetypeinfo_reclaimable);
	close_plot($i, $plot_3, $graph_pagetypeinfo_movable);
	close_plot($i, $plot_4, $graph_pagetypeinfo_reserve);
    }
############# Powertop data: optional ###################
    if ($powertop_data_found) {
	print "powertop ";
############# powertop C-states, freq-states to same multiplot #####################
	$plot = start_plotfile_histogram_multi($graph_powertop_cf_states);
	print_cf_states_plot_cmds($plot);
	close_plot($cnt, $plot, $graph_powertop_cf_states);
############# powertop powerdomain core, neon, periph states #####################
	$plot = start_plotfile_histogram_multi($graph_powertop_domain_states_1);
	print_domain_plot_cmds($plot, "core", 0.3, 0.0);
	print_domain_plot_cmds($plot, "neon", 0.3, 0.35);
	print_domain_plot_cmds($plot, "periph", 0.3, 0.7);
	close_plot($i, $plot, $graph_powertop_domain_states_1);
############# powertop powerdomain sgx, dss, mpu states #####################
	$plot = start_plotfile_histogram_multi($graph_powertop_domain_states_2);
	print_domain_plot_cmds($plot, "sgx", 0.3, 0.0);
	print_domain_plot_cmds($plot, "dss", 0.3, 0.35);
	print_domain_plot_cmds($plot, "mpu", 0.3, 0.7);
	close_plot($i, $plot, $graph_powertop_domain_states_2);
############# powertop wakeups #####################
	$plot = start_plotfile_lines($graph_powertop_wakeups);
	value_emit("e/p-wakeups", 1);
	value_emit("e/p-timers", 1);
	print $plot "'e/p-wakeups' lw 2, ";
	print $plot "'e/p-timers' lw 2 ";
	close_plot($i, $plot, $graph_powertop_wakeups);
############# powertop activity #####################
	$cnt = 0;
	%show_this = undef;
	foreach my $p (keys %p_activity) {
	    if ($num_activity_samples{$p} <= 1) {
		next;
	    }
	    $show_this{$p} = 1;
	    $cnt += 1;
	}
	my $split_point = $cnt/4;
	if($split_point > $max_per_graph_onecolumn) {
	    $split_point = $max_per_graph_onecolumn;
	}
	$plot_1 = start_plotfile_linespoints($graph_powertop_activity_1);
	$plot_2 = start_plotfile_linespoints($graph_powertop_activity_2);
	$plot_3 = start_plotfile_linespoints($graph_powertop_activity_3);
	$plot_4 = start_plotfile_linespoints($graph_powertop_activity_4);
	$cnt_1 = $cnt_2 = $cnt_3 = $cnt_4 = 0;
	foreach my $p ( reverse sort {$p_activity_max{$a} <=> $p_activity_max{$b} } keys %p_activity) {
	    if (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) > 4*$max_per_graph_onecolumn) {
		last;
	    } 
	    if (!$show_this{$p}) {
		next;
	    }
	    if (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= $split_point) {
		one_plot_set("e/$p-activity", 2, $plot_1, \$cnt_1, 0);
	    } elsif (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= 2 * $split_point) {
		one_plot_set("e/$p-activity", 2, $plot_2, \$cnt_2, 0);
	    } elsif (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= 3 * $split_point) {
		one_plot_set("e/$p-activity", 2, $plot_3, \$cnt_3, 0);
	    } elsif (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= 4 * $split_point) {
		one_plot_set("e/$p-activity", 2, $plot_4, \$cnt_4, 0);
	    }
	}
	close_plot($cnt_1, $plot_1, $graph_powertop_activity_1);
	close_plot($cnt_2, $plot_2, $graph_powertop_activity_2);
	close_plot($cnt_3, $plot_2, $graph_powertop_activity_3);
	close_plot($cnt_4, $plot_2, $graph_powertop_activity_4);
    }
}
################ Start ######################################################

@dirs = @ARGV;
$num_of_rounds = @dirs;

system("rm -f e/* $graphs_dir/??_* $html_name");
mkdir "e";
mkdir "$graphs_dir";

#
# note: this is global rounds counter! (name not well chosen..)
#
$i = 0;
# first pass, get version, scan uptime lines to determine periods
$cnt = 0;
foreach $d (@dirs) {
#
# get HW version only from first one
#
    if(!$hw_build) {
	parse_component_version();
    }
    my $fn = "$d/usage.csv";
    my $f;
    unless (open($f, $fn)) {
	print STDERR "ERROR: unable to open $fn: $!\n";
	exit(1);
    }
    while (<$f>) {
	if( m/SW-version/) {
	    $line = $_;
	    chop $line;
	    my $flds = split(' ', $line);
	    if ($flds == 3) {
# SW-version = DFL61_HARMATTAN_0.2011.03-2_RD_001
		(undef, undef, $swver) = split(' ', $line, 3);
		(undef, $swver) = split('_', $swver, 2);
	    } else {
# SW-version = Linux 2.6.35.3-10.3-n900 armv7l
		(undef, undef, $swver) = split(' ', $line, 3);
	    }
	    if($sw_version && ($sw_version ne $swver)) {
		print "** NOTE: at $d version changes [$sw_version]->[$swver]; Reflash in sequence??\n"
	    } 
	    $sw_version = $swver;
	    next;
	} 
	if( m/date = (.*)/) {
	    $round_date{$d} = $1;
	    #                                                                                                                                                    
	    # parse date into num of seconds,                                                                                                                    
	    #                                                                                                                                                    
	    $secval{$d} = date2seconds($_);
	    next;
	}
 	if( m/Uptime,Idletime /) {
	    $line = <$f>;
	    chop $line;
	    ($upt, undef) = split(',', $line, 2);
	    if ($first_upt == 0) {
		$first_upt = $upt;
	    }
	    if ($upt_prev) {
		$passed = $upt - $upt_prev;
	    } else {
		$passed = 0;
	    }
	    $lapsed_time{$cnt} = $passed; 
#	    print "$i:passed: $passed\n";
	    if ($upt < $upt_prev) {
		print "** NOTE: at $d uptime steps back. Reboot in sequence? Duration calc will have no sense..\n"
	    }
	    $upt_prev = $upt;
	    $cnt += 1;
	    last;
	} 
    }
    close $f;
    my $dfn = "$d/step.txt";
    if (-e $dfn) {
	$steps_files += 1;
    }
}

use integer;
$total_duration = $upt - $first_upt;
if ($cnt > 1) {
    $secs_per_round = $total_duration/($cnt - 1);
    $mins_per_round = $secs_per_round/60;
    $hours_per_round = $secs_per_round/3600;
    $str_hours = sprintf("%2d", $hours_per_round);
    $str_minutes = sprintf("%2d", $mins_per_round);
    $str_seconds = sprintf("%2d", $secs_per_round);
    if ($cnt > 25) {
	$samples_required = $cnt / 5;
    } elsif ($cnt < 5) {
#	$samples_required = $cnt;
	$samples_required = 2;
    } else {
	$samples_required = 5;
    }
} else {
    print STDERR "ERROR: need at least 2 rounds\n";
    exit(1);
}
if (!$secs_per_round) {
    print STDERR "ERROR: zero duration, can not calculate much\n";
    exit(1);
}
no integer;
print "endurance_plot $version; ";
print "rounds=$num_of_rounds; duration=$total_duration sec, avg-per-round: sec=$secs_per_round or min=$mins_per_round or hour=$hours_per_round\n";

print "input: ";
foreach $d (@dirs) {
    my $fn = "$d/usage.csv";
    my $f;
    unless (open($f, $fn)) {
	print STDERR "ERROR: unable to open $fn: $!\n";
	exit(1);
    }
    print "$d ";
    %shared_lpid = %shared_cpid = undef;
    %shared_lpid_cnt_oneround = %shared_cpid_cnt_oneround = undef;
    %shared_num = %shared_size = undef;
    while (<$f>) {
	if( (index($_, "Loadavg ") != -1)) {
	    $line = <$f>;
	    chop $line;
	    my ($load_1,$load_5,$load_15,$running_all,$lastpid) = split(',' , $line, 5);
	    value_store($load_1_file_name, $i, $load_1);
	    value_store($load_5_file_name, $i, $load_5);
	    value_store($load_15_file_name, $i, $load_15);
	    my ($running,$all) = split('/' , $running_all, 2);
	    value_store("e/num-processes", $i, $all);
	    next;
	} 
	if( (index($_, "Allocated FDs,") != -1)) {
	    $line = <$f>;
	    chop $line;
	    my ($Allocated_FDs,$Freed_FDs,$Max_FDs) = split(',' , $line, 3);
	    $perc_fd = (100 * $Allocated_FDs) / $Max_FDs; 
	    value_store($fd_perc_file_name, $i, $perc_fd);
	    next;
	} 
	if( index($_, "Name,State") != -1) {
	    parse_name_state_block($f);
	    next;
	} 
	if( index($_, "Shared memory segments:") != -1) {
	    parse_shmem_block($f);
	    next;
	} 
	if( index($_, "PID,FD count,Command") != -1) {
	    parse_pid_fd_block($f);
	    next;
	} 
	if( index($_, "Process status:") != -1) {
	    parse_process_status_block($f);
	    next;
	}
	if( index($_, "res-base,") != -1) {
	    parse_xresource_block($f);
	    next;
	}
	if( index($_, "Filesystem,") != -1) {
	    parse_filesystem_block($f);
	    next;
	}
	if( index($_, "MemTotal") != -1) {
	    parse_memtotal_block($f);
	    next;
	} 
	if( index($_, "nr_free_pages") != -1) {
	    parse_pages_block($f);
	    next;
	} 
    }
    close $f;
    $swap_events_cumul += $pswp_in + $pswp_out + $pgscan_kswapd_normal + 
	$pgscan_direct_normal + $slabs_scanned + $kswapd_steal;

    process_slabinfo();
    process_smaps();
    process_interrupts();
    process_diskstats();
    process_stat();
    process_powertop();
    process_bme();
    process_ramzswap();
    process_pagetypeinfo();
    process_openfds();
    process_cgroups();
    process_ifconfig();
    process_sysfs_cpu();

#    $unaccount_swapped = $swapused - $sum_app_swapped;
#    print "swap: total=$swaptotal free=$swapfree used=$swapused sum_app=$sum_app_swapped, unacc=$unaccount_swapped\n";

    value_store($app_swapped_plot_file_name, $i, $sum_app_swapped);
#    print $app_swapped_plot_file "$i, $sum_app_swapped\n";
#    value_store($unaccount_swapped_plot_file_name, $i, $unaccount_swapped);
#    print $unaccount_swapped_plot_file "$i, $unaccount_swapped\n";
    value_store($app_pss_plot_file_name, $i, $sum_app_pss);
#    print $app_pss_plot_file "$i, $sum_app_pss\n";

    loop_over_all_apps();
#    $total_shared_num = 0;
    for ($z = 0; $z <= $max_nattach ; $z++) {
#	print "round $i: z=$z; shared_num=$shared_num{$z}\n";
#	$total_shared_num += $shared_num{$z};
	$fn = "e/nattach-$z-shm";
	value_store($fn, $i, $shared_num{$z});
	if ($z > 0) {
	    $fn = "e/nattach-$z-shm-sz";
	    if (defined $shared_size{$z}) {
		value_store($fn, $i, $shared_size{$z});
	    } else {
		value_store($fn, $i, 0);
	    }
	}
    }
#    print "total shared_num=$total_shared_num\n";

#    $total_unaccounted = 512*1024 + $swapused - $sum_app_pss - $sum_app_swapped;
#	print "$i: 256M + $swapused; apps=$sum_app_pss swapped=$sum_app_swapped; total unaccount = $total_unaccounted\n";

    $i++;
}
print "\n";

$plot_width = $i * 13 + 200;
#print "desired plot_width $plot_width\n";
if ($plot_width < 1000) {
    $plot_width = 1000;
}
if ($plot_width > 1920) {
    $plot_width = 1920;
}
#print "plot_width $plot_width\n";

generate_plots();
print "$html_name ";
gen_html_page();
print "\ndone.\n";
