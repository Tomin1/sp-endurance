#!/usr/bin/perl
#
# This file is part of sp-endurance.
#
# vim: sw=4
#
# Copyright (C) 2010-2011 by Nokia Corporation
#
# Contact: Eero Tamminen <eero.tamminen@nokia.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA

use Time::Local;
use POSIX qw/ceil WIFSIGNALED WTERMSIG SIGINT SIGTERM SIGKILL/;
use List::Util qw/min max sum/;
use Getopt::Long;

my $gnuplot_terminal = 'pngcairo';

# tunables
my $ticks_per_sec = 100;
my $sector_sz = 512;
my $max_per_graph_twocolumn = 2*75;
my $max_per_graph_onecolumn = 74;
my $page_size = 4;
my $pg_bytes = 4096;
my $MB_bytes = 1024*1024;
my $samples_required = 5;
my $thumb_width = 320;
my $thumb_height = 250;
my $html_name = "index.html";
my $graphs_dir = "graphs";

my ($sw_version, $hw_build, $hw_product);
#stuff keyed by graph name with data for each graph:
my %legend;
my (%unit, %unit_1, %unit_2);
my %thumblegend;
my $plot_width;

my $forkmanager;

my $secs_per_round = 0;
my $total_duration;

# The gnuplot pngcairo color palette seems to be limited, so use our own
# colors. Based on the X11 color set.
my @line_colors = qw/FF0000 66CDAA DEB887 00FF00 87CEEB B22222 D8BFD8 2F4F4F
C71585 E9967A 90EE90 8FBC8F 9370DB 48D1CC 008080 0000CD 483D8B 9932CC E0FFFF
808000 98FB98 B8860B A52A2A 20B2AA 556B2F DC143C 808080 800080 6A5ACD 000080
A0522D 00FFFF BA55D3 00FF00 7CFC00 800000 008B8B 708090 4682B4 8B4513 2E8B57
87CEFA DA70D6 3CB371 4169E1 6B8E23 AFEEEE B0C4DE 5F9EA0 7FFFD4 BC8F8F D2691E
32CD32 9ACD32 000000 C0C0C0 00CED1 696969 EE82EE 228B22 8A2BE2 6495ED 006400
ADD8E6 CD5C5C 8B008B D3D3D3 D2B48C 40E0D0 BDB76B 1E90FF 191970 DDA0DD 7B68EE
00BFFF 4B0082 A9A9A9 7FFF00 0000FF 778899 B0E0E6 9400D3 00FF7F 008000 CD853F
00008B 8B0000 DB7093/;

######## PROCESS GRAPHS ###########

my $graph_appmem_heap = "1001_appmem_heap";
$legend{$graph_appmem_heap} = "process heap mem size";
$thumblegend{$graph_appmem_heap} = "HEAP";
$unit{$graph_appmem_heap} = "MB";

#my $graph_appmem_private_dirty = "1002_appmem_private_dirty";
#$legend{$graph_appmem_private_dirty} = "private dirty mem by processes";
#$thumblegend{$graph_appmem_private_dirty} = "PRIVATE DIRTY";
#$unit{$graph_appmem_private_dirty} = "MB";

my $graph_appmem_pss_swap = "1003_appmem_pss_swap";
$legend{$graph_appmem_pss_swap} = "apps PSS+SWAP";
$thumblegend{$graph_appmem_pss_swap} = "PSS+SWAP";
$unit{$graph_appmem_pss_swap} = "MB";

my $graph_appmem_pss = "1004_appmem_pss";
$legend{$graph_appmem_pss} = "apps PSS";
$thumblegend{$graph_appmem_pss} = "PSS";
$unit{$graph_appmem_pss} = "MB";

my $graph_appmem_pss_swap_lines_big = "1005_appmem_pss_swap_lines_big";
$unit{$graph_appmem_pss_swap_lines_big} = "MB";

my $graph_appmem_pss_swap_lines_small = "1005_appmem_pss_swap_lines_small";
$unit{$graph_appmem_pss_swap_lines_small} = "MB";

my $graph_appmem_pss_swap_lines_smaller = "1005_appmem_pss_swap_lines_smaller";
$unit{$graph_appmem_pss_swap_lines_smaller} = "MB";

my $graph_appmem_pss_swap_lines_smallest = "1005_appmem_pss_swap_lines_smallest";
$unit{$graph_appmem_pss_swap_lines_smallest} = "MB";

my $graph_appmem_swapped = "1006_appmem_swapped";
$legend{$graph_appmem_swapped} = "swap used by processes";
$thumblegend{$graph_appmem_swapped} = "SWAP USE";
$unit{$graph_appmem_swapped} = "MB";

my $graph_events_major_pagefaults = "1010_events_major_pagefaults";
$legend{$graph_events_major_pagefaults} = "major page faults";
$thumblegend{$graph_events_major_pagefaults} = "PAGE FAULTS";
$unit{$graph_events_major_pagefaults} = "count per second";

my $graph_appmem_locked = "1020_appmem_locked";
$legend{$graph_appmem_locked} = "process locked mem size";
$thumblegend{$graph_appmem_locked} = "LOCKED";
$unit{$graph_appmem_locked} = "MB";

my $graph_appmem_wx = "1030_appmem_wx";
$legend{$graph_appmem_wx} = "executable mem which is writable, security issue";
$thumblegend{$graph_appmem_wx} = "WRITABLE-EXEC";
$unit{$graph_appmem_wx} = "MB";

my $graph_vmsize = "1040_vmsize";
$legend{$graph_vmsize} = "process virtual mem size";
$thumblegend{$graph_vmsize} = "VMSIZE";
$unit{$graph_vmsize} = "MB";

my $graph_appmem_sysvshared = "1050_appmem_sysvshared";
$legend{$graph_appmem_sysvshared} = "process SYSV-shared mem size";
$thumblegend{$graph_appmem_sysvshared} = "SYSV-SHAREDMEM";
$unit{$graph_appmem_sysvshared} = "MB";

my $graph_appmem_posixshared = "1051_appmem_posixshared";
$legend{$graph_appmem_posixshared} = "process POSIX-shared mem size";
$thumblegend{$graph_appmem_posixshared} = "POSIX-SHAREDMEM";
$unit{$graph_appmem_posixshared} = "MB";

my $graph_mem_shared_cpid = "1052_mem_shared_cpid";
$legend{$graph_mem_shared_cpid} = "shared by creator (cpid)";
$thumblegend{$graph_mem_shared_cpid} = "SHMEM CREATOR";
$unit{$graph_mem_shared_cpid} = "MB";

my $graph_mem_shared_lpid = "1053_mem_shared_lpid";
$legend{$graph_mem_shared_lpid} = "shared by last user (lpid)";
$thumblegend{$graph_mem_shared_lpid} = "SHMEM LAST USER";
$unit{$graph_mem_shared_lpid} = "MB";

my $graph_mem_shared_lpid_name = "1054_mem_shared_lpid_name";
$legend{$graph_mem_shared_lpid_name} = "shared by last user-pname (lpid)";
$thumblegend{$graph_mem_shared_lpid_name} = "SHMEM LAST PNAME";
$unit{$graph_mem_shared_lpid_name} = "MB";

my $graph_appmem_devpvr = "1060_appmem_devpvr";
$legend{$graph_appmem_devpvr} = "Total virtual size of process /dev/pvrsrvkm mappings";
$thumblegend{$graph_appmem_devpvr} = "/dev/pvrsrvkm &mdash; MAPPING SIZE";
$unit{$graph_appmem_devpvr} = "MB";

my $graph_devpvr_count = "1061_devpvr_count";
$legend{$graph_devpvr_count} = "Process /dev/pvrsrvkm mapping count (processes with changes)";
$thumblegend{$graph_devpvr_count} = "/dev/pvrsrvkm &mdash; MAPPING COUNT";
$unit{$graph_devpvr_count} = "count";

my $graph_xresource_sz_pxm = "1070_xresource_pixmaps";
$legend{$graph_xresource_sz_pxm} = "X resource pixmaps size";
$thumblegend{$graph_xresource_sz_pxm} = "X-RESOURCES-PIXMAPS";
$unit{$graph_xresource_sz_pxm} = "Size of Xres pixmaps, kB";

my $graph_xresource_cnt = "1071_xresource_count";
$legend{$graph_xresource_cnt} = "X resource counts";
$thumblegend{$graph_xresource_cnt} = "X-RESOURCES-COUNT";
$unit{$graph_xresource_cnt} = "number of Xres objects";

#my $graph_xresource_sz_misc = "1072_xresource_misc";
#$legend{$graph_xresource_sz_misc} = "X resource misc size";
#$thumblegend{$graph_xresource_sz_misc} = "X-RESOURCES-MISC";
#$unit{$graph_xresource_sz_misc} = "Size of Xres misc, kB";

my $graph_fdcount = "1080_fdcount";
$legend{$graph_fdcount} = "FD use by processes";
$thumblegend{$graph_fdcount} = "FILE DESCR";
$unit{$graph_fdcount} = "number of FD";

my $graph_fdcount_inotify = "1080_fdcount_inotify";
$legend{$graph_fdcount_inotify} = "inotify FD use by processes";
$thumblegend{$graph_fdcount_inotify} = "INOTIFY FILE DESCR";
$unit{$graph_fdcount_inotify} = "number of FD";

my $graph_fdcount_pipe = "1080_fdcount_pipe";
$legend{$graph_fdcount_pipe} = "pipe FD use by processes";
$thumblegend{$graph_fdcount_pipe} = "PIPE FILE DESCR";
$unit{$graph_fdcount_pipe} = "number of FD";

my $graph_fdcount_socket = "1080_fdcount_socket";
$legend{$graph_fdcount_socket} = "socket FD use by processes";
$thumblegend{$graph_fdcount_socket} = "SOCKET FILE DESCR";
$unit{$graph_fdcount_socket} = "number of FD";

my $graph_fdcount_tmpfs = "1080_fdcount_tmpfs";
$legend{$graph_fdcount_tmpfs} = "/dev, /sys, /syspart, /proc, /tmp, /var/run FD use by processes";
$thumblegend{$graph_fdcount_tmpfs} = "TMPFS FILE DESCR";
$unit{$graph_fdcount_tmpfs} = "number of FD";

my $graph_fdcount_eventfd = "1080_fdcount_eventfd";
$legend{$graph_fdcount_eventfd} = "eventfd FD use by processes";
$thumblegend{$graph_fdcount_eventfd} = "EVENTFD FILE DESCR";
$unit{$graph_fdcount_eventfd} = "number of FD";

my $graph_fdcount_epoll = "1080_fdcount_epoll";
$legend{$graph_fdcount_epoll} = "epoll FD use by processes";
$thumblegend{$graph_fdcount_epoll} = "EPOLL FILE DESCR";
$unit{$graph_fdcount_epoll} = "number of FD";

my $graph_fdcount_signalfd = "1080_fdcount_signalfd";
$legend{$graph_fdcount_signalfd} = "signalfd FD use by processes";
$thumblegend{$graph_fdcount_signalfd} = "SIGNALFD FILE DESCR";
$unit{$graph_fdcount_signalfd} = "number of FD";

my $graph_fdcount_timerfd = "1080_fdcount_timerfd";
$legend{$graph_fdcount_timerfd} = "timerfd FD use by processes";
$thumblegend{$graph_fdcount_timerfd} = "TIMERFD FILE DESCR";
$unit{$graph_fdcount_timerfd} = "number of FD";

my $graph_fdcount_disk = "1080_fdcount_disk";
$legend{$graph_fdcount_disk} = "disk FD use by processes";
$thumblegend{$graph_fdcount_disk} = "DISK FILE DESCR";
$unit{$graph_fdcount_disk} = "number of FD";

my $graph_cpu_totaltime = "1150_cpu_totaltime";
$legend{$graph_cpu_totaltime} = "CPU total time";
$thumblegend{$graph_cpu_totaltime} = "TOTAL CPU TIME";
$unit{$graph_cpu_totaltime} = "percent";

my $graph_cpu_usertime = "1160_cpu_usertime";
$legend{$graph_cpu_usertime} = "CPU user time";
$thumblegend{$graph_cpu_usertime} = "USER CPU TIME";
$unit{$graph_cpu_usertime} = "percent";

my $graph_cpu_systime = "1162_cpu_systime";
$legend{$graph_cpu_systime} = "CPU system time";
$thumblegend{$graph_cpu_systime} = "SYSTEM CPU TIME";
$unit{$graph_cpu_systime} = "percent";

my $graph_events_ctx_total = "1165_ctx_total";
$legend{$graph_events_ctx_total} = "process total context switches";
$thumblegend{$graph_events_ctx_total} = "CTX TOTAL";
$unit{$graph_events_ctx_total} = "count per second";

my $graph_events_ctx_nonvolunt = "1166_ctx_nonvolunt";
$legend{$graph_events_ctx_nonvolunt} = "process non-voluntary context switches";
$thumblegend{$graph_events_ctx_nonvolunt} = "CTX NONVOLUNTARY";
$unit{$graph_events_ctx_nonvolunt} = "count per second";

my $graph_events_ctx_volunt = "1166_ctx_volunt";
$legend{$graph_events_ctx_volunt} = "process voluntary context switches";
$thumblegend{$graph_events_ctx_volunt} = "CTX VOLUNTARY";
$unit{$graph_events_ctx_volunt} = "count per second";

my $graph_threads_count = "1200_threads_count";
$legend{$graph_threads_count} = "Number of threads per process";
$thumblegend{$graph_threads_count} = "THREAD COUNT";
$unit{$graph_threads_count} = "number of threads";

my $graph_threads_changes = "1201_threads_changes";
$legend{$graph_threads_changes} = "Number of threads per process (only changed shown)";
$thumblegend{$graph_threads_changes} = "THREAD CHANGES";
$unit{$graph_threads_changes} = "number of threads";

######## SYSTEM GRAPHS ###########

my $graph_battery = "2000_battery";
$legend{$graph_battery} = "battery: left:charge left; right: voltage";
$thumblegend{$graph_battery} = "BATTERY";
$unit_1{$graph_battery} = "charge-percent, temp-C";
$unit_2{$graph_battery} = "mV";

my $graph_diskspace = "2001_diskspace";
$legend{$graph_diskspace} = "file systems and global FD set";
$thumblegend{$graph_diskspace} = "DISK USED, GLOBAL FD %";
$unit{$graph_diskspace} = "percentage used";

my $graph_loadavg = "2005_loadavg";
$legend{$graph_loadavg} = "Load average";
$thumblegend{$graph_loadavg} = "LOAD AVG 1m/5m/15m";
$unit{$graph_loadavg} = "loadavg units";

my $graph_cpu = "2015_cpu";
$legend{$graph_cpu} = "CPU utilization";
$thumblegend{$graph_cpu} = "CPU UTILIZATION";
$unit{$graph_cpu} = "percent";

my $graph_processes_global = "2050_processes_created";
$legend{$graph_processes_global} = "Processes/threads created";
$thumblegend{$graph_processes_global} = "PROC/THREADS CREATED";
$unit{$graph_processes_global} = "count per minute";

my $graph_ctx_global = "2060_ctx_global";
$legend{$graph_ctx_global} = "left: CTX switches; right: num of processes";
$thumblegend{$graph_ctx_global} = "CTX-SW,PROC-NUM";
$unit_1{$graph_ctx_global} = "context switches: per second";
$unit_2{$graph_ctx_global} = "num-of-processes: count";

my $graph_nonsleeping_process_count = "2065_nonsleeping_process_count";
$legend{$graph_nonsleeping_process_count} = "number of processes in non-sleep states";
$thumblegend{$graph_nonsleeping_process_count} = "NON-SLEEP PROCESS COUNT";
$unit{$graph_nonsleeping_process_count} = "number";

my $graph_interrupts = "2070_interrupts";
$legend{$graph_interrupts} = "left:specific interrupts; right: sum of all interrupts";
$thumblegend{$graph_interrupts} = "INTERRUPTS";
$unit{$graph_interrupts} = "count per second";

my $graph_diskstats_reads_mb = "2100_diskstats_reads_mb";
$legend{$graph_diskstats_reads_mb} = "Bytes read from device";
$thumblegend{$graph_diskstats_reads_mb} = "DISK READS &mdash; MB";
$unit{$graph_diskstats_reads_mb} = 'MB';

my $graph_diskstats_reads_mb_per_second = "2100_diskstats_reads_mb_per_second";
$legend{$graph_diskstats_reads_mb_per_second} = "Bytes read from device";
$thumblegend{$graph_diskstats_reads_mb_per_second} = "DISK READS &mdash; MB/s";
$unit{$graph_diskstats_reads_mb_per_second} = "MB per second";

my $graph_diskstats_writes_mb = '2101_diskstats_writes_mb';
$legend{$graph_diskstats_writes_mb} = "Bytes written to device";
$thumblegend{$graph_diskstats_writes_mb} = "DISK WRITES &mdash; MB";
$unit{$graph_diskstats_writes_mb} = 'MB';

my $graph_diskstats_writes_mb_per_second = "2101_diskstats_writes_mb_per_second";
$legend{$graph_diskstats_writes_mb_per_second} = "Bytes written to device";
$thumblegend{$graph_diskstats_writes_mb_per_second} = "DISK WRITES &mdash; MB/s";
$unit{$graph_diskstats_writes_mb_per_second} = "MB per second";

my $graph_ext4_written = '2102_ext4_written';
$legend{$graph_ext4_written} = 'Bytes written to the ext4 partitions';
$thumblegend{$graph_ext4_written} = 'EXT4 WRITES';
$unit{$graph_ext4_written} = 'MB';

my $graph_diskstats_read_time = "2105_diskstats_read_time";
$legend{$graph_diskstats_read_time} = "diskstats_read_time";
$thumblegend{$graph_diskstats_read_time} = "DISKREAD TIME";
$unit{$graph_diskstats_read_time} = "ms per sector";

my $graph_diskstats_write_time = "2105_diskstats_write_time";
$legend{$graph_diskstats_write_time} = "diskstats_write_time";
$thumblegend{$graph_diskstats_write_time} = "DISKWRITE TIME";
$unit{$graph_diskstats_write_time} = "ms per sector";

my $graph_events_swap = "2110_events_swap";
$legend{$graph_events_swap} = "swap-related events";
$thumblegend{$graph_events_swap} = "SWAP EVENTS";
$unit{$graph_events_swap} = "count per second";

my $graph_ramzswap = "2111_ramzswap";
$legend{$graph_ramzswap} = "compressed swap counters; left:reads/writes right:used amount, bold";
$thumblegend{$graph_ramzswap} = "COMPR-SWAP";
$unit_1{$graph_ramzswap} = "MB per second";
$unit_2{$graph_ramzswap} = "MB used";

my $graph_system_memory_1   = "2200_system_memory_1";
$legend{$graph_system_memory_1} = "system-level memory";
$thumblegend{$graph_system_memory_1} = "SYSTEM MEMORY 1";
$unit{$graph_system_memory_1} = "MB";

my $graph_system_memory_2 = "2200_system_memory_2";
$legend{$graph_system_memory_2} = "system-level memory 2";
$thumblegend{$graph_system_memory_2} = "SYSTEM MEMORY 2";
$unit{$graph_system_memory_2} = "MB";

my $graph_mem_shared = "2240_mem_shared";
$legend{$graph_mem_shared} = "shared memory";
$thumblegend{$graph_mem_shared} = "SHMEM";
$unit{$graph_mem_shared} = "MB";

my $graph_mem_shared_number = "2240_mem_shared_number";
#$legend{$graph_mem_shared_number} = "shared mem number of segments; nattach-0: real orphans";
#$legend{$graph_mem_shared_number} = "shared mem number of segments and attach-avg-age (sec)";
$legend{$graph_mem_shared_number} = "left: num of shmem segments by attached proc; right: num of all shmem segments";
$thumblegend{$graph_mem_shared_number} = "SHMEM ATTACH COUNT";
$unit_1{$graph_mem_shared_number} = "count by attached processes";
$unit_2{$graph_mem_shared_number} = "count of all";

my $graph_mem_shared_size = "2240_mem_shared_size";
$legend{$graph_mem_shared_size} = "shared by nattach, size";
$thumblegend{$graph_mem_shared_size} = "SHMEM ATTACH SIZES";
$unit{$graph_mem_shared_size} = "MB";

my $graph_mem_slabs = "2255_mem_slabs";
$legend{$graph_mem_slabs} = "kernel slab memory";
$thumblegend{$graph_mem_slabs} = "KERNEL SLABS";
$unit{$graph_mem_slabs} = "kB";

my $graph_cgroups_mem = "2300_cgroups-mem";
$legend{$graph_cgroups_mem} = "memory usage per cgroup";
$thumblegend{$graph_cgroups_mem} = "CGROUPS MEMORY";
$unit{$graph_cgroups_mem} = "MB";

my $graph_cgroups_swap = "2300_cgroups-swap";
$legend{$graph_cgroups_swap} = "swap usage per cgroup";
$thumblegend{$graph_cgroups_swap} = "CGROUPS SWAP";
$unit{$graph_cgroups_swap} = "MB";

my $graph_cgroups_memsw = "2301_cgroups-memsw";
$legend{$graph_cgroups_memsw} = "memory+swap usage per cgroup";
$thumblegend{$graph_cgroups_memsw} = "CGROUPS MEMORY+SWAP";
$unit{$graph_cgroups_memsw} = "MB";

my $graph_cgroups_cache = "2302_cgroups-cache";
$legend{$graph_cgroups_cache} = "page cache per cgroup";
$thumblegend{$graph_cgroups_cache} = "CGROUPS PAGE CACHE";
$unit{$graph_cgroups_cache} = "MB";

my $graph_cgroups_rss = "2302_cgroups-rss";
$legend{$graph_cgroups_rss} = "rss (anonymous + swap cache) per cgroup";
$thumblegend{$graph_cgroups_rss} = "CGROUPS RSS";
$unit{$graph_cgroups_rss} = "MB";

my $graph_cgroups_mapped_file = "2302_cgroups-mapped_file";
$legend{$graph_cgroups_mapped_file} = "mapped file per cgroup";
$thumblegend{$graph_cgroups_mapped_file} = "CGROUPS MAPPED FILE";
$unit{$graph_cgroups_mapped_file} = "MB";

my $graph_cgroups_unevictable = "2302_cgroups-unevictable";
$legend{$graph_cgroups_unevictable} = "unevictable memory per cgroup";
$thumblegend{$graph_cgroups_unevictable} = "CGROUPS UNEVICTABLE";
$unit{$graph_cgroups_unevictable} = "MB";

my $graph_cgroups_inactive_anon = "2303_cgroups-inactive_anon";
$legend{$graph_cgroups_inactive_anon} = "anon + swap cache on inactive LRU list per cgroup";
$thumblegend{$graph_cgroups_inactive_anon} = "CGROUPS INACTIVE ANON";
$unit{$graph_cgroups_inactive_anon} = "MB";

my $graph_cgroups_active_anon = "2303_cgroups-active_anon";
$legend{$graph_cgroups_active_anon} = "anon + swap cache on active LRU list per cgroup";
$thumblegend{$graph_cgroups_active_anon} = "CGROUPS ACTIVE ANON";
$unit{$graph_cgroups_active_anon} = "MB";

my $graph_cgroups_inactive_file = "2304_cgroups-inactive_file";
$legend{$graph_cgroups_inactive_file} = "file-backed memory on inactive LRU list per cgroup";
$thumblegend{$graph_cgroups_inactive_file} = "CGROUPS INACTIVE FILE";
$unit{$graph_cgroups_inactive_file} = "MB";

my $graph_cgroups_active_file = "2304_cgroups-active_file";
$legend{$graph_cgroups_active_file} = "file-backed memory on active LRU list per cgroup";
$thumblegend{$graph_cgroups_active_file} = "CGROUPS ACTIVE FILE";
$unit{$graph_cgroups_active_file} = "MB";

my $graph_cgroups_pgpgin = "2305_cgroups-pgpgin";
$legend{$graph_cgroups_pgpgin} = "cgroups pages paged in";
$thumblegend{$graph_cgroups_pgpgin} = "CGROUPS PGPGIN";
$unit{$graph_cgroups_pgpgin} = "number of events";

my $graph_cgroups_pgpgout = "2305_cgroups-pgpgout";
$legend{$graph_cgroups_pgpgout} = "cgroups pages paged out";
$thumblegend{$graph_cgroups_pgpgout} = "CGROUPS PGPGOUT";
$unit{$graph_cgroups_pgpgout} = "number of events";

my $graph_cgroups_process_cnt = "2305_cgroups-process-cnt";
$legend{$graph_cgroups_process_cnt} = "cgroups process count";
$thumblegend{$graph_cgroups_process_cnt} = "CGROUPS PROCESS CNT";
$unit{$graph_cgroups_process_cnt} = "processes";

my $graph_cgroups_task_cnt = "2305_cgroups-task_cnt";
$legend{$graph_cgroups_task_cnt} = "cgroups thread (task) count";
$thumblegend{$graph_cgroups_task_cnt} = "CGROUPS THREAD CNT";
$unit{$graph_cgroups_task_cnt} = "tasks";

my $graph_cgroups_mem_failcnt = "2306_cgroups-mem_failcnt";
$legend{$graph_cgroups_mem_failcnt} = "cgroups memory fail count";
$thumblegend{$graph_cgroups_mem_failcnt} = "CGROUPS MEMORY FAILCNT";
$unit{$graph_cgroups_mem_failcnt} = "number of events";

my $graph_cgroups_memsw_failcnt = "2306_cgroups-memsw_failcnt";
$legend{$graph_cgroups_memsw_failcnt} = "cgroups memory+swap fail count";
$thumblegend{$graph_cgroups_memsw_failcnt} = "CGROUPS MEMORY+SWAP FAILCNT";
$unit{$graph_cgroups_memsw_failcnt} = "number of events";

my $graph_wchan_count = '2350_wchan-count';
$legend{$graph_wchan_count} = 'Process count per wait channel';
$thumblegend{$graph_wchan_count} = 'WAIT CHANNEL COUNT';
$unit{$graph_wchan_count} = 'process count';

my $graph_wchan_changes = '2351_wchan-changes';
$legend{$graph_wchan_changes} = 'Process count per wait channel (only changed shown)';
$thumblegend{$graph_wchan_changes} = 'WAIT CHANNEL CHANGES';
$unit{$graph_wchan_changes} = 'process count';

#
# Note: powertop is optional. it's files are not collected
# by standard sp-endurance, but it is easy to use 
# "powertop as sleep" in measurement cycle and save 1xx/powertop.out
# If such was made, we graph something from powertop output
#
my $graph_powertop_wakeups = "2900_powertop_wakeups";
$legend{$graph_powertop_wakeups} = "Powertop-wakeups";
$thumblegend{$graph_powertop_wakeups} = "WAKEUPS";
$unit{$graph_powertop_wakeups} = "count per second";

my $graph_powertop_timers = "2905_powertop_timers";
$legend{$graph_powertop_timers} = "Powertop-timers";
$thumblegend{$graph_powertop_timers} = "TIMERS";
$unit{$graph_powertop_timers} = "count per second";

my $graph_powertop_activity_1 = "2901_powertop_activity";
$legend{$graph_powertop_activity_1} = "Powertop-activity";
$thumblegend{$graph_powertop_activity_1} = "P-ACTIVITY";
$unit{$graph_powertop_activity_1} = "events per second";

my $graph_powertop_activity_2 = "2902_powertop_activity";
$legend{$graph_powertop_activity_2} = "Powertop-activity-2";
$thumblegend{$graph_powertop_activity_2} = "P-ACTIVITY 2";
$unit{$graph_powertop_activity_2} = "events per second";

my $graph_powertop_activity_3 = "2903_powertop_activity";
$legend{$graph_powertop_activity_3} = "Powertop-activity-3";
$thumblegend{$graph_powertop_activity_3} = "P-ACTIVITY 3";
$unit{$graph_powertop_activity_3} = "events per second";

my $graph_powertop_activity_4 = "2904_powertop_activity";
$legend{$graph_powertop_activity_4} = "Powertop-activity-4";
$thumblegend{$graph_powertop_activity_4} = "P-ACTIVITY 4";
$unit{$graph_powertop_activity_4} = "events per second";

my $graph_powertop_cf_states = "2910_powertop_cf";
$legend{$graph_powertop_cf_states} = "Powertop CF-states";
$thumblegend{$graph_powertop_cf_states} = "CF-STATES";
$unit{$graph_powertop_cf_states} = "percentage";

my $graph_powertop_domain_states_1 = "2920_powertop_domain";
$legend{$graph_powertop_domain_states_1} = "Powertop Domain states";
$thumblegend{$graph_powertop_domain_states_1} = "POWERDOMAIN-STATES 1";
$unit{$graph_powertop_domain_states_1} = "percentage";

my $graph_powertop_domain_states_2 = "2921_powertop_domain";
$legend{$graph_powertop_domain_states_2} = "Powertop Domain states";
$thumblegend{$graph_powertop_domain_states_2} = "POWERDOMAIN-STATES 2";
$unit{$graph_powertop_domain_states_2} = "percentage";

# optional, swap-fragmentation is generated by another tool 
# gen_swapfrag-for-apps.pl which is not part of standard sp-endurance;
# but we put it's thumbnail on same page, if present
# note different numbering, it survives the removal of previous
# other graphs when this script deletes graphs/[12]???_* before run
my @graph_fragmentation = (
"3951_fragmentation",
"3952_fragmentation",
"3953_fragmentation");

my @gnuplot_commands;

my @dirs;
my %val;
my %all_apps;
my %pid_by_namepid;
my %name_by_pid;
my (%has_threads, %has_threads_samples);
my %all_slabs;
my (%shared_lpid, %shared_cpid);
my (%shared_lpid_cnt, %shared_lpid_cnt_oneround);
my (%shared_cpid_cnt, %shared_cpid_cnt_oneround);
my %shared_lpid_names_all_sz;
my (%shared_num, %shared_size, %shared_used);
my (%fd_count, %fd_count_samples, %fd_count_diff, %fd_count_prev);
my %pss_swap_num_samples;
my %lapsed_time;
my @uptimes;
my $global_ctx_prev = 0;
my $global_processes_prev;
my $memfree_plot_file_name = "e/memfree";
my $buffers_plot_file_name = "e/buffers";
my $cached_plot_file_name = "e/cached";
my $swapcached_plot_file_name = "e/swapcached";
my $kernelstack_plot_file_name = "e/kernelstack";
my $shmem_plot_file_name = "e/shmem";
my $swapused_plot_file_name = "e/swapused";
my $dirty_plot_file_name = "e/dirty";
my $active_file_plot_file_name = "e/active_file";
my $inactive_file_plot_file_name = "e/inactive_file";
my $active_anon_plot_file_name = "e/active_anon";
my $inactive_anon_plot_file_name = "e/inactive_anon";
my $mlocked_plot_file_name = "e/mlocked";
my $mpixmaps_plot_file_name = "e/mpixmaps";
my $mapped_plot_file_name = "e/mapped";
my $slabreclaim_plot_file_name = "e/slabreclaim";
my $slabunreclaim_plot_file_name = "e/slabunreclaim";
my $pagetables_plot_file_name = "e/pagetables";
my $pswp_in_plot_file_name = "e/pswp_in";
my $pswp_out_plot_file_name = "e/pswp_out";
my $pgscan_kswapd_normal_plot_file_name = "e/pgscan_kswapd_normal";
my $pgscan_direct_normal_plot_file_name = "e/pgscan_direct_normal";
my $slabs_scanned_plot_file_name = "e/slabs_scanned";
my $kswapd_steal_plot_file_name = "e/kswapd_steal";
my $shared_locked_plot_file_name = "e/shared_locked";
my $shared_unlocked_plot_file_name = "e/shared_unlocked";
my $app_swapped_plot_file_name = "e/all_apps_swapped";
my $app_pss_plot_file_name = "e/all_apps_pss";
my $load_1_file_name = "e/load_1_min";
my $load_5_file_name = "e/load_5_min";
my $load_15_file_name = "e/load_15_min";
my $fd_perc_file_name = "e/global-FD-percentage";

my $batt_charge_left_file_name = "e/batt-charge-left";
#my $batt_reporting_file_name = "e/batt-reporting";
my $batt_voltage_file_name = "e/batt-voltage";
my $batt_temperature_file_name = "e/batt-temp";

my $ramzswap_bdreads_file_name = "e/ramzswap-bdreads";
my $ramzswap_reads_file_name = "e/ramzswap-reads";
my $ramzswap_bdwrites_file_name = "e/ramzswap-bdwrites";
my $ramzswap_writes_file_name = "e/ramzswap-writes";
my $ramzswap_zerop_file_name = "e/ramzswap-zerop";
my $ramzswap_used_file_name = "e/ramzswap-used";

my $pswp_in_prev = 0;
my $pswp_out_prev = 0;
my $pgscan_kswapd_normal_prev = 0;
my $pgscan_direct_normal_prev = 0;
my $slabs_scanned_prev = 0;
my $kswapd_steal_prev = 0;

my (%int_prev, %int_total);
my (%dev_reads_total, %dev_reads_prev);
my (%dev_writes_total, %dev_writes_prev);
my (%dev_time_per_read_prev, %dev_time_per_write_prev);
my %cumul_vol_ctx;
my %cumul_nonvol_ctx;
my %cumul_total_ctx;
my %param_prev_vol_ctx;
my %param_prev_nonvol_ctx;
my %majflt_prev;
my %majflt_cumul;
my %minflt_prev;
my %minflt_cumul;
my %param_prev_utime;
my %param_prev_stime;
my %utime_cumul;
my %stime_cumul;
my %totaltime_cumul;
my %prev_cpu_ticks;
my %prev_cgroups_stats;
my %prev_cgroups_mem_failcnt;
my %prev_cgroups_memsw_failcnt;
my %process_states_seen;

my %fd_samples;
my %fd_inotify;
my %fd_pipe;
my %fd_socket;
my %fd_tmpfs;
my %fd_dev;
my %fd_sys;
my %fd_syspart;
my %fd_proc;
my %fd_eventfd;
my %fd_epoll;
my %fd_signalfd;
my %fd_timerfd;
my %fd_disk;

my %app_pss;
my %app_swapped;
my %app_sum_locked;
my (%app_sum_vmsz, %prev_vmsize, %changed_vmsize);
#my %app_private_dirty;
my %app_sysv_shared;
my %app_posix_shared;
my %app_rwxp;
my %app_dev_pvr;

my %app_cumul_pss;
my %app_cumul_swp;
#my %app_cumul_private_dirty;
my %app_cumul_pss_swp;
my %app_cumul_rwxp;
my %app_cumul_sysv_shared;
my %app_cumul_posix_shared;
my %app_cumul_dev_pvr;

my %avg_pss;
my %avg_heap;
#my %avg_private_dirty;
my %avg_swp;
my %avg_pss_swp;
my %avg_shared_lpid;
my %avg_shared_cpid;
my %avg_sysv_shared;
my %avg_posix_shared;
my %avg_dev_pvr;

my %devcount_pss;
my %devcount_swp;
#my %devcount_private_dirty;
my %devcount_heap;
my %devcount_pss_swp;
my %devcount_shared_lpid;
my %devcount_shared_cpid;
my %devcount_sysv_shared;
my %devcount_posix_shared;
my %devcount_dev_pvr;

my %sumdev_pss;
my %sumdev_swp;
#my %sumdev_private_dirty;
my %sumdev_heap;
my %sumdev_pss_swp;
my %sumdev_pss_swp_adj;
my %sumdev_shared_lpid;
my %sumdev_shared_cpid;
my %sumdev_sysv_shared;
my %sumdev_posix_shared;
my %sumdev_dev_pvr;

my %show_this;
my %xresource_latest_cnt;
my %xresource_latest_sz_pxm;
my %xresource_latest_sz_misc;
my %xres_pxm_size_total;
my %filesystem_names;
my %filesystem_demangle;
my %filesystem_to_mountpoint;
my $max_nattach = 0;

my (%images, %thumbnames);
my %xres_samples;
my %xres_atoms_seen;
my %p_activity;
my $powertop_data_found = 0;
my %seen_powertop_c_levels;
my %seen_powertop_f_levels;
my %p_activity_max;

my %sum_heap;
my %num_heap_samples;
my %max_heap;
my %num_activity_samples;

my %files;
my %secval;
my %round_date;

my $have_diskstats = 0;
my $have_ramzswap = 0;
my $have_bme = 0;
my $have_pagetypeinfo = 0;

my $prev_ramzswap_bdreads;
my $prev_ramzswap_bdwrites;
my $prev_ramzswap_reads;
my $prev_ramzswap_writes;

my $swapused_total = 0;
my $swap_pgout_total = 0;

my %vma_count;
my %vma_count_max;
my $steps_files = 0;

my %cgroups;
my %cgroups_demangle;
my %interfaces_seen;
my %interfaces_prev_rx_packets;
my %interfaces_prev_tx_packets;
my %interfaces_prev_rx_kB;
my %interfaces_prev_tx_kB;

my %time_in_state_freqs_seen;
my %prev_time_in_state_pcpu;

my %sysfs_fs_prev;
my %sysfs_fs_devices_seen;
my %sysfs_power_supply_devices;
my %sysfs_power_supply_device_model_name;
my %sysfs_power_supply_device_manufacturer;
my %sysfs_backlight_devices;

my %wchan_seen;

sub compression_check
{
    my ($file) = @_;
    my $lzoname = $file . '.lzo';
    my $gzname = $file . '.gz';
    my $xzname = $file . '.xz';
    if (-e $lzoname) {
	return "lzop -dc $lzoname |";
    } elsif (-e $gzname) {
	return "zcat $gzname |";
    } elsif (-e $xzname) {
	return "xzcat $xzname |";
    }
    return $file;
}

sub date2seconds
{
    my ($date_time) = @_;
    my ($date, $time) = split(' ', $date_time, 2);
    my ($year, $mon, $day) = split('-', $date, 3);
    my ($hour, $min, $sec) = split(':', $time, 3);
    my $retsec = timelocal($sec, $min, $hour, $day, $mon-1, $year-1900);
    return $retsec;
}

sub one_plot_set
{
    my %args = @_;

    my $fn = $args{fn} or die "INTERNAL ERROR: 'fn' parameter required for one_plot_set()";
    my $lw = $args{lw};
    my $plot = $args{plot} or die "INTERNAL ERROR: 'plot' parameter required for one_plot_set()";
    my $r_cnt = $args{cnt} or die "INTERNAL ERROR: 'cnt' parameter required for one_plot_set()";
    my $emit_zeroes = $args{emit_zeroes};
    my $title = $args{title};
    my $lc = $args{lc};
    my $axes = $args{axes};

    my $num = value_emit($fn, $emit_zeroes);

    if ($num) {
	if ($$r_cnt > 0) {
	    print $plot ", ";
	}
	if (not $lc) {
	    $lc = $line_colors[$$r_cnt % @line_colors];
	}
	if ($lw) {
	    # line plot
	    print $plot "'$fn' lt ";
	    print $plot "rgb '#$lc' " if $lc;
	    print $plot "lw $lw";
	} else {
	    # histogram
	    print $plot "'$fn' using 2 ";
	    print $plot "lc rgb '#$lc' " if $lc;
	}
	print $plot " axes $axes " if $axes;
	$$r_cnt += 1;
	if (length $title) {
	    print $plot " title \"$title\"";
	}
    }
}

sub value_exists($)
{
    my $fn = shift;

    if($files{$fn}) {
	return 1;
    } else {
	return 0;
    }
}

sub value_store_zeropad($$$)
{
    my $fn = shift;
    my $rnd = shift;
    my $val = shift;
    my $z;

    if (!value_exists($fn)) {
	for ($z = 0 ; $z < $rnd ; $z++) {
	    value_store($fn, $z, 0);
	}
    }
    value_store($fn, $rnd, $val);
}

sub value_store($$$)
{
    my $fn = shift;
    my $rnd = shift;
    my $val = shift;

    my $rnd_val = $rnd . ":" . $val;
    my $ra;
#    print "store: i=[$i] fn[$fn] rnd[$rnd] val[$val] rndval=[$rnd_val]\n";

    if (!value_exists($fn)) {
	$ra = [ ];
#	print "  ** store: create new array ra=$ra\n";
#	print "  ** store: store ref $ra in hash\n";
	$files{$fn} = $ra;
    } else {
	$ra = $files{$fn};
	if (! $ra) {
	    print STDERR "\nINTERNAL ERROR: *** store[$fn rnd=$rnd]: no ref in hash ?????\n";
	    exit(1);
	}
    }
#    print "  store: store idx=$rnd val=$val\n";
#    $ra[$rnd] = $val;
    push (@$ra, $rnd_val);
#    my $idx = 0;
#    foreach my $item (@{$files{$fn}}) {
#	print "  store [$fn]: i=$idx contents=$item\n";
#	$idx += 1;
#    }
}

sub count_nonzero_entries
{
    my ($ofile) = @_;
    my $ra = $files{$ofile};
    if (not $ra) {
	return 0;
    }
    my $num = 0;
    foreach (@$ra) {
	my (undef, $val) = split(':' , $_, 2);
	if ($val) {
	    $num += 1;
	}
    }
    return $num;
}

sub changes_found
{
    my ($ofile) = @_;
    my $ra = $files{$ofile};
    if (not $ra) {
	return 0;
    }
    my $changed = 0;
    my $prev_value;
    foreach (@$ra) {
	my (undef, $value) = split(':' , $_, 2);
	if ($prev_value && $value ne $prev_value) {
	    $changed = 1;
	    last;
	}
	$prev_value = $value;
    }
    return $changed;
}

sub changes_found_ignore_zeroes
{
    my ($ofile) = @_;
    my $ra = $files{$ofile};
    if (not $ra) {
	return 0;
    }
    my $changed = 0;
    my $prev_value;
    foreach (@$ra) {
	my (undef, $value) = split(':' , $_, 2);
	next if not $value;
	if ($prev_value && $value ne $prev_value) {
	    $changed = 1;
	    last;
	}
	$prev_value = $value;
    }
    return $changed;
}

sub value_emit_all_entries($$)
{
    my $ofile = shift;
    my $ra = shift;

    my $num = 0;
    foreach my $item (@$ra) {
	my ($rnd, $val) = split(':' , $item, 2);
#	print "emit: item[$item] rnd=[$rnd] val[$val]\n";
	print $ofile "$rnd, $val\n";
	$num += 1;
    }
    return $num;
}

sub value_emit_nonzero_entries($$)
{
    my $ofile = shift;
    my $ra = shift;

    my $num = 0;
    foreach my $item (@$ra) {
	my ($rnd, $val) = split(':' , $item, 2);
	if ($val) {
	    print $ofile "$rnd, $val\n";
	    $num += 1;
	}
    }
    return $num;
}

sub value_emit($$)
{
    my $fn = shift;
    my $emit_zeroes = shift;
    my $num = 0;

    my $ra = $files{$fn};
    if (! $ra) {
	print "*** emit[$fn]: no ref in hash!?\n";
	return $num;
    }
    my $ofile;
    unless (open ($ofile, "> $fn")) {
	print STDERR "ERROR: unable to create $fn: $!\n";
	exit(1);
    }
    if ($emit_zeroes) {
	$num = value_emit_all_entries($ofile, $ra);
    } else {
	$num = value_emit_nonzero_entries($ofile, $ra);
    }
    close $ofile;
    if (!$num) {
	print "*** emit: file=[$fn] turned out empty, deleting\n";
	unlink($fn);
    }
    return $num;
}

#
# Data for histogram-style graph needs pre-padded zero lines
# or otherwise columns get shifted, (even if entries are numbered!)
# Line-style graphs in turn shows better without zero entries,
# or graphs starting not from start would show
# zero line and then rise to first real sample.
# In cases we re-use same data file for both,
# we delete zero lines for line graph generation
# (which happen come after histogram generation)
#
# with new store & emit technique, (starting in 0.22)
# we always have zero-padded-at-start data files,
# so we need to "clean" them from zeroes
# for cases where this is meaningful: threads

sub delete_zero_lines($)
{
    my $fn = shift;
    my $tmpf = "zeroing-tmp";
    my $sz = 0;

    if(! -s $fn) { 
	print "file $fn is empty zeros-delete!!\n";
	return $sz;
    }
#    printf("zero $fn before:\n==================\n");
#    system("cat $fn");
    rename($fn, $tmpf);
    system("grep -v \', 0\$\' zeroing-tmp > $fn");
#    printf("after:\n==================\n");
#    system("cat $fn");
#    printf("==================\n");
    $sz = -s $fn;
#
# this should not happen if files are generated correctly,
# but watch out anyway since we delete lines
# 
    if(! $sz) { 
	print "file $fn got truncated by zeros-delete!!\n";
    }
    unlink($tmpf);
    return $sz;
}

my @names;

sub split_values($)
{
    my $lin = shift;
    my @values = split(',' , $lin);
    my $vidx = 0;
    %val = ();
    foreach (@names) {
	$val{$_} = $values[$vidx];
#	print "line: assign val[$_]=$values[$vidx]\n";
	$vidx++;
    }
}

sub parse_name_state_block($)
{
    my $handle= shift;
    chop;
    chop;
    @names = split(',' , $_);
    while (<$handle>) {
	chop;
	if ($_ eq "") {
	    last;
	}
	split_values($_);

	my $Name = $val{"Name"};
	my $Pid = $val{"Pid"};
	$Name =~ s/\///g;
	my $pname = $Name . "-" . $Pid;

	###############
	my $param = $val{"nonvoluntary_ctxt_switches"};
	my $nonvol_ctx = 0;
	if ($param_prev_nonvol_ctx{$pname}) {
	    $nonvol_ctx = $param  - $param_prev_nonvol_ctx{$pname};
	}
	$cumul_nonvol_ctx{$pname} += $nonvol_ctx;
	if ($lapsed_time{$i}) {
	    $nonvol_ctx /= $lapsed_time{$i};
	} else {
	    $nonvol_ctx /= $secs_per_round;
	}
	if (defined $param_prev_nonvol_ctx{$pname}) {
	    my $fn = "e/nonvol-ctx-$pname";
	    value_store($fn, $i, $nonvol_ctx);
	}
	$param_prev_nonvol_ctx{$pname} = $param;
	###############
	$param = $val{"voluntary_ctxt_switches"};
	my $vol_ctx = 0;
	if ($param_prev_vol_ctx{$pname}) {
	    $vol_ctx = $param  - $param_prev_vol_ctx{$pname};
	}
	$cumul_vol_ctx{$pname} += $vol_ctx;
	if($lapsed_time{$i}) {
	    $vol_ctx /= $lapsed_time{$i};
	} else {
	    $vol_ctx /= $secs_per_round;
	}
	my $total_ctx = $nonvol_ctx + $vol_ctx;
	if (defined $param_prev_vol_ctx{$pname}) {
	    my $fn = "e/vol-ctx-$pname";
	    value_store($fn, $i, $vol_ctx);
	    $fn = "e/total-ctx-$pname";
	    value_store($fn, $i, $total_ctx);
	}
	$cumul_total_ctx{$pname} += $total_ctx;
	$param_prev_vol_ctx{$pname} = $param;
    }
}

sub parse_shmem_block($)
{
    my $handle= shift;
    my $shared_locked = 0;
    my $shared_unlocked = 0;
    my $a_age_sum = 0;
    my $a_age_cnt = 0;
    my $d_age_sum = 0;
    my $d_age_cnt = 0;
    my $shared_cnt = 0;

    my $line = <$handle>;
    chop $line;
    @names = split(',' , $line);
    while (<$handle>) {
	chop;
	if ($_ eq "") {
	    last;
	}
	$shared_cnt += 1;
	split_values($_);
	my $perms = $val{"perms"};
	my $size = $val{"size"};
	my $lpid = $val{"lpid"};
	my $cpid = $val{"cpid"};
	my $nattach = $val{"nattch"};
	my $atime = $val{"atime"};
	my $dtime = $val{"dtime"};
	#my $ctime = $val{"ctime"};

#	print "use $atime $dtime $ctime $secval\n";
	if (($nattach == 1) && (($lpid == $cpid) && ($dtime == 0))) {
	    my $a_age = $secval{$d} - $atime;
	    $a_age_sum += $a_age;
	    $a_age_cnt += 1;

	    if ($dtime) {
		my $d_age = $secval{$d} - $dtime;
		$d_age_sum += $d_age;
		$d_age_cnt += 1;
	    }
	}

	my $szxx = ($size/1024)/1024;
	$shared_num{$nattach} += 1;
	$shared_size{$nattach} += $szxx;
	$shared_used{$nattach} = 1;
	if($nattach > $max_nattach) {
	    $max_nattach = $nattach;
	}
	if ($nattach == 1) {
	#
        # only one attached process in shared segment, suspicious..
        #
#	    print "$d: 1 nattach, cpid=$cpid lpid=$lpid dtime=$dtime perms=$perms size=$size\n";
	    if (($lpid == $cpid) && ($dtime == 0)) {
		#
		# but it is really orphan only if no other process has attached
		# than creator, so we count those separately as "class zero"
		#
#		print "   *** orphan: dtime=0\n";
		my $xnattach = 0;
		$shared_num{$xnattach} += 1;
		$shared_used{$xnattach} = 1;
	    }
	}
	my $xperms = hex($perms);
	if ($xperms & 0x2000) {
#		    print "$d: xperm=[$xperms] perm=[$perms], locked\n";
	    $shared_locked += $szxx;
	} else {
#		    print "$d: xperm=[$xperms] perm=[$perms], unlocked\n";
	    $shared_unlocked += $szxx;
	}
	$shared_lpid{$lpid} += $szxx;
	$shared_cpid{$cpid} += $szxx;
	# by pid only as here we dont see name, will get re-assigned
	# to name-pid hash at the end of one round
	$shared_lpid_cnt_oneround{$lpid} += 1;
	$shared_cpid_cnt_oneround{$cpid} += 1;
    }
#    if ($a_age_cnt) {
#	$a_age_avg = $a_age_sum / $a_age_cnt;
#	$fn = "e/nattach-a-age-shm";
#	value_store($fn, $i, $a_age_avg);
#    }
#    if ($d_age_cnt) {
#	$d_age_avg = $d_age_sum / $d_age_cnt;
#	$fn = "e/nattach-d-age-shm";
#	value_store($fn, $i, $d_age_avg);
#    }
    value_store_zeropad($shared_locked_plot_file_name, $i, $shared_locked);
    value_store_zeropad($shared_unlocked_plot_file_name, $i, $shared_unlocked);
    value_store_zeropad("e/count-shm", $i, $shared_cnt);
}

sub parse_pid_fd_block($)
{
    my $handle= shift;
    while (<$handle>) {
	chop;
	if ($_ eq "") {
	    last;
	}
	my ($Pid, $FD_count, $cmdline) = split(',' , $_, 3);
	my ($Name, undef) = split(' ' , $cmdline);
	my $last_slash = rindex($Name, '/');
	if ($last_slash > 0) {
	    $Name = substr($Name, $last_slash + 1);
	}
	if ($Name) {
	    my $pname = $Name . "-" . $Pid;
	    $fd_count{$pname} = $FD_count;
	    $fd_count_samples{$pname} += 1;
	    my $fn = "e/fd-$pname";
	    value_store($fn, $i, $FD_count);
	    if ($i > 0) {
		my $fd_diff = $fd_count_prev{$pname} - $FD_count;
		if ($fd_diff < 0) {
		    $fd_diff *= -1;
		}
		$fd_count_diff{$pname} += $fd_diff;
	    }
	    $fd_count_prev{$pname} = $FD_count;
	}
    }
}

# Process status:
# 1,(init),S,0,1,1,0,-1,4194560,26741,567383, ...
# 2,(kthreadd),S,0,0,0,0,-1,2149613632,0,0,0,0,0,0, ...
# ...
sub stat_split
{
    my ($line) = @_;
    my @result;
    my $pid;
    my $name;
    ($pid, $line) = split(',', $line, 2);
    # The 'comm' field may contain ','.
    my $pos = rindex($line, ')');
    return @result if $pos <= 1;
    $name = substr($line, 1, $pos-1);
    $line = substr($line, $pos+2);
    push(@result, $pid, $name, split(',', $line));
    return @result;
}

sub parse_process_status_block($)
{
    my ($handle) = @_;
    my %state_cnt;
    while (<$handle>) {
	chop;
	last if $_ eq '';
	my @entries = stat_split($_);

###########################
	my $Pid = $entries[0];
	my $Name = $entries[1];
	$Name =~ s/\(//g;
	$Name =~ s/\)//g;
	$Name =~ s/\///g;
	my $pname = $Name . "-" . $Pid;

###########################
	my $MajFlt = $entries[11];
	my $major_faults;
	if(!$majflt_prev{$pname}) {
	    $major_faults = 0;
	} else {
	    $major_faults = $MajFlt - $majflt_prev{$pname};
	}
	$majflt_cumul{$pname} += $major_faults;
	if ($lapsed_time{$i}) {
	    $major_faults = $major_faults/$lapsed_time{$i};
	} else {
	    $major_faults = 0;
	}
	if (defined $majflt_prev{$pname}) {
	    value_store("e/majflt-$pname", $i, $major_faults);
	}
	$majflt_prev{$pname} = $MajFlt;

###########################
	my $MinFlt = $entries[9];
	my $minor_faults;
	if(!$minflt_prev{$pname}) {
	    $minor_faults = 0;
	} else {
	    $minor_faults = $MinFlt - $minflt_prev{$pname};
	}
	$minflt_cumul{$pname} += $minor_faults;
	if ($lapsed_time{$i}) {
	    $minor_faults = $minor_faults/$lapsed_time{$i};
	} else {
	    $minor_faults = 0;
	}
	if (defined $minflt_prev{$pname}) {
	    value_store("e/minflt-$pname", $i, $minor_faults);
	}
	$minflt_prev{$pname} = $MinFlt;

###########################
	my $Utime = $entries[13];
	my $utim = 0;
	if($param_prev_utime{$pname}) {
	    $utim = $Utime - $param_prev_utime{$pname};
	}
	$utime_cumul{$pname} += $utim;
	if ($lapsed_time{$i}) {
	    $utim /= $lapsed_time{$i};
	} else {
	    $utim /= $secs_per_round;
	}
	# to make it percent value 0..100%
	$utim *= 100;
	$utim /= $ticks_per_sec;
	if (defined $param_prev_utime{$pname}) {
	    value_store("e/utime-$pname", $i, $utim);
	}
	$param_prev_utime{$pname} = $Utime;

###########################
	my $Stime = $entries[14];
	my $stim = 0;
	if($param_prev_stime{$pname}) {
	    $stim = $Stime - $param_prev_stime{$pname};
	}
	$stime_cumul{$pname} += $stim;
	if ($lapsed_time{$i}) {
	    $stim /= $lapsed_time{$i};
	} else {
	    $stim /= $secs_per_round;
	}
	# to make it percent value 0..100%
	$stim *= 100;
	$stim /= $ticks_per_sec;
	my $ttim = $stim + $utim;
	if (defined $param_prev_stime{$pname}) {
	    value_store("e/stime-$pname", $i, $stim);
	    value_store("e/$pname-totaltime", $i, $ttim);
	}
	$totaltime_cumul{$pname} += $ttim;
	$param_prev_stime{$pname} = $Stime;
###########################
	my $NumThreads = $entries[19];
	value_store_zeropad("e/thr-$pname", $i, $NumThreads);
	if ($NumThreads > 1) {
	    $has_threads{$pname} += $NumThreads;
	    $has_threads_samples{$pname} += 1;
	}
###########################
	my $State = $entries[2];
	$state_cnt{$State}++;
	$process_states_seen{$State} = 1;
    }
    foreach (keys %process_states_seen) {
	my $cnt = 0;
	$cnt = $state_cnt{$_} if $state_cnt{$_};
	value_store_zeropad("e/process-state-count-$_", $i, $cnt);
    }
}

sub parse_xresource_block
{
    my ($handle, $header) = @_;
    chomp $header;
    @names = split(',', $header);

    my %xres_seen = ();
    my $sum_all_pixmaps = 0;
    while (<$handle>) {
	chop;
	if ($_ eq "") {
	    last;
	}
	split_values($_);

	my $Identifier = $val{"Identifier"};
	my $xresPid = $val{"PID"};
	$Identifier =~ s/ /-/g;
	$Identifier =~ s/\>//g;
	$Identifier =~ s/\<//g;
	$Identifier =~ s/\(//g;
	$Identifier =~ s/\)//g;
	$Identifier =~ s/\//-/g;
	$Identifier =~ s/\|/-/g;
	$Identifier =~ s/\&/-/g;

	# Truncate too long names:
	$Identifier = substr($Identifier, 0, 30);

	if($xresPid != -1) {
	    my $name = $name_by_pid{$xresPid};
	    if ($name and $name !~ /$Identifier/i) {
		$Identifier = $name . '-' . $Identifier;
	    }
	    $Identifier = $Identifier . "-" . $xresPid;
	}
	if ($Identifier) {
	    # there are multiple "unknown" ids, make unique by appending hex value,
	    # otherwise they will added up in same line
	    if ($xres_seen{$Identifier}) {
		$Identifier = $Identifier . '-' . $val{"res-base"};
	    }
	    $xres_seen{$Identifier} = 1;
	    $xres_samples{$Identifier} += 1;

	    # The per-atom plotting is disabled for now, as it can easily
	    # generate dozen of graphs that are in most cases not very
	    # interesting.
	    if (0) {
	    foreach my $resource_atom (keys %val) {
		if ($resource_atom eq 'res-base' ||
			$resource_atom eq 'total_resource_count' ||
			$resource_atom eq 'Pixmap mem' ||
			$resource_atom eq 'Misc mem' ||
			$resource_atom eq 'Total mem' ||
			$resource_atom eq 'PID' ||
			$resource_atom eq 'Identifier') {
		    next;
		}
		$resource_atom =~ tr/ /_/;
		my $fn = "e/xres-cnt-$Identifier-${resource_atom}";
		value_store($fn, $i, $val{$resource_atom});
		$xres_atoms_seen{$resource_atom} = 1;
	    }
	    }

	    my $total_cnt;
	    if ($val{"total_resource_count"}) {
		$total_cnt = $val{"total_resource_count"};
	    } else {
		$total_cnt = $val{"Windows"} + $val{"Pixmaps"} + $val{"GCs"} + $val{"Fonts"} +
		    $val{"Cursors"} + $val{"Colormaps"} + $val{"Map entries"} + $val{"Other clients"} + 
		    $val{"Grabs"} + $val{"Pictures"} + $val{"Pictformats"} + $val{"Glyphsets"} + 
		    $val{"CRTCs"} + $val{"Modes"} + $val{"Outputs"} + $val{"Xi clients"} + $val{"Unknown"};
	    }
	    $xresource_latest_cnt{$Identifier} = $total_cnt;
	    my $fn = "e/xres-cnt-$Identifier";
	    value_store($fn, $i, $total_cnt);
	    my $pixmap_mem = $val{"Pixmap mem"};
	    $pixmap_mem =~ s/B//g;
	    $pixmap_mem /= 1024;
	    $xresource_latest_sz_pxm{$Identifier} = $pixmap_mem;
	    $fn = "e/xres-pxm-$Identifier";
	    value_store($fn, $i, $pixmap_mem);
	    $sum_all_pixmaps += $pixmap_mem;
	    $xres_pxm_size_total{$Identifier} += $pixmap_mem;
	}
    }
# system level file has MB units, so we divide it once more
    $sum_all_pixmaps /= 1024;
    value_store($mpixmaps_plot_file_name, $i, $sum_all_pixmaps);
}

sub parse_filesystem_block($)
{
    my $handle= shift;
    while (<$handle>) {
	chop;
	if ($_ eq "") {
	    last;
	}
	process_df_entry(split(',' , $_, 6));
    }
}

sub parse_memtotal_block($)
{
    my $handle= shift;
    chop;
    @names = split(',' , $_);

    my $line = <$handle>;
    $line =~ s/kB//g;
    chop $line;
    split_values($line);

    my $mfree = $val{"MemFree"} /1024 ;
    value_store($memfree_plot_file_name, $i, $mfree);
    my $cached = $val{"Cached"} /1024;
    value_store($cached_plot_file_name, $i, $cached);
    my $swapcached = $val{"SwapCached"} / 1024;
    value_store($swapcached_plot_file_name, $i, $swapcached);

    my $swaptotal = $val{"SwapTotal"} / 1024;
    my $swapfree = $val{"SwapFree"} / 1024;
    my $swapused = $swaptotal - $swapfree;
    value_store($swapused_plot_file_name, $round, $swapused);
    $swapused_total += $swapused;

    my $buffers = $val{"Buffers"} / 1024;
    value_store($buffers_plot_file_name, $i, $buffers);
    my $dirty = $val{"Dirty"} / 1024;
    value_store($dirty_plot_file_name, $i, $dirty);
    my $active_file = $val{"Active(file)"} / 1024;
    value_store($active_file_plot_file_name, $i, $active_file);
    my $inactive_file = $val{"Inactive(file)"} / 1024;
    value_store($inactive_file_plot_file_name, $i, $inactive_file);
    my $active_anon = $val{"Active(anon)"} / 1024;
    value_store($active_anon_plot_file_name, $i, $active_anon);
    my $inactive_anon = $val{"Inactive(anon)"} / 1024;
    value_store($inactive_anon_plot_file_name, $i, $inactive_anon);
    my $mlocked = $val{"Mlocked"} / 1024;
    value_store($mlocked_plot_file_name, $i, $mlocked);
#
# for some reason, (kernel bug?) mlocked gets less
# every few rounds sometimes, until wraps under zero
# and shows as awfully large value then..
# avoid it here and cut to zero as it spoils graph scale
# Note, this is true for Fremantle, and not seen yet on Harmattan
#
    if($mlocked >  1024) {
	$mlocked = 0;
    }
    my $pagetables = $val{"PageTables"} / 1024;
    value_store($pagetables_plot_file_name, $round, $pagetables);
    my $kernelstack = $val{"KernelStack"} / 1024;
    value_store($kernelstack_plot_file_name, $i, $kernelstack);
    my $shmem = $val{"Shmem"} / 1024;
    value_store($shmem_plot_file_name, $i, $shmem);
}

sub parse_pages_block($)
{
    my $handle= shift;
    chop;
    chop;
    @names = split(',' , $_);

    my $line = <$handle>;
    chop $line;
    split_values($line);

    my $pslabreclaim = $val{"nr_slab_reclaimable"};
    my $pslabunreclaim = $val{"nr_slab_unreclaimable"};
    my $pswp_in_cumul = $val{"pswpin"};
    my $pswp_out_cumul = $val{"pswpout"};
    my $pgscan_kswapd_normal_cumul = $val{"pgscan_kswapd_normal"};
    my $pgscan_direct_normal_cumul = $val{"pgscan_direct_normal"};
    my $slabs_scanned_cumul = $val{"slabs_scanned"};
    my $kswapd_steal_cumul = $val{"kswapd_steal"};
    
    my $slabreclaim = ($pslabreclaim * $page_size)/1024;
    value_store($slabreclaim_plot_file_name, $i, $slabreclaim);
    my $slabunreclaim = ($pslabunreclaim * $page_size)/1024;
    value_store($slabunreclaim_plot_file_name, $i, $slabunreclaim);

    my $divider;
    if ($lapsed_time{$i}) {
	$divider = $lapsed_time{$i};
    } else {
	$divider = $secs_per_round;
    }

    if ($pswp_in_prev) {
	my $pswp_in = ($pswp_in_cumul - $pswp_in_prev)/$divider;
	value_store_zeropad($pswp_in_plot_file_name, $i, $pswp_in);
    }
    $pswp_in_prev = $pswp_in_cumul;

    my $pswp_out = 0;
    if ($pswp_out_prev) {
	$pswp_out = ($pswp_out_cumul - $pswp_out_prev)/$divider;
	value_store_zeropad($pswp_out_plot_file_name, $i, $pswp_out);
    }
    $pswp_out_prev = $pswp_out_cumul;
    $swap_pgout_total += $pswp_out;

    if ($pgscan_kswapd_normal_prev) {
	my $pgscan_kswapd_normal = ($pgscan_kswapd_normal_cumul - $pgscan_kswapd_normal_prev)/$divider;
	value_store_zeropad($pgscan_kswapd_normal_plot_file_name, $i, $pgscan_kswapd_normal);
    }
    $pgscan_kswapd_normal_prev = $pgscan_kswapd_normal_cumul;

    if ($pgscan_direct_normal_prev) {
	my $pgscan_direct_normal = ($pgscan_direct_normal_cumul - $pgscan_direct_normal_prev)/$divider;
	value_store_zeropad($pgscan_direct_normal_plot_file_name, $i, $pgscan_direct_normal);
    }
    $pgscan_direct_normal_prev = $pgscan_direct_normal_cumul;
    
    if ($slabs_scanned_prev) {
	my $slabs_scanned = ($slabs_scanned_cumul - $slabs_scanned_prev)/$divider;
	value_store_zeropad($slabs_scanned_plot_file_name, $i, $slabs_scanned);
    }
    $slabs_scanned_prev = $slabs_scanned_cumul;

    if ($kswapd_steal_prev) {
	my $kswapd_steal = ($kswapd_steal_cumul - $kswapd_steal_prev)/$divider;
	value_store_zeropad($kswapd_steal_plot_file_name, $i, $kswapd_steal);
    }
    $kswapd_steal_prev = $kswapd_steal_cumul;
}

sub parse_wchan_block
{
    my ($handle) = @_;
    my %wchan_count;
    while (<$handle>) {
	last if $_ eq '';
	my ($pid, $wchan) = split(',', $_, 2);
	chomp $wchan;
	next if $wchan eq '';
	$wchan_count{$wchan}++;
	$wchan_seen{$wchan}++;
    }
    foreach (keys %wchan_seen) {
	my $cnt = 0;
	$cnt = $wchan_count{$_} if $wchan_count{$_};
	value_store_zeropad("e/wchan-$_", $i, $cnt);
    }
}

sub process_wchan
{
    return unless open(WCHAN, $d . '/wchan');
    my %wchan_count;
    while (<WCHAN>) {
	if (m#^==> /proc/(\d+)/wchan <==#) {
	    my $wchan = <WCHAN>;
	    chomp $wchan;
	    $wchan_count{$wchan}++;
	    $wchan_seen{$wchan}++;
	}
    }
    close(WCHAN);
    foreach (keys %wchan_seen) {
	my $cnt = 0;
	$cnt = $wchan_count{$_} if $wchan_count{$_};
	value_store_zeropad("e/wchan-$_", $i, $cnt);
    }
}

sub process_xmeminfo
{
    my $fn = "$d/xmeminfo";
    my $xmeminfo;
    if (not open($xmeminfo, $fn)) {
	return;
    }
    my $header = <$xmeminfo>;
    if ($header =~ m#^res-base,#) {
	parse_xresource_block($xmeminfo, $header);
    } else {
	print STDERR "WARNING: unable to parse '$fn': invalid header '$header'.\n";
    }
    close($xmeminfo);
}

sub process_df_entry
{
    my ($filesystem, $blocks_kb, $used_kb, $available, $capacity, $mounted_on) = @_;
    #print STDERR "Mounted on: $mounted_on, capacity: $capacity\n";
    return if not $mounted_on;
    my $mangled = $mounted_on;
    $mangled =~ s/\//\_/g;
    $filesystem_to_mountpoint{$filesystem} = $mounted_on;
    $filesystem_names{$mangled} = $used_kb;
    $filesystem_demangle{$mangled} = $mounted_on;
    my $fn = "e/fs-used-${mangled}";
    chop $capacity;
    value_store($fn, $i, $capacity);
}

sub process_df
{
    my $fn = "$d/df";
    if (not open(DF, $fn)) {
	return;
    }
    my $header = <DF>;
    if ($header =~ m/^Filesystem/) {
	while (<DF>) {
	    chomp;
	    process_df_entry(split(' ', $_, 6));
	}
    } else {
	print STDERR "WARNING: unable to parse '$fn': invalid header '$header'.\n";
    }
    close(DF);
}

sub process_slabinfo()
{
    my $fn = "$d/slabinfo";
    unless (open(SLABINFO, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<SLABINFO>) {
	my $idx_1 = index($_, "slabinfo");
	my $idx_2 = index($_, "# name");
	if (($idx_1 != -1) || ($idx_2 != -1)) {
	    next;
	}
	chop;
	my ($slabname, $active_objs, $num_objs, $obj_size,
	 undef, undef, undef, undef, undef, 
	 undef, undef, undef, undef, undef, undef, undef) = split(' ' , $_, 16);

	$slabname =~ s/ //g;
	$slabname =~ s/\>//g;
	$slabname =~ s/\<//g;
	$slabname =~ s/\(//g;
	$slabname =~ s/\)//g;
	$slabname =~ s/\//-/g;
	$slabname =~ s/\|/-/g;

	my $slab_sz = ($active_objs * $obj_size)/1024;
	$fn = "e/slabs-$slabname";
	value_store($fn, $i, $slab_sz);
	$all_slabs{$slabname} += $active_objs;
    }
    close(SLABINFO);
}

#/proc/12/fd/:
#total 0
#
#/proc/1205/fd/:
#total 0
#lrwx------    1 user     users           64 Feb  4 01:57 0 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 1 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 2 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 3 -> socket:[9304]
#lrwx------    1 user     users           64 Feb  4 01:57 4 -> socket:[9307]
#
#/proc/1213/fd/:
#total 0
#lrwx------    1 user     users           64 Feb  4 01:57 0 -> /dev/console
#lrwx------    1 user     users           64 Feb  4 01:57 1 -> /dev/console
#lr-x------    1 user     users           64 Feb  4 01:57 10 -> inotify
#lr-x------    1 user     users           64 Feb  4 01:57 12 -> inotify
#lr-x------    1 user     users           64 Feb  4 01:57 13 -> pipe:[9718]
#l-wx------    1 user     users           64 Feb  4 01:57 14 -> pipe:[9718]
#lr-x------    1 user     users           64 Feb  4 01:57 15 -> pipe:[9719]
#l-wx------    1 user     users           64 Feb  4 01:57 16 -> pipe:[9719]
#lrwx------    1 user     users           64 Feb  4 01:57 17 -> socket:[9735]
#lr-x------    1 user     users           64 Feb  4 01:57 18 -> pipe:[9740]
#l-wx------    1 user     users           64 Feb  4 01:57 19 -> pipe:[9740]
#lrwx------    1 user     users           64 Feb  4 01:57 2 -> /dev/console
sub process_openfds()
{
    my $fn = compression_check("$d/open-fds");
    if (not open(OPENFDS, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my $pid;
    while (<OPENFDS>) {
	if (m#/proc/(\d+)/fd/:#) {
	    if ($pid) {
		value_store("e/fd_inotify-$name_by_pid{$pid}-$pid",   $i, $fd_inotify{$pid});
		value_store("e/fd_pipe-$name_by_pid{$pid}-$pid",      $i, $fd_pipe{$pid});
		value_store("e/fd_socket-$name_by_pid{$pid}-$pid",    $i, $fd_socket{$pid});
		value_store("e/fd_tmpfs-$name_by_pid{$pid}-$pid",     $i, $fd_tmpfs{$pid});
		value_store("e/fd_eventfd-$name_by_pid{$pid}-$pid",   $i, $fd_eventfd{$pid});
		value_store("e/fd_epoll-$name_by_pid{$pid}-$pid",     $i, $fd_epoll{$pid});
		value_store("e/fd_signalfd-$name_by_pid{$pid}-$pid",  $i, $fd_signalfd{$pid});
		value_store("e/fd_timerfd-$name_by_pid{$pid}-$pid",   $i, $fd_timerfd{$pid});
		value_store("e/fd_disk-$name_by_pid{$pid}-$pid",      $i, $fd_disk{$pid});
	    }
	    $pid = $1;
	    $fd_samples{$pid} += 1;
	    $fd_inotify{$pid} = 0;
	    $fd_pipe{$pid} = 0;
	    $fd_socket{$pid} = 0;
	    $fd_tmpfs{$pid} = 0;
	    $fd_eventfd{$pid} = 0;
	    $fd_epoll{$pid} = 0;
	    $fd_signalfd{$pid} = 0;
	    $fd_timerfd{$pid} = 0;
	    $fd_disk{$pid} = 0;
	} elsif (m#^.[rwx-]{9}\s+\d+\s+(\S+)\s+\S+\s+.*\d+ -> (\S+)#) {
	    my $username = $1;
	    my $target = $2;
	    if ($target eq 'inotify' or $target eq 'anon_inode:inotify') {
		$fd_inotify{$pid} += 1;
	    } elsif ($target =~ m/^pipe:\[\d+\]$/) {
		$fd_pipe{$pid} += 1;
	    } elsif ($target =~ m/^socket:\[\d+\]$/) {
		$fd_socket{$pid} += 1;
	    } elsif ($target =~ m#^/dev/# or
	             $target =~ m#^/sys/# or
	             $target =~ m#^/syspart/# or
	             $target =~ m#^/proc/# or
	             $target =~ m#^/tmp/# or
	             $target =~ m#^/var/run/#) {
		$fd_tmpfs{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[eventfd]') {
		$fd_eventfd{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[eventpoll]') {
		$fd_epoll{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[signalfd]') {
		$fd_signalfd{$pid} += 1;
	    } elsif ($target eq 'anon_inode:[timerfd]') {
		$fd_timerfd{$pid} += 1;
	    } elsif ($target =~ m#^/#) {
		$fd_disk{$pid} += 1;
	    } else {
		#print STDERR "UNCLASSIFIED open-fds entry: $_";
	    }
	}
    }
    close(OPENFDS);
}

# Sanitize the Control Group name so that we can use it as a file name:
# "/system/applications/standby/" -> "_system_applications_standby_"
sub sanitize_cgroup_name
{
    my ($name) = @_;
    $name =~ tr#/#_#;
    if ($name eq "") {
	$name = 'root';
    }
    return $name;
}

sub process_cgroups()
{
    my $fn = "$d/cgroups";
    if (not open(CGROUPS, $fn)) {
	return;
    }
    while (<CGROUPS>) {
	my $cgroup_name_orig;
	my $cgroup_name_mangled;
	if (m#^==> /syspart(\S*/)memory\.memsw\.usage_in_bytes <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $memsw_usage = int(<CGROUPS>) / (1024*1024);
	    value_store_zeropad("e/cgroup-${cgroup_name_mangled}-memsw", $i, $memsw_usage);
	} elsif (m#^==> /syspart(\S*/)memory\.usage_in_bytes <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $mem_usage = int(<CGROUPS>) / (1024*1024);
	    value_store_zeropad("e/cgroup-${cgroup_name_mangled}-mem", $i, $mem_usage);
	} elsif (m#^==> /syspart(\S*/)memory\.limit_in_bytes <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $mem_limit = int(<CGROUPS>);
	    if ($mem_limit != 9223372036854775807) {
		$mem_limit /= (1024*1024);
		value_store_zeropad("e/cgroup-${cgroup_name_mangled}-memlimit", $i, $mem_limit);
	    }
	} elsif (m#^==> /syspart(\S*/)memory\.stat <==#) {
	    # ==> /syspart/system/desktop/memory.stat <==
	    # cache 49410048
	    # rss 68714496
	    # mapped_file 45260800
	    # pgpgin 465491
	    # pgpgout 436652
	    # swap 17645568
	    # inactive_anon 57729024
	    # active_anon 11051008
	    # inactive_file 2899968
	    # active_file 46440448
	    # unevictable 4096
	    # hierarchical_memory_limit 157286400
	    # hierarchical_memsw_limit 9223372036854775807
	    # total_cache 49410048
	    # total_rss 68714496
	    # total_mapped_file 45260800
	    # total_pgpgin 465491
	    # total_pgpgout 436652
	    # total_swap 17645568
	    # total_inactive_anon 57729024
	    # total_active_anon 11051008
	    # total_inactive_file 2899968
	    # total_active_file 46440448
	    # total_unevictable 4096
	    #
	    # ==> ...
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my %stat;
	    while (<CGROUPS> =~ m#^([a-z_]+) (\d+)$#) {
		my ($key, $val) = ($1, $2);
		$stat{$key} = int($val);
	    }
	    # pgpgin and pgpgout are event counts, so collect differences
	    # between rounds:
	    if (exists $prev_cgroups_stats{$cgroup_name_mangled}) {
		my %prev_stat = %{$prev_cgroups_stats{$cgroup_name_mangled}};
		foreach (qw/pgpgin pgpgout/) {
		    my $val_now = $stat{$_};
		    my $val_prev = $prev_stat{$_};
		    my $val = $val_now - $val_prev;
		    $val = 0 if ($val < 0);
		    value_store("e/cgroup-${cgroup_name_mangled}-$_", $i, $val);
		}
	    }
	    $prev_cgroups_stats{$cgroup_name_mangled} = \%stat;
	    foreach (qw/cache rss mapped_file swap inactive_anon
			active_anon inactive_file active_file unevictable/) {
		value_store_zeropad("e/cgroup-${cgroup_name_mangled}-$_", $i,
		    $stat{$_} / (1024*1024));
	    }
	} elsif (m#^==> /syspart(\S*/)cgroup\.procs <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $procs_count = 0;
	    while (<CGROUPS> =~ m#^\d+$#) {
		$procs_count++;
	    }
	    value_store_zeropad("e/cgroup-${cgroup_name_mangled}-process-cnt", $i, $procs_count);
	} elsif (m#^==> /syspart(\S*/)tasks <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $task_count = 0;
	    while (<CGROUPS> =~ m#^\d+$#) {
		$task_count++;
	    }
	    value_store_zeropad("e/cgroup-${cgroup_name_mangled}-task-cnt", $i, $task_count);
	} elsif (m#^==> /syspart(\S*/)memory\.failcnt <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $failcnt = int(<CGROUPS>);
	    if (exists $prev_cgroups_mem_failcnt{$cgroup_name_mangled}) {
		my $failcnt_prev = $prev_cgroups_mem_failcnt{$cgroup_name_mangled};
		my $val = $failcnt - $failcnt_prev;
		$val = 0 if ($val < 0);
		value_store("e/cgroup-${cgroup_name_mangled}-mem-failcnt", $i, $val);
	    }
	    $prev_cgroups_mem_failcnt{$cgroup_name_mangled} = $failcnt;
	} elsif (m#^==> /syspart(\S*/)memory\.memsw\.failcnt <==#) {
	    $cgroup_name_orig = $1;
	    $cgroup_name_mangled = sanitize_cgroup_name($cgroup_name_orig);
	    my $failcnt = int(<CGROUPS>);
	    if (exists $prev_cgroups_memsw_failcnt{$cgroup_name_mangled}) {
		my $failcnt_prev = $prev_cgroups_memsw_failcnt{$cgroup_name_mangled};
		my $val = $failcnt - $failcnt_prev;
		$val = 0 if ($val < 0);
		value_store("e/cgroup-${cgroup_name_mangled}-memsw-failcnt", $i, $val);
	    }
	    $prev_cgroups_memsw_failcnt{$cgroup_name_mangled} = $failcnt;
	}
	if ($cgroup_name_mangled) {
	    $cgroups{$cgroup_name_mangled} = 1;
	    $cgroups_demangle{$cgroup_name_mangled} = $cgroup_name_orig;
	}
    }
    close(CGROUPS);
}

sub process_ifconfig()
{
    my $fn = "$d/ifconfig";
    if (not open(IFCONFIG, $fn)) {
	return;
    }
    while (<IFCONFIG>) {
	if (m/^[^ ]/) {
	    my ($interface, undef) = split(' ', $_, 2);
	    if ($interface eq '') {
		next;
	    }
	    $interface =~ tr/:/_/;
	    $interfaces_seen{$interface} = 1;
	    while (<IFCONFIG>) {
		if ($_ eq "\n") {
		    last;
		}
		my $value;
		if (m/RX packets:([0-9]+)/) {
		    my $rx = int($1);
		    if (defined $interfaces_prev_rx_packets{$interface}) {
			my $prev_rx = $interfaces_prev_rx_packets{$interface};
			if ($prev_rx <= $rx) {
			    $value = $rx - $prev_rx;
			} else {
			    $value = $rx;
			}
			value_store("e/iface-$interface-rx-packets", $i, $value);
		    }
		    $interfaces_prev_rx_packets{$interface} = $rx;
		} elsif (m/TX packets:([0-9]+)/) {
		    my $tx = int($1);
		    if (defined $interfaces_prev_tx_packets{$interface}) {
			my $prev_tx = $interfaces_prev_tx_packets{$interface};
			if ($prev_tx <= $tx) {
			    $value = $tx - $prev_tx;
			} else {
			    $value = $tx;
			}
			value_store("e/iface-$interface-tx-packets", $i, $value);
		    }
		    $interfaces_prev_tx_packets{$interface} = $tx;
		} elsif (m/RX bytes:([0-9]+).*TX bytes:([0-9]+)/) {
		    my $rx = int($1) / 1024;
		    my $tx = int($2) / 1024;
		    if (defined $interfaces_prev_rx_kB{$interface}) {
			my $prev_rx = $interfaces_prev_rx_kB{$interface};
			if ($prev_rx <= $rx) {
			    $value = $rx - $prev_rx;
			} else {
			    $value = $rx;
			}
			value_store("e/iface-$interface-rx-kB", $i, $value);
			my $prev_tx = $interfaces_prev_tx_kB{$interface};
			if ($prev_tx <= $tx) {
			    $value = $tx - $prev_tx;
			} else {
			    $value = $tx;
			}
			value_store("e/iface-$interface-tx-kB", $i, $value);
		    }
		    $interfaces_prev_rx_kB{$interface} = $rx;
		    $interfaces_prev_tx_kB{$interface} = $tx;
		}
	    }
	}
    }
    close(IFCONFIG);
}

sub process_smaps()
{
    my $heap = 0;
    my $nm;
    my $fn = compression_check("$d/smaps.cap");
    unless (open(SMAPS_CAP, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my %process_devpvr_count;
    my $sum_app_swapped = 0;
#    $sum_app_private_dirty = 0;
    my $sum_app_pss = 0;
    %app_swapped = ();
#    %app_private_dirty = ();
    %app_pss = ();
    %app_sysv_shared = ();
    %app_posix_shared = ();
    %app_rwxp = ();
    %app_dev_pvr = ();
    %vma_count = ();
    while (<SMAPS_CAP>) {
	if (m#^[A-Z]#) {
	    if( index($_, "Pss:") != -1) {
		my $pss = int(substr($_, 4, -4));
		$sum_app_pss += $pss;
		$app_pss{$nm} += $pss;
		$vma_count{$nm} += 1;
		next;
	    }
#	    if( index($_, "Private_Dirty:") != -1) {
#		my $pdirty = int(substr($_, 14, -4));
#		$sum_app_private_dirty += $pdirty;
#		$app_private_dirty{$nm} += $pdirty;
#		next;
#	    }
	    if( index($_, "Swap:") != -1) {
		my $swapped = int(substr($_, 5, -4));
		$sum_app_swapped += $swapped;
		$app_swapped{$nm} += $swapped;
		next;
	    }
	} elsif (m/^#/) {
	    if( index($_, "#Name: ") != -1) {
		chop;
		#
		# before taking new name into $nm, store
		# heap for previous.
		# This is because heap comes in multiple segments
		#
		$avg_heap{$nm} = ($avg_heap{$nm} * $i + $heap)/($i+1);
		my $dev = ($avg_heap{$nm} - $heap);
		if ($dev < 0) {
		    $dev = -1 * $dev;
		}
		$sumdev_heap{$nm} += $dev;
		$devcount_heap{$nm} += 1;
		if (not defined $max_heap{$nm}) {
		    $max_heap{$nm} = $heap;
		} else {
		    $max_heap{$nm} = max $heap, $max_heap{$nm};
		}
		$fn = "e/heap-$nm";
		$sum_heap{$nm} += $heap;
		$num_heap_samples{$nm} += 1;
		my $xxx = $heap / 1024;
		value_store_zeropad($fn, $i, $xxx);
		$heap = 0;

		###### now start with new name
		(undef, $nm) = split(' ' , $_, 2);

		# some are really long names (hald-bla-bla 384 chars)
		my $sz = length $nm;
		if($sz > 64) {
		    $nm = substr($nm, 0, 64);
		}
		$nm =~ s/\(//g;
		$nm =~ s/\)//g;
		$nm =~ s/\///g;
		next;
	    }
	    if( index($_, "#Pid: ") != -1) {
		chop;
		my (undef, $s_pid) = split(' ' , $_, 2);
		$name_by_pid{$s_pid} = $nm;
		$nm = $nm . "-" . $s_pid;
		$app_swapped{$nm} = 0;
#		$app_private_dirty{$nm} = 0;
		$app_pss{$nm} = 0;
		# create mapping from pid to name-pid
		$pid_by_namepid{$nm} = $s_pid;
		$all_apps{$nm} = 1;
		next;
	    }
	    if( index($_, "#VmLck: ") != -1) {
		chop;
		my (undef, $locked) = split(' ' , $_, 2);
		$fn = "e/locked-$nm";
		$app_sum_locked{$nm} += $locked;
		my $xxx = $locked / 1024;
		value_store_zeropad($fn, $i, $xxx);
		next;
	    }
	    if( index($_, "#VmSize: ") != -1) {
		chop;
		my (undef, $vmsz) = split(' ' , $_, 2);
		$fn = "e/vmsz-$nm";
		$app_sum_vmsz{$nm} += $vmsz;
		my $xxx = $vmsz / 1024;
		value_store_zeropad($fn, $i, $xxx);
		if ($prev_vmsize{$nm} && ($prev_vmsize{$nm} != $vmsz)) {
		    $changed_vmsize{$nm} = 1;
		}
		$prev_vmsize{$nm} = $vmsz;
		next;
	    }
	} else {
	    if( index($_, "[heap]") != -1) {
		my $line = <SMAPS_CAP>;
		chop $line;
		my (undef, $xheap, undef) = split(' ' , $line, 3);
		$heap += $xheap;
		# will register this value before new $nm is set
		next;
	    }
	    if( index($_, "/dev/shm/") != -1) {
		my $line = <SMAPS_CAP>;
		chop $line;
		my (undef, $posix_shared, undef) = split(' ' , $line, 3);
		$app_posix_shared{$nm} += $posix_shared;
		next;
	    }
	    if( index($_, "/dev/pvrsrvkm") != -1) {
		my $line = <SMAPS_CAP>;
		chop $line;
		my (undef, $pvr, undef) = split(' ' , $line, 3);
		$app_dev_pvr{$nm} += $pvr;
		$process_devpvr_count{$nm}++;
		next;
	    }
	    if( index($_, " rwxp ") != -1) {
		my $line = <SMAPS_CAP>;
		chop $line;
		my (undef, $sz_wx, undef) = split(' ' , $line, 3);
		$app_rwxp{$nm} += $sz_wx;
		next;
	    }
	    if( m#/SYSV[0-9a-f]{8,}# ) {
		my $line = <SMAPS_CAP>;
		chop $line;
		my (undef, $sysv_shared, undef) = split(' ' , $line, 3);
		$app_sysv_shared{$nm} += $sysv_shared;
		next;
	    }
	}
    }
    close(SMAPS_CAP);
    foreach (keys %process_devpvr_count) {
	value_store("e/devpvr-count-$_", $i, $process_devpvr_count{$_});
    }
    $sum_app_swapped /= 1024;
    $sum_app_pss /= 1024;
#    $sum_app_private_dirty /= 1024;
    value_store($app_swapped_plot_file_name, $i, $sum_app_swapped);
    value_store($app_pss_plot_file_name, $i, $sum_app_pss);
}

sub process_interrupts()
{
    my $all_ints = 0;

    my $fn = $d . "/interrupts";
    unless (open(INTERRUPTS, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<INTERRUPTS>) {
	chop;
	my ($int_num, $int_cnt, undef, $int_name1, $int_name2, $int_name3, $int_name4) = split(' ' , $_);
	chop $int_num;
	my $iname = $int_num . '-' . $int_name1 . $int_name2 . $int_name3 . $int_name4;
	
	my $ints = 0;
	if (!$int_prev{$iname} or !$lapsed_time{$i}) {
	    $ints = 0;
	} else {
	    $ints = ($int_cnt - $int_prev{$iname})/$lapsed_time{$i};
	}
	$int_prev{$iname} = $int_cnt;
	$int_total{$iname} += $ints;
	$all_ints += $ints;
	$fn = "e/int-$iname";
	value_store($fn, $i, $ints);
#	print "$i: ints-per-sec=$ints int_cnt=$int_cnt num=[$int_num] name=[$iname] nm=[$int_name1] nm2=[$int_name2] nm3=[$int_name3] nm4=[$int_name4]\n";
    }
    close(INTERRUPTS);
    value_store("e/count-int", $i, $all_ints);
}

sub process_diskstats()
{
    my $fn = $d . "/diskstats";
    if (! -e $fn) {
        # this is optional as it was added later to snapshots.
	return;
    }
    unless (open(DISKSTATS, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    while (<DISKSTATS>) {
	chop;
	my ($majdev, $mindev, $dname,
	 $xdev_reads, $xdev_reads_merged, $xsector_reads, $xmsec_reading, $xdev_writes, $dxev_writes_merged,
	 $xsector_writes, $xmsec_writing, $xios_in_progress, $xmsec_in_io, $xmsec_weighted_in_io) = split(' ' , $_, 14);
	if (($xdev_reads + $xdev_writes) == 0) {
	    next;
	}
	
	my $nreads = 0;
	my $reads = 0;
	if ($dev_reads_prev{$dname} and $lapsed_time{$i}) {
#	    $reads = ($xdev_reads - $dev_reads_prev{$dname})/$lapsed_time{$i};
	    $nreads = $xsector_reads - $dev_reads_prev{$dname};
	    $reads = ((($nreads * $sector_sz)/($MB_bytes)))/$lapsed_time{$i};
	    value_store("e/devreads-mb-$dname", $i,
		($nreads * $sector_sz) / $MB_bytes);
	}
#	$dev_reads_prev{$dname} = $xdev_reads;
	$dev_reads_prev{$dname} = $xsector_reads;
	$dev_reads_total{$dname} += $reads;
	$fn = "e/devreads-$dname";
	value_store($fn, $i, $reads);

	my $nwrites = 0;
	my $writes = 0;
	if ($dev_writes_prev{$dname} and $lapsed_time{$i}) {
#	    $writes = ($xdev_writes - $dev_writes_prev{$dname})/$lapsed_time{$i};
	    $nwrites = $xsector_writes - $dev_writes_prev{$dname};
	    $writes = ((($nwrites * $sector_sz)/($MB_bytes)))/$lapsed_time{$i};
	    value_store("e/devwrites-mb-$dname", $i,
		($nwrites * $sector_sz) / $MB_bytes);
	}
#	$dev_writes_prev{$dname} = $xdev_writes;
	$dev_writes_prev{$dname} = $xsector_writes;
	$dev_writes_total{$dname} += $writes;
	$fn = "e/devwrites-$dname";
	value_store($fn, $i, $writes);

	my $time_per_read = 0;
	if ($dev_time_per_read_prev{$dname}) {
	    if ($nreads) {
		$time_per_read = ($xmsec_reading - $dev_time_per_read_prev{$dname})/$nreads;
	    }
	}
	$dev_time_per_read_prev{$dname} = $xmsec_reading;
	$fn = "e/devreadtime-$dname";
	value_store($fn, $i, $time_per_read);

	my $time_per_write = 0;
	if ($dev_time_per_write_prev{$dname}) {
	    if ($nwrites) {
		$time_per_write = ($xmsec_writing - $dev_time_per_write_prev{$dname})/$nwrites;
	    }
	}
	$dev_time_per_write_prev{$dname} = $xmsec_writing;
	$fn = "e/devwritetime-$dname";
	value_store($fn, $i, $time_per_write);
	$have_diskstats = 1;
    }
    close(DISKSTATS);
}

sub process_bme()
{
    my $fn = $d . "/bmestat";
    if (! -e $fn) {
        # as this is new (added in sp-endurance 2.2.1+0m6 in 2011w9), 
	# it may be missing in snapshots, just return silently if not there
	return;
    }
    unless (open(BMESTAT, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    $have_bme = 1;
    while (<BMESTAT>) {
	if (m/battery pct. level:/) {
	    my (undef, undef, undef, $batt_lev) = split(' ' , $_, 4);
	    chop $batt_lev;
	    value_store($batt_charge_left_file_name, $i, $batt_lev);
	} 
	elsif (m/battery cur. voltage:/) {
	    my (undef, undef, undef, $volt) = split(' ' , $_, 4);
	    chop $volt;
	    value_store($batt_voltage_file_name, $i, $volt);
	}
	elsif (m/battery temperature:/) {
	    my (undef, undef, $batt_temp) = split(' ' , $_, 3);
	    chop $batt_temp;
	    value_store($batt_temperature_file_name, $i, $batt_temp);
	}
    }
    close(BMESTAT);
}


sub process_ramzswap()
{
    my $fn = $d . "/ramzswap";
    if (! -e $fn) {
        # as this is optional, may be missing in snapshots.
	return;
    }
    unless (open(RAMZSWAP, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my $divider;
    if ($lapsed_time{$i}) {
	$divider = $lapsed_time{$i};
    } else {
	$divider = $secs_per_round;
    }
    while (<RAMZSWAP>) {
	if (m/BDevNumReads:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_bdreads = 0;
	    if ($prev_ramzswap_bdreads) {
		$n_bdreads = ($param  - $prev_ramzswap_bdreads)/$divider;
	    }
	    value_store($ramzswap_bdreads_file_name, $i, $n_bdreads);
	    $prev_ramzswap_bdreads = $param;
	} elsif (m/NumReads:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_reads = 0;
	    if ($prev_ramzswap_reads) {
		$n_reads = ($param  - $prev_ramzswap_reads)/$divider;
	    }
	    value_store($ramzswap_reads_file_name, $i, $n_reads);
	    $prev_ramzswap_reads = $param;
	} elsif (m/BDevNumWrites:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_bdwrites = 0;
	    if ($prev_ramzswap_bdwrites) {
		$n_bdwrites = ($param  - $prev_ramzswap_bdwrites)/$divider;
	    }
	    value_store($ramzswap_bdwrites_file_name, $i, $n_bdwrites);
	    $prev_ramzswap_bdwrites = $param;
	} elsif (m/NumWrites:/) {
	    my (undef, $param) = split(' ' , $_, 2);
	    my $n_writes = 0;
	    if ($prev_ramzswap_writes) {
		$n_writes = ($param  - $prev_ramzswap_writes)/$divider;
	    }
	    value_store($ramzswap_writes_file_name, $i, $n_writes);
	    $prev_ramzswap_writes = $param;
	} elsif (m/ZeroPages:/) {
	    my (undef, $zerop) = split(' ' , $_, 2);
	    my $zerom = ($zerop * $page_size)/1024;
	    value_store($ramzswap_zerop_file_name, $i, $zerom);
	} elsif (m/PagesUsed:/) {
	    my (undef, $n_usedp) = split(' ' , $_, 2);
	    my $used = ($n_usedp * $page_size)/1024;
	    value_store($ramzswap_used_file_name, $i, $used);
	    $have_ramzswap = 1;
	}
    }
    close(RAMZSWAP);
}


sub process_stat()
{
    my $ctx;
    my %cpu_ticks;
    my $processes;
    my $fn = $d . "/stat";
    open(STAT, $fn);
    while (<STAT>) {
	chop;
	if( m/ctxt /) {
	    (undef, $ctx) = split(' ' , $_, 2);

	    my $global_ctx = 0;
	    if (!$global_ctx_prev) {
		$global_ctx = 0;
	    } elsif (($ctx - $global_ctx_prev) < 0) {
		$global_ctx = 0;
	    } elsif (!$lapsed_time{$i}) {
		$global_ctx = 0;
	    } else {
		$global_ctx = ($ctx - $global_ctx_prev)/$lapsed_time{$i};
	    }
	    if ($i > 0) {
		value_store("e/all-ctx-switches", $i, $global_ctx);
	    }
	} elsif(m/cpu  (\d+) (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)/) {
	    %cpu_ticks = (
		sum => $1 + $2 + $3 + $4 + $5 + $6 + $7,
		user => $1,
		nice => $2,
		sys => $3,
		idle => $4,
		iowait => $5,
		irq => $6,
		softirq => $7,
	    );
	    foreach (qw/user nice sys idle iowait irq softirq/) {
		if (%prev_cpu_ticks) {
		    value_store_zeropad("e/cpu-$_", $i,
			100 * (($cpu_ticks{$_} - $prev_cpu_ticks{$_}) /
			    ($cpu_ticks{sum} - $prev_cpu_ticks{sum})));
		} else {
		    value_store_zeropad("e/cpu-$_", $i, 0);
		}
	    }
	} elsif( m/processes /) {
	    (undef, $processes) = split(' ' , $_, 2);

	    my $global_processes = 0;
	    if ($global_processes_prev and $lapsed_time{$i}) {
		$global_processes = (60*($processes - $global_processes_prev))/$lapsed_time{$i};
	    }
	    if ($i > 0) {
		value_store("e/global-processes", $i, $global_processes);
	    }
	    last;
	}
    }
    close(STAT);
    $global_ctx_prev = $ctx;
    %prev_cpu_ticks = %cpu_ticks;
    $global_processes_prev = $processes;
}

sub process_pagetypeinfo()
{
    my $fn = $d . "/pagetypeinfo";
    if (! -e $fn) {
	return;
    }
    unless (open(PAGETYPEINFO, $fn)) {
	print STDERR "WARNING: unable to open $fn: $!\n";
	return;
    }
    my (@unmovable, @reclaimable, @movable, @reserve, @isolate);
    while (<PAGETYPEINFO>) {
	chop;
	if( m/Node /) {
	    $have_pagetypeinfo = 1;
	    if (m/Unmovable/) {
		(@unmovable) = split(' ' , $_, 17);
	    } elsif (m/Reclaimable/) {
		(@reclaimable) = split(' ' , $_, 17);
	    } elsif (m/Movable/) {
		(@movable) = split(' ' , $_, 17);
	    } elsif (m/Reserve/) {
		(@reserve) = split(' ' , $_, 17);
	    } elsif (m/Isolate/) {
		(@isolate) = split(' ' , $_, 17);
	    } 
	}
    }
    close(PAGETYPEINFO);
    for my $ordernum (0 .. 10) {
	my $order = 1 << $ordernum;
	$fn = "e/pt-unmovable-$ordernum";
	value_store_zeropad($fn, $i, ($unmovable[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-reclaimable-$ordernum";
	value_store_zeropad($fn, $i, ($reclaimable[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-movable-$ordernum";
	value_store_zeropad($fn, $i, ($movable[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-reserve-$ordernum";
	value_store_zeropad($fn, $i, ($reserve[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
	$fn = "e/pt-isolate-$ordernum";
	value_store_zeropad($fn, $i, ($isolate[$ordernum+6]*$order*$pg_bytes)/$MB_bytes);
    }
}

# ==> /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state <==
# 1000000 23307374
# 800000 1039046
# 600000 785700
# 300000 1588381
sub process_sysfs_cpu
{
    my $fn = "$d/sysfs_cpu";
    if (not open(SYSFS, $fn)) {
	return;
    }
    while (<SYSFS>) {
	if (m#^==> /sys/devices/system/cpu/cpu(\d+)/cpufreq/stats/time_in_state <==#) {
	    my $cpu_num = $1;
	    if (not $time_in_state_freqs_seen{$cpu_num}) {
		$time_in_state_freqs_seen{$cpu_num} = {};
	    }
	    my %time_in_state;
	    while (<SYSFS> =~ m#(\d+)\s+(\d+)#) {
		my ($freq, $ticks) = (int($1), int($2));
		$freq /= 1000;
		$time_in_state{$freq} = $ticks;
		$time_in_state_freqs_seen{$cpu_num}->{$freq} = 1;
	    }
	    if ($prev_time_in_state_pcpu{$cpu_num}) {
		my %prev_time_in_state = %{$prev_time_in_state_pcpu{$cpu_num}};
		my $total_ticks = sum(values(%time_in_state)) - sum(values(%prev_time_in_state));
		if ($total_ticks != 0) {
		    foreach my $freq (keys(%time_in_state)) {
			my $ticks = $time_in_state{$freq};
			my $prev_ticks = $prev_time_in_state{$freq};
			my $pct = 100 * (($ticks - $prev_ticks) / $total_ticks);
			value_store_zeropad("e/sysfs_cpu${cpu_num}_${freq}mhz", $i, $pct);
		    }
		}
	    }
	    $prev_time_in_state_pcpu{$cpu_num} = \%time_in_state;
	}
    }
    close(SYSFS);
}

sub process_sysfs_fs
{
    return unless open(SYSFS_FS, $d . '/sysfs_fs');
    while (<SYSFS_FS>) {
	if (m#==> /sys/fs/ext4/(\S+)/lifetime_write_kbytes <==#) {
	    my $device = $1;
	    my $value = int(<SYSFS_FS>);
	    if ($sysfs_fs_prev{$device}) {
		my $prev_value = int($sysfs_fs_prev{$device});
		value_store("e/fs-ext4-lifetime-write-MB-$device", $i,
		    ($value - $prev_value) / 1024);
	    }
	    $sysfs_fs_prev{$device} = $value;
	    $sysfs_fs_devices_seen{$device} = 1;
	}
    }
    close(SYSFS_FS);
}

sub process_sysfs_power_supply
{
    return unless open(SYSFS_POWER_SUPPLY, $d . '/sysfs_power_supply');
    my %ps;
    while (<SYSFS_POWER_SUPPLY>) {
	if (m#==> /sys/class/power_supply/(BAT\d+)#) {
	    $sysfs_power_supply_devices{$1} = 1;
	}
	if (m#==> /sys/class/power_supply/(BAT\d+)/voltage_now <==#) {
	    $ps{$1}{voltage_now} = int(<SYSFS_POWER_SUPPLY>) / 1e6;
	} elsif (m#==> /sys/class/power_supply/(BAT\d+)/charge_now <==#) {
	    $ps{$1}{charge_now} = int(<SYSFS_POWER_SUPPLY>) / 1e6;
	} elsif (m#==> /sys/class/power_supply/(BAT\d+)/charge_full_design <==#) {
	    $ps{$1}{charge_full_design} = int(<SYSFS_POWER_SUPPLY>) / 1e6;
	} elsif (m#==> /sys/class/power_supply/(BAT\d+)/temp <==#) {
	    $ps{$1}{temp} = int(<SYSFS_POWER_SUPPLY>);
	} elsif (m#==> /sys/class/power_supply/(BAT\d+)/model_name <==#) {
	    my $line = <SYSFS_POWER_SUPPLY>;
	    chomp $line;
	    $sysfs_power_supply_device_model_name{$1} = $line;
	} elsif (m#==> /sys/class/power_supply/(BAT\d+)/manufacturer <==#) {
	    my $line = <SYSFS_POWER_SUPPLY>;
	    chomp $line;
	    $sysfs_power_supply_device_manufacturer{$1} = $line;
	}
    }
    close(SYSFS_POWER_SUPPLY);
    foreach my $dev (keys %ps) {
	foreach my $key (keys(%{$ps{$dev}})) {
	    my $value = $ps{$dev}{$key};
	    value_store("e/power_supply-$dev-$key", $i, $value);
	}
	if (not defined $ps{$dev}{capacity} and
		($ps{$dev}{charge_now} and $ps{$dev}{charge_full_design})) {
	    value_store("e/power_supply-$dev-capacity", $i,
		100 * ($ps{$dev}{charge_now} / $ps{$dev}{charge_full_design}));
	}
    }
}

sub process_sysfs_backlight
{
    return unless open(SYSFS_BACKLIGHT, $d . '/sysfs_backlight');
    my %backlight;
    while (<SYSFS_BACKLIGHT>) {
	if (m#==> /sys/class/backlight/(\S+)/actual_brightness <==#) {
	    $sysfs_backlight_devices{$1} = 1;
	    $backlight{$1}{actual_brightness} = int(<SYSFS_BACKLIGHT>);
	} elsif (m#==> /sys/class/backlight/(\S+)/max_brightness <==#) {
	    $sysfs_backlight_devices{$1} = 1;
	    $backlight{$1}{max_brightness} = int(<SYSFS_BACKLIGHT>);
	}
    }
    close(SYSFS_BACKLIGHT);
    foreach my $dev (keys %backlight) {
	foreach my $key (keys(%{$backlight{$dev}})) {
	    my $value = $backlight{$dev}{$key};
	    value_store("e/sysfs-backlight-$dev-$key", $i, $value);
	}
	if ($backlight{$dev}{max_brightness} > 0 and $backlight{$dev}{actual_brightness}) {
	    value_store("e/sysfs-backlight-$dev-percentage", $i,
		100 * ($backlight{$dev}{actual_brightness} / $backlight{$dev}{max_brightness}));
	}
    }
}

sub emit_domain_values($$)
{
    my $line = shift;
    my $domain = shift;
    chop $line;
#    print "powerdomain $domain: line=[$line]\n";
    my (undef, $off, $ret, $ina, $on) = split('\|' , $line, 6);
    (undef, $off) = split(':' , $off, 2);
    (undef, $ret) = split(':' , $ret, 2);
    (undef, $ina) = split(':' , $ina, 2);
    (undef, $on) = split(':' , $on, 2);

    value_store_zeropad("e/p-domain-$domain-off", $i, $off);
    value_store_zeropad("e/p-domain-$domain-ret", $i, $ret);
    value_store_zeropad("e/p-domain-$domain-ina", $i, $ina);
    value_store_zeropad("e/p-domain-$domain-on", $i, $on);
}

sub process_powertop()
{
#
# powertop output if exists
#
    my $fn = $d . "/powertop.out";
    unless (open(POWERTOP, $fn)) {
	return;
    }
    $powertop_data_found = 1;
    my $secs;
    while (<POWERTOP>) {
	chop;
	if( m/Collecting data for /) {
	    (undef, undef, undef, $secs, undef) = split(' ' , $_, 5);
	    next;
	} elsif( index($_, "C#") != -1) {
	    my $line = <POWERTOP>;
	    while (<POWERTOP>) {
		$line = $_;
		if ($line eq "\n") {
		    last;
		}
		chop $line;
		chop $line;
# 
# it used to be like this:
#C#      | Ratio  | Avg/dura | Frequency | Ratio
#--------+--------+----------+-----------+--------+
#     C0 |  95.4% |          |  1000 MHz |  95.4% |
#     C1 |   0.2% |   11.2ms |   800 MHz |   0.0% |
#
#but startin with powertop  1.13.61 changed to separate tables:
#----------------------------+  +--------------------+
#     Available C-States     |  |   Available Freqs  |
#--------+--------+----------+  +-----------+--------+
#C#      | Ratio  | Avg/dura |  | Frequency | Ratio  |
#--------+--------+----------+  +-----------+--------+
#     C0 |   0.4% |          |  |  1000 MHz |   0.0% |
#     C1 |   0.4% |    0.3ms |  |   800 MHz |   0.0% |

#
# so I replace "|  |" with "|" (i.e. to have old style) for uniform parsing
#
#		print "power-c line=[$line]\n";
		$line =~ s/\|  \|/|/g;
#		print "xxxpower-c line=[$line]\n";
		my ($clev, $ratio_c, $dura, $freq, $ratio_f) = split('\|' , $line, 5);
#		if (index($clev, "C") == -1) {
#		    last;
#		}
		$clev =~ s/ //g;
#		print "power-c clev=[$clev]\n";
		value_store_zeropad("e/$clev", $i, $ratio_c);
		$seen_powertop_c_levels{$clev} = 1;
		if (index($freq, "MHz") != -1) {
		    $freq =~ s/ //g;
#		    print "power-c freq=[$freq]\n";
		    value_store_zeropad("e/$freq", $i, $ratio_f);
		    $seen_powertop_f_levels{$freq} = 1;
		}
	    }
	} elsif( index($_, "PID#") != -1) {
	    my $line = <POWERTOP>;
	    while (1) {
		$line = <POWERTOP>;
#		print "$i:line=[$line]\n";
		if ($line eq "\n") {
		    last;
		}
		my ($pid, $activ, $name, $func) = split('\|' , $line, 4);
		($func, undef) = split(' ' , $func, 2);
		my $id = $name . "-" . $pid . "-" . $func;
		$id =~ s/ //g;
		$id =~ s/\<//g;
		$id =~ s/\>//g;
		$id =~ s/\///g;
#		print "$i:id=[$id] [pid[$pid], activ[$activ], name[$name], func[$func]\n";
		$activ /= $secs;
		value_store("e/$id-activity", $i, $activ);
		$num_activity_samples{$id} += 1;
		$p_activity{$id} += $activ;
		if ($activ > $p_activity_max{$id}) {
		    $p_activity_max{$id} = $activ;
		}
	    }
	} elsif( index($_, "per |OFF:") != -1) {
	    emit_domain_values($_, "periph");
	} elsif( index($_, "core |OFF:") != -1) {
	    emit_domain_values($_, "core");
	} elsif( index($_, "neon |OFF:") != -1) {
	    emit_domain_values($_, "neon");
	} elsif( index($_, "sgx |OFF:") != -1) {
	    emit_domain_values($_, "sgx");
	} elsif( index($_, "dss |OFF:") != -1) {
	    emit_domain_values($_, "dss");
	} elsif( index($_, "mpu |OFF:") != -1) {
	    emit_domain_values($_, "mpu");
	} elsif( index($_, "Total wakeups") != -1) {
	    my (undef, undef, $wakeups, $wakeups_s, undef,
	     undef, $irqs, $irqs_s, undef, 
	     undef, $timers, $timers_s, undef) = split(' ' , $_, 13);
	    $wakeups_s =~ s/s//g;
	    $wakeups_s =~ s/\///g;
	    value_store("e/p-wakeups", $i, $wakeups_s);
	    $timers_s =~ s/s//g;
	    $timers_s =~ s/\///g;
	    value_store("e/p-timers", $i, $timers_s);
	}
    }
    close(POWERTOP);
}

sub parse_component_version
{
    return unless open(COMPONENT_VERSION, $d . '/component_version');
    while (<COMPONENT_VERSION>) {
	if (m/product/) {
	    chop;
	    (undef, $hw_product) = split(' ', $_, 2);
	    next;
	} elsif (m/hw-build/) {
	    chop;
	    (undef, $hw_build) = split(' ', $_, 2);
	    last;
	}
    }
    close(COMPONENT_VERSION);
}

sub loop_over_all_apps()
{
    my %shared_lpid_names_sz = ();
#
# use same hash keys set for two things (and sum of them is 3rd)
#
    foreach my $x (keys %all_apps) {
	my $fn;
	my $xxx;
	if (!$x) {
	    next;
	}
#	    print "$x ";

	###############
	if ($app_pss{$x}) {
	    $app_cumul_pss{$x} += $app_pss{$x};
	    $avg_pss{$x} = ($avg_pss{$x} * $i + $app_pss{$x})/($i+1);
	    my $dev = ($avg_pss{$x} - $app_pss{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_pss{$x} += $dev;
	    $devcount_pss{$x} += 1;
	    $xxx = $app_pss{$x} / 1024;
	} else {
	    $xxx = 0;
	}
#	    print "$i:$x:PSS: pss=$app_pss{$x} dev=$dev dev_cnt=$devcount_pss{$x} avg=$avg_pss{$x}\n";
#	if ($i == 0) {
#	    print "$app_pss{$x} $x\n";
#	}

	$fn = "e/p-$x";
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_sysv_shared{$x}) {
	    $app_cumul_sysv_shared{$x} += $app_sysv_shared{$x};
	    $avg_sysv_shared{$x} = ($avg_sysv_shared{$x} * $i + $app_sysv_shared{$x})/($i+1);
	    my $dev = ($avg_sysv_shared{$x} - $app_sysv_shared{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_sysv_shared{$x} += $dev;
	    $devcount_sysv_shared{$x} += 1;
	    $xxx = $app_sysv_shared{$x} / 1024;
	} else {
	    $xxx = 0;
	}
#	print "$i:$x:SYSV: pss=$app_sysv_shared{$x} dev=$dev dev_cnt=$devcount_sysv_shared{$x} avg=$avg_sysv_shared{$x}\n";

	$fn = "e/sysvshm-$x";
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_posix_shared{$x}) {
	    $app_cumul_posix_shared{$x} += $app_posix_shared{$x};
	    $avg_posix_shared{$x} = ($avg_posix_shared{$x} * $i + $app_posix_shared{$x})/($i+1);
	    my $dev = ($avg_posix_shared{$x} - $app_posix_shared{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_posix_shared{$x} += $dev;
	    $devcount_posix_shared{$x} += 1;
	    $xxx = $app_posix_shared{$x} / 1024;
	} else {
	    $xxx = 0;
	}
#	print "$i:$x:POSIX: pss=$app_posix_shared{$x} dev=$dev dev_cnt=$devcount_posix_shared{$x} avg=$avg_posix_shared{$x}\n";

	$fn = "e/posixshm-$x";
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_dev_pvr{$x}) {
	    $app_cumul_dev_pvr{$x} += $app_dev_pvr{$x};
	    $avg_dev_pvr{$x} = ($avg_dev_pvr{$x} * $i + $app_dev_pvr{$x})/($i+1);
	    my $dev = ($avg_dev_pvr{$x} - $app_dev_pvr{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_dev_pvr{$x} += $dev;
	    $devcount_dev_pvr{$x} += 1;
	    $xxx = $app_dev_pvr{$x} / 1024;
	} else {
	    $xxx = 0;
	}

	$fn = "e/devpvr-$x";
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_swapped{$x}) {
	    $app_cumul_swp{$x} += $app_swapped{$x};

	    $avg_swp{$x} = ($avg_swp{$x} * $i + $app_swapped{$x})/($i+1);
	    my $dev = ($avg_swp{$x} - $app_swapped{$x});
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_swp{$x} += $dev;
	    $devcount_swp{$x} += 1;
	    $xxx = $app_swapped{$x} / 1024;
	} else {
	    $xxx = 0;
	}
	$fn = "e/swp-$x";
	value_store_zeropad($fn, $i, $xxx);

	###############
	if ($app_rwxp{$x}) {
	    $app_cumul_rwxp{$x} += $app_rwxp{$x};
	    $xxx = $app_rwxp{$x} / 1024;
	} else {
	    $xxx = 0;
	}
	$fn = "e/$x-wx";
	value_store_zeropad($fn, $i, $xxx);

	###############
#	if ($app_private_dirty{$x}) {
#	    $app_cumul_private_dirty{$x} += $app_private_dirty{$x};
#
#	    $avg_private_dirty{$x} = ($avg_private_dirty{$x} * $i + $app_private_dirty{$x})/($i+1);
#	    my $dev = ($avg_private_dirty{$x} - $app_private_dirty{$x});
#	    if ($dev < 0) {
#		$dev = -1 * $dev;
#	    }
#	    $sumdev_private_dirty{$x} += $dev;
#	    $devcount_private_dirty{$x} += 1;
#	}
#	$fn = "e/$x-pdirty";
#	if ( ! -e $fn) {
#	    for ($z = 0 ; $z < $i ; $z++) {
#		system("echo '$z, 0' >> $fn");
#	    }
#	}
#	$xxx = $app_private_dirty{$x} / 1024;
#	system("echo '$i, $xxx' >> $fn");

	###############
	my $pss_swap = ($app_pss{$x} + $app_swapped{$x})/1024;
	if ($pss_swap) {
	    $app_cumul_pss_swp{$x} += $pss_swap;

#		$avg_pss_swp{$x} = ($avg_pss_swp{$x} * $i + $pss_swap)/($i+1);
	    $avg_pss_swp{$x} = ($avg_pss_swp{$x} * $devcount_pss_swp{$x} + $pss_swap)/($devcount_pss_swp{$x} + 1);
	    my $dev = ($avg_pss_swp{$x} - $pss_swap);
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_pss_swp{$x} += $dev;
	    $devcount_pss_swp{$x} += 1;
	    $pss_swap_num_samples{$x} += 1;
	}
	$fn = "e/pswp-$x";
	value_store_zeropad($fn, $i, $pss_swap);

#	if ($i == 0) {
#	    print "$pss_swap $x\n";
#	}
	###############
	my $pid = $pid_by_namepid{$x};
	my $lpid_name = $name_by_pid{$pid} ;
#	print "$i: lpid_name by pid=[$pid] is [$lpid_name]\n";
	if (defined $shared_lpid_cnt_oneround{$pid}) {
	    $shared_lpid_cnt{$x} += $shared_lpid_cnt_oneround{$pid};
	}
	if (defined $shared_cpid_cnt_oneround{$pid}) {
	    $shared_cpid_cnt{$x} += $shared_cpid_cnt_oneround{$pid};
	}

	my $shared;

	$shared = $shared_lpid{$pid};
	$fn = "e/shml-$x";
	if ($shared) {
#	    print "$i: lpid shared[x=$x pid=$pid] = $shared\n";
	    value_store_zeropad($fn, $i, $shared);
	    $avg_shared_lpid{$pid} = ($avg_shared_lpid{$pid} * $i + $shared)/($i+1);
	    my $dev = ($avg_shared_lpid{$pid} - $shared);
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_shared_lpid{$x} += $dev/$shared;
	    $devcount_shared_lpid{$x} += 1;
#		print "   lpid: inc devcount[$x] now = $devcount_shared_lpid{$x}\n";
	#
	# also by name-only. sum  up different shm mappings for apps that
	# have carried different PIDs. After this loop we loop over app names
	# and insert values there.
	#
	    if ($shared_lpid_cnt_oneround{$pid}) {
		if ($lpid_name) {
#		print "lpid-name: pid=$pid name=$lpid_name cnt=$shared_lpid_cnt_oneround{$pid};\n";
		    $shared_lpid_names_all_sz{$lpid_name} += $shared;
		    $shared_lpid_names_sz{$lpid_name} += $shared;
		}
		else {
		    print "$i: lpid-name: pid=$pid name=$lpid_name cnt=$shared_lpid_cnt_oneround{$pid};\n";
		}
	    }
	    

	} else {
	    value_store_zeropad($fn, $i, 0);
	    if ($lpid_name) {
		$shared_lpid_names_sz{$lpid_name} += 0;
	    }
	}
	# clear value or it remains there even if that pid has nothing in next round
	$shared_lpid{$pid} = 0;
	
	$shared = $shared_cpid{$pid};
	$fn = "e/shmc-$x";
	if ($shared) {
#	    print "$i: cpid shared[x=$x pid=$pid] = $shared\n";
	    value_store_zeropad($fn, $i, $shared);
	    $avg_shared_cpid{$pid} = ($avg_shared_cpid{$pid} * $i + $shared)/($i+1);
	    my $dev = ($avg_shared_cpid{$pid} - $shared);
	    if ($dev < 0) {
		$dev = -1 * $dev;
	    }
	    $sumdev_shared_cpid{$x} += $dev/$shared;
	    $devcount_shared_cpid{$x} += 1;
#		print "   cpid: inc devcount[$x] now = $devcount_shared_lpid{$x}\n";
	} else {
	    value_store_zeropad($fn, $i, 0);
	}
	$shared_cpid{$pid} = 0;

	if (exists $vma_count{$x}) {
	    my $fn = "e/vma-count-$x";
	    value_store($fn, $i, $vma_count{$x});
	    $vma_count_max{$x} = max $vma_count{$x}, $vma_count_max{$x};
	}
    }
    #
    # loops over shmem lpid names and insert values
    #
    foreach my $x (keys %shared_lpid_names_sz) {
	my $fn = "e/shmln-$x";
	value_store_zeropad($fn, $i, $shared_lpid_names_sz{$x});
    }
}

sub img_to_filename
{
    my ($img) = @_;
    return $graphs_dir . '/' . $img . '.png';
}

sub img_to_thumb
{
    my ($img) = @_;
    return $graphs_dir . '/' . $img . '_thumb.jpg';
}

sub echo_one_img_line
{
    my ($html, $img) = @_;
    my $img_fn = img_to_filename($img);
    my $thumb_fn = img_to_thumb($img);
    if (-e $img_fn and -s $img_fn > 0) {
	print $html "<table class=\"image\">\n";
	print $html "<caption align=\"bottom\">$thumbnames{$img}</caption>\n";
	print $html "<tr><td><a href=$img_fn><img src=$thumb_fn></a></td></tr>\n";
	print $html "</table>\n";
	return 1;
    }
    return 0;
}

sub add_use_case_names
{
    my ($html) = @_;
    if (!$steps_files) {
	return;
    }
    print $html "\n<br clear='all'/>\n";
    print $html "<a name='steps'/>\n";
    print $html "<h2>SNAPSHOT DATES AND DESCRIPTIONS</h2>\n";
    foreach my $dir (@dirs) {
	my $dfn = $dir . '/step.txt';
	if (-e $dfn) {
	    my $step = `cat $dfn`;
	    chop $step;
	    my $desc = $dir;
	    if (int($dir) >= 101) {
		$desc = $dir - 101;
	    }
	    print $html "$desc: [$round_date{$dir}] $step<br/>\n";
	}
    }
}

sub duration_to_str
{
    my ($duration_secs) = @_;
    my $hours = int($duration_secs / 3600);
    my $minutes = int(($duration_secs % 3600) / 60);
    if ($hours > 0) {
	return "${hours}h ${minutes}min";
    } elsif ($minutes > 0) {
	return "${minutes}min";
    } else {
	return "${duration_secs}s";
    }
}

# (Average, longest, shortest) intervals.
sub round_duration_stats
{
    # Pick durations starting from round 1 (ignore the initial zero-valued
    # round zero).
    my @intervals;
    foreach (grep { $_ } keys %lapsed_time) {
	push(@intervals, $lapsed_time{$_});
    }
    return (duration_to_str($secs_per_round),
	    duration_to_str(max(@intervals)),
	    duration_to_str(min(@intervals)));
}

sub html_title
{
    return "Endurance graph [$hw_product][$sw_version] " .
	"snapshot avg interval " . (round_duration_stats())[0] .
	", total duration " . duration_to_str($total_duration) . ".";
}

sub gen_html_page
{
    my $html;
    if (not open($html, '>', $html_name)) {
	print STDERR "ERROR: unable to open $html_name for writing: $!\n";
	exit(1);
    }
    print $html "<html>\n";
    print $html "<head>\n";
    print $html " <style>\n";
    print $html "  table { float: left; margin: 20px 5px 0px 0; }\n";
    print $html " </style>\n";
    print $html " <title>" . html_title() . "</title>\n";
    print $html "</head>\n";
    print $html "<body>\n";

    print $html "<h1>ENDURANCE GRAPHS</h1>\n";
    print $html "<ul>\n";
    print $html " <li>Total duration: <b>" . duration_to_str($total_duration) . "</b>. ";
    printf $html "Snapshot interval average: <b>%s</b> | longest: <b>%s</b> | shortest: <b>%s</b>.\n",
		round_duration_stats();
    print $html " <li>OS version: <b>$sw_version</b>. " .
		($hw_product ? "Hardware: <b>$hw_product:$hw_build</b>." : "") . "\n";
    print $html " <li>Content: " .
		"<a href='#process_graphs'>Process Resource Usage Graphs</a> | " .
		"<a href='#system_graphs'>System Resource Usage Graphs</a> | " .
		"<a href='#steps'>Snapshot Dates and Descriptions</a>. " .
		"See also: <a href='endurance-report.html'>endurance-report.html</a>.\n";
    print $html "</ul>\n";

    my @html_images;
    my (@process_images, @system_images);
    foreach (keys %images) {
	if (/^1/) { push(@process_images, $_); }
	else { push(@system_images, $_); }
    }

    print $html "<a name='process_graphs'/>\n";
    print $html "\n<h2>PROCESS RESOURCE USAGE GRAPHS</h2>\n";
    foreach my $img (sort @process_images) {
	my $ret = echo_one_img_line($html, $img);
	push(@html_images, $img) if $ret;
    }

    print $html "\n<br clear='all'/>\n";
    print $html "<a name='system_graphs'>\n";
    print $html "<h2>SYSTEM RESOURCE USAGE GRAPHS</h2>\n";
    foreach my $img (sort @system_images) {
	my $ret = echo_one_img_line($html, $img);
	push(@html_images, $img) if $ret;
    }

    for (my $swfr = 1; $swfr <= 3; $swfr++) {
	my $img = $graph_fragmentation[$swfr - 1];
	my $fn = $graphs_dir . "/" . $img . ".png";
	if (-e $fn) {
	    $thumbnames{$img} = "SWAP FRAGMENTATION " . $swfr;
	    my $ret = echo_one_img_line($html, $img);
	    push(@html_images, $img) if $ret;
	}
    }

    add_use_case_names($html);

    print $html "</body>\n";
    print $html "</html>\n";

    close($html);

    return @html_images;
}

sub gen_thumbnails
{
    my @html_images = @_;
    foreach my $img (@html_images) {
	$forkmanager->start() and next if $forkmanager;
	my $img_fn = img_to_filename($img);
	my $thumb_fn = img_to_thumb($img);
	system("pngtopnm $img_fn | pnmscalefixed -width=$thumb_width -height=$thumb_height | pnmtojpeg > $thumb_fn");
	if (WIFSIGNALED($?)) {
	    my $sig = WTERMSIG($?);
	    # Ignore thumnail generation problems (SIGSEGV etc), but stop
	    # processing if it looks like the users wants to abort the plot
	    # generation.
	    if ($sig == SIGINT or $sig == SIGTERM or $sig == SIGKILL) {
		kill($sig, $$);
	    }
	}
	$forkmanager->finish() if $forkmanager;
    }
    $forkmanager->wait_all_children() if $forkmanager;
}

sub xtics
{
    my @xtics;
    my $ii = 0;
    foreach my $dir (@dirs) {
	my $desc = $dir;
	if (int($dir) >= 101) {
	    $desc = $dir - 101;
	} else {
	    $desc = substr($desc, -5);
	}
	push(@xtics, "\"$desc: [$round_date{$dir}]\" $ii");
	$ii++;
    }
    # Less ticks if we have lots of rounds.
    my $pick = 0;
    if (($plot_width / scalar(@dirs)) < 10) {
	@xtics = grep { not ($pick++ % 10) } @xtics;
    } elsif (($plot_width / scalar(@dirs)) < 20) {
	@xtics = grep { not ($pick++ % 5) } @xtics;
    } elsif (($plot_width / scalar(@dirs)) < 35) {
	@xtics = grep { not ($pick++ % 2) } @xtics;
    }
    return join(',', @xtics);
}

sub start_plotfile_common($)
{
    my $key = shift;

    my $title = $legend{$key};
    my $ylabel = $unit{$key};
    my $plot;

    my $cmdfname = "e/" . $key . ".cmd";

    unless (open ($plot, "> $cmdfname")) {
	print STDERR "WARNING: unable to create $cmdfname: $!\n";
    }

    $title = $title . "\\nSW=" . $sw_version . "\\nHW=" . $hw_product . ":" . $hw_build;

    print $plot "set label \"$title\" at graph 0.02,0.98\n";
    print $plot "set xlabel \"rounds\"\n";
    print $plot "set ylabel \"$ylabel\"\n";
    print $plot "set grid xtics ytics\n";
    if ($gnuplot_terminal eq 'pngcairo') {
	print $plot "set term pngcairo size $plot_width, 1100 font \"serif,8\"\n";
	print $plot "set xtics (" . xtics() . ") rotate by -25\n";
    } else {
	print $plot "set term png small truecolor size $plot_width, 1100\n";
    }
    return $plot;
}

sub start_plotfile_lines_common($$)
{
    my $key = shift;
    my $style = shift;
    my $plot;

    $plot = start_plotfile_common($key);

    print $plot "set style data $style\n";
    print $plot "set key autotitle reverse Left\n";
    my $add = scalar(@dirs)/4;
    if ($add < 10) {
	$add = 10;
    }
    my $xmax = scalar(@dirs) + $add;
    print $plot "plot [0:$xmax] ";
    return $plot;
}

sub start_plotfile_lines_common_2axes($$)
{
    my $key = shift;
    my $style = shift;
    my $plot;
    my $ylabel = $unit_1{$key};
    my $y2label = $unit_2{$key};

    $plot = start_plotfile_common($key);

    print $plot "set ylabel \"$ylabel\"\n";
    print $plot "set y2label \"$y2label\"\n";
    print $plot "set ytics nomirror\n";
    print $plot "set y2tics\n";
    print $plot "set style data $style\n";
    print $plot "set key autotitle reverse Left\n";
    my $xmax = scalar(@dirs)+5;
    print $plot "set xrange [0 : $xmax]\n";
    print $plot "set yrange [0 : ]\n";
    print $plot "set x2range [0 : $xmax]\n";
    print $plot "set y2range [0 : ]\n";
    print $plot "plot ";
    return $plot;
}

sub start_plotfile_lines($)
{
    my $key = shift;
    return start_plotfile_lines_common($key, "lines")
}

sub start_plotfile_lines_2axes($)
{
    my $key = shift;
    return start_plotfile_lines_common_2axes($key, "lines")
}

sub start_plotfile_linespoints($)
{
    my $key = shift;
    return start_plotfile_lines_common($key, "linespoints")
}

sub start_plotfile_histogram($)
{
    my $key = shift;
    my $plot;

    $plot = start_plotfile_common($key);

    print $plot "set style data histograms\n";
    print $plot "set key invert autotitle reverse Left\n";
    print $plot "set style histogram rowstacked\n";
    print $plot "set style fill solid 1.00 border -1\n";
    print $plot "set yrange [0 : ]\n";

    my $add = scalar(@dirs)/3;
    if ($add < 25) {
	$add = 25;
    }
    my $xmax = scalar(@dirs) + $add;
    print $plot "plot [-1:$xmax] ";

    return $plot;
}

sub start_plotfile_histogram_multi($)
{
    my $key = shift;
    my $plot;

    $plot = start_plotfile_common($key);

    print $plot "set style data histograms\n";
    print $plot "set key invert autotitle reverse Left\n";
    print $plot "set style histogram rowstacked\n";
    print $plot "set style fill solid 1.00 border -1\n";
    print $plot "set multiplot\n";
    print $plot "unset label\n";

    return $plot;
}

sub close_plot($$$)
{
    my $count = shift;
    my $plot = shift;
    my $key = shift;

    print $plot "\n";
    close $plot;
    if ($count) {
	my $cmdfname = "e/" . $key . ".cmd";
	my $img_fn   = $graphs_dir . "/" . $key . ".png";
	push(@gnuplot_commands, "gnuplot $cmdfname > $img_fn");
	$images{$key} = $key;
	$thumbnames{$key} = $thumblegend{$key};
    } else {
#	print "\nNot enough changes/samples for $key, skipped\n";
#	print "(skip $key) ";
#	print "(skip) ";
    }
}

sub run_gnuplot
{
    foreach (sort @gnuplot_commands) {
	$forkmanager->start() and next if $forkmanager;
	print " > $_\n";
	system($_);
	if (WIFSIGNALED($?)) {
	    my $sig = WTERMSIG($?);
	    # Ignore gnuplot problems (SIGSEGV etc), but stop processing if it
	    # looks like the users wants to abort the plot generation.
	    if ($sig == SIGINT or $sig == SIGTERM or $sig == SIGKILL) {
		kill($sig, $$);
	    }
	}
	$forkmanager->finish() if $forkmanager;
    }
    $forkmanager->wait_all_children() if $forkmanager;
}

sub print_cf_states_plot_cmds($)
{
    my $plot = shift;
    my $cnt_1 = 0;
    my $cnt_2 = 0;
    my $xmax = scalar(@dirs)+18;

    print $plot "set size 1.0,0.4\n";
    print $plot "set origin 0.0,0.0\n";
    print $plot "set title \"C states\"\n";
    print $plot "plot [-1:$xmax] ";
    # need number of entries for 
    # using colors in reverse order so that highest level gets red
    # (which is lowest lt number)
    my $num_entries = 0;
    foreach my $p (reverse sort keys %seen_powertop_c_levels) {
	$num_entries += 1;
    }
    # and we sort them like this to get highest stuff to the top
    foreach my $p (reverse sort keys %seen_powertop_c_levels) {
	if ($cnt_1 > 0) {
	    print $plot ", ";
	}
	print $plot "'e/$p' using 2 lt $num_entries";
	value_emit("e/$p", 1);
	$cnt_1 += 1;
	$num_entries -= 1;
    }
    print $plot "\nset size 1.0,0.4\n";
    print $plot "set origin 0.0,0.5\n";
    print $plot "set title \"Freq states\"\n";
    print $plot "plot [-1:$xmax] ";
    $num_entries = 0;
    foreach my $p (reverse sort keys %seen_powertop_f_levels) {
	$num_entries += 1;
    }
    foreach my $p (sort { $a <=> $b } keys %seen_powertop_f_levels) {
	if ($cnt_2 > 0) {
	    print $plot ", ";
	}
	print $plot "'e/$p' using 2 lt $num_entries";
	value_emit("e/$p", 1);
	$cnt_2 += 1;
	$num_entries -= 1;
    }
    return ($cnt_1 + $cnt_2);
}

sub print_domain_plot_cmds($$$$)
{
    my $plot = shift;
    my $domain = shift;
    my $height = shift;
    my $offs = shift;

    my $xmax = scalar(@dirs)+18;
    value_emit("e/p-domain-$domain-off", 1);
    value_emit("e/p-domain-$domain-ret", 1);
    value_emit("e/p-domain-$domain-ina", 1);
    value_emit("e/p-domain-$domain-on", 1);
    print $plot "set size 1.0,$height\n";
    print $plot "set origin 0.0,$offs\n";
    print $plot "set title \"$domain states\"\n";
#
# here we explicitly code bar color, lt=1:red=ON lt=2:green=OFF, others by enum
#
    print $plot "plot [-1:$xmax] 'e/p-domain-$domain-off' using 2 lt 2, ";
    print $plot "'e/p-domain-$domain-ret' using 2 lt 3, ";
    print $plot "'e/p-domain-$domain-ina' using 2 lt 4, ";
    print $plot "'e/p-domain-$domain-on' using 2 lt 1\n";
}

sub generate_plot_system_memory_1
{
    my $cnt = 0;
    my $plot = start_plotfile_lines($graph_system_memory_1);
    if (count_nonzero_entries($swapused_plot_file_name)) {
	one_plot_set(fn => $swapused_plot_file_name, plot => $plot,
	    lw => 5, emit_zeroes => 1, cnt => \$cnt, lc => 'FF0000',
	    title => 'Swap used');
    }
    if (count_nonzero_entries($app_swapped_plot_file_name)) {
	one_plot_set(fn => $app_swapped_plot_file_name, plot => $plot,
	    lw => 2, emit_zeroes => 1, cnt => \$cnt, lc => 'FF0000',
	    title => 'Sum of swapped in applications');
    }
    if (count_nonzero_entries($swapcached_plot_file_name)) {
	one_plot_set(fn => $swapcached_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Swapcached');
    }
    if (count_nonzero_entries($memfree_plot_file_name)) {
	one_plot_set(fn => $memfree_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'MemFree');
    }
    if (count_nonzero_entries($cached_plot_file_name)) {
	one_plot_set(fn => $cached_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Cached');
    }
    if (count_nonzero_entries($active_file_plot_file_name)) {
	one_plot_set(fn => $active_file_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Active (file)');
    }
    if (count_nonzero_entries($inactive_file_plot_file_name)) {
	one_plot_set(fn => $inactive_file_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Inactive (file)');
    }
    if (count_nonzero_entries($active_anon_plot_file_name)) {
	one_plot_set(fn => $active_anon_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Active (anon)');
    }
    if (count_nonzero_entries($inactive_anon_plot_file_name)) {
	one_plot_set(fn => $inactive_anon_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Inactive (anon)');
    }
    if (count_nonzero_entries($shmem_plot_file_name)) {
	one_plot_set(fn => $shmem_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Shmem');
    }
    if (count_nonzero_entries($app_pss_plot_file_name)) {
	one_plot_set(fn => $app_pss_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Sum of PSS');
    }
    close_plot($cnt, $plot, $graph_system_memory_1);
}

sub generate_plot_system_memory_2
{
    my $cnt = 0;
    my $plot = start_plotfile_lines($graph_system_memory_2);
    if (value_exists($dirty_plot_file_name)) {
	one_plot_set(fn => $dirty_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Dirty');
    }
    if (value_exists($buffers_plot_file_name)) {
	one_plot_set(fn => $buffers_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Buffers');
    }
    if (value_exists($mlocked_plot_file_name)) {
	one_plot_set(fn => $mlocked_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Mlocked');
    }
    if (count_nonzero_entries($mpixmaps_plot_file_name)) {
	one_plot_set(fn => $mpixmaps_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'Pixmaps');
    }
    if (value_exists($pagetables_plot_file_name)) {
	one_plot_set(fn => $pagetables_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'PageTables');
    }
    if (value_exists($kernelstack_plot_file_name)) {
	one_plot_set(fn => $kernelstack_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'KernelStack');
    }
    if (value_exists($slabreclaim_plot_file_name)) {
	one_plot_set(fn => $slabreclaim_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'SlabReclaimable');
    }
    if (value_exists($slabunreclaim_plot_file_name)) {
	one_plot_set(fn => $slabunreclaim_plot_file_name, plot => $plot,
	    lw => 3, emit_zeroes => 1, cnt => \$cnt,
	    title => 'SlabUnreclaimable');
    }
    close_plot($cnt, $plot, $graph_system_memory_2);
}

sub generate_plot_slab
{
    my $plot = start_plotfile_lines($graph_mem_slabs);
    my $cnt = 0;
    foreach my $p (reverse sort {$all_slabs{$a} <=> $all_slabs{$b} } keys %all_slabs) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	if ($all_slabs{$p} == 0) {
	    next;
	}
	one_plot_set(fn => "e/slabs-$p", lw => 3, plot => $plot, cnt => \$cnt,
	    title => $p);
    }
    close_plot($cnt, $plot, $graph_mem_slabs);
}

sub generate_plot_ctx
{
    my $plot;
    my $cnt;
    my $fn;

############# Processes, total ctxt switches  ######################
    $plot = start_plotfile_linespoints($graph_events_ctx_total);

    $cnt = 0;
    foreach my $p (reverse sort {$cumul_total_ctx{$a} <=> $cumul_total_ctx{$b} } keys %cumul_total_ctx) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($cumul_total_ctx{$p} == 0) {
	    last;
	}
	one_plot_set(fn => "e/total-ctx-$p", lw => 3, plot => $plot,
	    cnt => \$cnt, emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_events_ctx_total);

############# Processes, non-voluntary ctxt switches  ######################
    $plot = start_plotfile_linespoints($graph_events_ctx_nonvolunt);

    $cnt = 0;
    foreach my $p (reverse sort {$cumul_nonvol_ctx{$a} <=> $cumul_nonvol_ctx{$b} } keys %cumul_nonvol_ctx) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($cumul_nonvol_ctx{$p} == 0) {
	    last;
	}
	one_plot_set(fn => "e/nonvol-ctx-$p", lw => 3, plot => $plot,
	    cnt => \$cnt, emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_events_ctx_nonvolunt);

############# Processes, voluntary ctxt switches  ######################
    $plot = start_plotfile_linespoints($graph_events_ctx_volunt);

    $cnt = 0;
    foreach my $p (reverse sort {$cumul_vol_ctx{$a} <=> $cumul_vol_ctx{$b} } keys %cumul_vol_ctx) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($cumul_vol_ctx{$p} == 0) {
	    last;
	}
	one_plot_set(fn => "e/vol-ctx-$p", lw => 3, plot => $plot,
	    cnt => \$cnt, emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_events_ctx_volunt);

############# global ctx switched #####################
    $plot = start_plotfile_lines_2axes($graph_ctx_global);
    $cnt = 0;
    one_plot_set(fn => 'e/all-ctx-switches', plot => $plot, lw => 3,
	axes => 'x1y1', emit_zeroes => 1, cnt => \$cnt,
	title => 'Context switches');
    one_plot_set(fn => 'e/num-processes', plot => $plot, lw => 3,
	axes => 'x2y2', emit_zeroes => 1, cnt => \$cnt,
	title => 'Process and thread count');
    close_plot($cnt, $plot, $graph_ctx_global);
}

sub generate_plot_loadavg
{
    my $cnt = 0;
    my $plot = start_plotfile_lines($graph_loadavg);
    one_plot_set(fn => $load_1_file_name, plot => $plot, lw => 3,
	cnt => \$cnt, emit_zeroes => 1, title => '1 minute average');
    one_plot_set(fn => $load_5_file_name, plot => $plot, lw => 3,
	cnt => \$cnt, emit_zeroes => 1, title => '5 minute average');
    one_plot_set(fn => $load_15_file_name, plot => $plot, lw => 3,
	cnt => \$cnt, emit_zeroes => 1, title => '15 minute average');
    close_plot($cnt, $plot, $graph_loadavg);
}

sub generate_plot_processes_global
{
    my $cnt = 0;
    my $plot = start_plotfile_lines($graph_processes_global);
    one_plot_set(fn => 'e/global-processes', plot => $plot, lw => 3,
	cnt => \$cnt, emit_zeroes => 1, title => 'Processes and threads');
    close_plot($cnt, $plot, $graph_processes_global);
}

sub generate_plot_pagefaults
{
    my $plot = start_plotfile_lines($graph_events_major_pagefaults);
    my $cnt = 0;
    foreach my $p (reverse sort {$majflt_cumul{$a} <=> $majflt_cumul{$b} } keys %majflt_cumul) {
#	if ($cnt > $max_per_graph_onecolumn) {
	if ($cnt > 5) {
	    last;
	} 
	if ($majflt_cumul{$p} == 0) {
	    last;
	} 
	one_plot_set(fn => "e/majflt-$p", lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_events_major_pagefaults);
}

sub generate_plot_cpu
{
    my $plot = start_plotfile_histogram($graph_cpu);
    my $cnt = 0;
    my %cpu_colors = (
	    "user" => "3149BD",
	    "nice" => "4265FF",
	    "sys" => "DE2821",
	    "irq" => "FF0000",
	    "softirq" => "EF0000",
	    "iowait" => "EE00FF",
	    "idle" => "ADE739");
    foreach (qw/sys irq softirq user nice iowait idle/) {
	one_plot_set(fn => "e/cpu-$_", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $_, lc => $cpu_colors{$_});
    }
    close_plot($cnt, $plot, $graph_cpu);
}

sub generate_plot_cpu_freq
{
    foreach my $cpu_num (keys(%time_in_state_freqs_seen)) {
	my $graph_cpu_time_in_state = "2010_cpu${cpu_num}_time_in_state";
	$legend{$graph_cpu_time_in_state} = "CPU${cpu_num} time in state";
	$thumblegend{$graph_cpu_time_in_state} = "CPU${cpu_num} TIME IN STATE";
	$unit{$graph_cpu_time_in_state} = 'percent';
	my $cnt = 0;
	my $plot = start_plotfile_histogram($graph_cpu_time_in_state);
	my @freqs = keys(%{$time_in_state_freqs_seen{$cpu_num}});
	foreach my $freq (sort {$a <=> $b} @freqs) {
	    one_plot_set(fn => "e/sysfs_cpu${cpu_num}_${freq}mhz",
		plot => $plot, cnt => \$cnt, emit_zeroes => 1,
		title => "${freq}MHz");
	}
	close_plot($cnt, $plot, $graph_cpu_time_in_state);
    }
}

sub device_to_filesystem
{
    my ($device) = @_;
    my @matched_filesystems = grep { /\b$device\b/ } keys %filesystem_to_mountpoint;
    if (@matched_filesystems) {
	return $filesystem_to_mountpoint{$matched_filesystems[0]};
    } elsif ($device eq 'mmcblk0p2' and $sw_version =~ /HARMATTAN/) {
	return '/';
    } else {
	return;
    }
}

sub generate_plot_fs_written
{
    my $cnt = 0;
    my $plot = start_plotfile_linespoints($graph_ext4_written);
    foreach my $device (keys(%sysfs_fs_devices_seen)) {
	my $title = $device;
	my $fs = device_to_filesystem($device);
	$title = $device . ': ' . $fs if $fs;
	one_plot_set(fn => "e/fs-ext4-lifetime-write-MB-$device", lw => 3,
	    plot => $plot, cnt => \$cnt, emit_zeroes => 1, title => $title);
    }
    close_plot($cnt, $plot, $graph_ext4_written);
}

sub generate_plot_cputime
{
    my $plot;
    my $cnt;

############# Processes, utime ######################
    $plot = start_plotfile_linespoints($graph_cpu_usertime);

    $cnt = 0;
    foreach my $p (reverse sort {$utime_cumul{$a} <=> $utime_cumul{$b} } keys %utime_cumul) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($utime_cumul{$p} == 0) {
	    last;
	}
	one_plot_set(fn => "e/utime-$p", lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_cpu_usertime);

############# Processes, stime ######################
    $plot = start_plotfile_linespoints($graph_cpu_systime);

    $cnt = 0;
    foreach my $p (reverse sort {$stime_cumul{$a} <=> $stime_cumul{$b} } keys %stime_cumul) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($stime_cumul{$p} == 0) {
	    last;
	}
	one_plot_set(fn => "e/stime-$p", lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_cpu_systime);

############# Processes, totaltime=stime+utime ######################
    $plot = start_plotfile_linespoints($graph_cpu_totaltime);

    $cnt = 0;
    foreach my $p (reverse sort {$totaltime_cumul{$a} <=> $totaltime_cumul{$b} } keys %totaltime_cumul) {
	if ($cnt > $max_per_graph_twocolumn) {
	    last;
	} 
	if ($totaltime_cumul{$p} == 0) {
	    last;
	}
	one_plot_set(fn => "e/$p-totaltime", lw => 3, plot => $plot,
	    cnt => \$cnt, emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_cpu_totaltime);
}

sub generate_plot_shmem
{
    my $plot;
    my $cnt;
    my $fn;

############### Histogram of shared mem #################
    $cnt = 0;
    $plot = start_plotfile_histogram($graph_mem_shared);
    one_plot_set(fn => $shared_locked_plot_file_name, plot => $plot,
	cnt => \$cnt, emit_zeroes => 1, title => 'Locked to memory');
    one_plot_set(fn => $shared_unlocked_plot_file_name, plot => $plot,
	cnt => \$cnt, emit_zeroes => 1, title => 'Not locked to memory');
    close_plot($cnt, $plot, $graph_mem_shared);

############### Histogram of shared mem lpid #################
    $plot = start_plotfile_histogram($graph_mem_shared_lpid);
#    $plot = start_plotfile_lines($graph_mem_shared_lpid);

    foreach my $p (keys %shared_lpid_cnt) {
	if ($devcount_shared_lpid{$p}) {
	    $sumdev_shared_lpid{$p} /= $devcount_shared_lpid{$p};
	    $sumdev_shared_lpid{$p} += (100*(scalar(@dirs) - $devcount_shared_lpid{$p}));
	}
    }

    $cnt = 0;
    foreach my $p (sort {$sumdev_shared_lpid{$a} <=> $sumdev_shared_lpid{$b} } keys %shared_lpid_cnt) {

#    print "plot_lpid: name=$p, sumdev=$sumdev_shared_lpid{$p} devcount=$devcount_shared_lpid{$p} cnt=$shared_lpid_cnt{$p}\n";
	if ($devcount_shared_lpid{$p}) {
	    one_plot_set(fn => "e/shml-$p", plot => $plot, cnt => \$cnt, emit_zeroes => 1, title => $p);
#	    one_plot_set(fn => "e/shml-$p", lw => 1, plot => $plot, cnt => \$cnt, emit_zeroes => 1, title => $p);
	}
    }
    close_plot($cnt, $plot, $graph_mem_shared_lpid);

############### Histogram of shared mem lpid, combined by name #################
    $plot = start_plotfile_lines($graph_mem_shared_lpid_name);
#    $plot = start_plotfile_histogram($graph_mem_shared_lpid_name);

    $cnt = 0;
    foreach my $p (reverse sort {$shared_lpid_names_all_sz{$a} <=> $shared_lpid_names_all_sz{$b} } keys %shared_lpid_names_all_sz) {
	$fn = "e/shmln-$p";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt, emit_zeroes => 1, title => $p);
#	one_plot_set(fn => $fn, lw => 0, plot => $plot, cnt => \$cnt, emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_mem_shared_lpid_name);

############### Histogram of shared mem cpid #################
    $plot = start_plotfile_histogram($graph_mem_shared_cpid);

    foreach my $p (keys %shared_cpid_cnt) {
	if ($devcount_shared_cpid{$p}) {
	    $sumdev_shared_cpid{$p} /= $devcount_shared_cpid{$p};
	    $sumdev_shared_cpid{$p} += (100*(scalar(@dirs) - $devcount_shared_cpid{$p}));
	}
    }
    $cnt = 0;
    foreach my $p (sort keys %shared_cpid_cnt) {

	if ($devcount_shared_cpid{$p}) {
#	print "plot_cpid: name-pid=$p, sumdev=$sumdev_shared_cpid{$p} devcount=$devcount_shared_cpid{$p} cnt=$shared_cpid_cnt{$p}\n";
	    one_plot_set(fn => "e/shmc-$p", plot => $plot,
		cnt => \$cnt, emit_zeroes => 1, title => $p);
	}
    }
    close_plot($cnt, $plot, $graph_mem_shared_cpid);

############### Lines of shared mem segments count, by num of attached proc #################
#    $plot = start_plotfile_lines($graph_mem_shared_number);

#    $cnt = 0;
#    for ($z = 0; $z <= $max_nattach ; $z++) {
#	$fn = "e/nattach-$z-shm";
#	one_plot_set(fn => $fn, lw => 2, plot => $plot, cnt => \$cnt);
#    }
##    $fn = "e/nattach-a-age-shm";
##    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt);
##    $fn = "e/nattach-d-age-shm";
##    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt);
#    close_plot($cnt, $plot, $graph_mem_shared_number);
############### Lines of shared mem segments count, by num of attached proc #################
    $plot = start_plotfile_lines_2axes($graph_mem_shared_number);

    $cnt = 0;
    for (my $z = 0; $z <= $max_nattach ; $z++) {
	if (!$shared_used{$z}) {
	    next;
	}
	$fn = "e/nattach-$z-shm";
	one_plot_set(fn => $fn, plot => $plot, lw => 2, axes => 'x1y1', cnt => \$cnt);
    }
    one_plot_set(fn => 'e/count-shm', plot => $plot, lw => 4, axes => 'x2y2', cnt => \$cnt);
    close_plot($cnt, $plot, $graph_mem_shared_number);

############### Histogram of shared mem size, by num of attached proc #################
    $plot = start_plotfile_histogram($graph_mem_shared_size);

    $cnt = 0;
    for (my $z = $max_nattach; $z > 0; $z--) {
	$fn = "e/nattach-$z-shm-sz";
	one_plot_set(fn => $fn, plot => $plot, cnt => \$cnt, emit_zeroes => 1);
    }
    close_plot($cnt, $plot, $graph_mem_shared_size);
}

sub generate_plot_mlocked
{
    my $plot = start_plotfile_histogram($graph_appmem_locked);
    my $cnt = 0;
    foreach my $p (reverse sort {$app_sum_locked{$a} <=> $app_sum_locked{$b} } keys %app_sum_locked) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
	if (!$app_sum_locked{$p}) {
	    last;
	}
	one_plot_set(fn => "e/locked-$p", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
	$cnt += 1;
    }
    close_plot($cnt, $plot, $graph_appmem_locked);
}

sub generate_plot_vmsize
{
    my $plot = start_plotfile_linespoints($graph_vmsize);
    my $cnt = 0;
    foreach my $p (reverse sort {$app_sum_vmsz{$a} <=> $app_sum_vmsz{$b} } keys %app_sum_vmsz) {
	if ($changed_vmsize{$p}) {
	    one_plot_set(fn => "e/vmsz-$p", lw => 3, plot => $plot,
		cnt => \$cnt, title => $p);
	}
    }
    close_plot($cnt, $plot, $graph_vmsize);
}

sub generate_plot_memory_map_count
{
    use constant MAX_MMAPS_PLOTS => 3;
    use constant MAX_MMAPS_PER_PLOT => 15;
    use constant MAX_MMAPS_SPLIT_FACTOR => 5;
    my %vma_count_max_to_plot = %vma_count_max;
    foreach my $plot_idx (1 .. MAX_MMAPS_PLOTS) {
	my $graph_num_mmaps = "1045_num_mmaps_${plot_idx}";
	$legend{$graph_num_mmaps} = 'Number of memory maps (virtual memory areas)';
	$unit{$graph_num_mmaps} = 'count';
	my $plot = start_plotfile_linespoints($graph_num_mmaps);
	my $prev_max = 0;
	my $cnt_this_round = 0;
	my @plotted_this_round;
	foreach my $p (reverse sort { $vma_count_max{$a} <=> $vma_count_max{$b} } keys %vma_count_max_to_plot) {
	    my $fn = "e/vma-count-$p";
	    next if not changes_found($fn);
	    if (not $prev_max) {
		$prev_max = $vma_count_max{$p};
	    }
	    if ($plot_idx < MAX_MMAPS_PLOTS and $prev_max >= (MAX_MMAPS_SPLIT_FACTOR * $vma_count_max{$p})) {
		last;
	    }
	    one_plot_set(fn => $fn, lw => 3, plot => $plot,
		cnt => \$cnt_this_round, title => $p);
	    push(@plotted_this_round, $p);
	    if ($plot_idx < MAX_MMAPS_PLOTS and $cnt_this_round > MAX_MMAPS_PER_PLOT) {
		last;
	    }
	}
	foreach my $p (@plotted_this_round) {
	    delete $vma_count_max_to_plot{$p};
	}
	$thumblegend{$graph_num_mmaps} = "#MEMORY MAPS &mdash; MAX $prev_max";
	close_plot($cnt_this_round, $plot, $graph_num_mmaps);
    }
}

sub generate_plot_heap_histogram
{
    my $plot = start_plotfile_histogram($graph_appmem_heap);
    my $cnt = 0;
    my %show_this = ();
    foreach my $p (reverse sort {$sum_heap{$a} <=> $sum_heap{$b} } keys %sum_heap) {
	if (count_nonzero_entries("e/heap-$p") <= 0) { next; }
	if ($cnt > $max_per_graph_onecolumn - 1) {
	    last;
	}
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %sum_heap) {
	if ($show_this{$p}) {
	    $sumdev_heap{$p} /= $devcount_heap{$p};
	    $sumdev_heap{$p} += (10000*(scalar(@dirs) - $devcount_heap{$p}));
	}
    }
    my @heap_sum_others;
    foreach my $p (keys %sum_heap) {
	next if $show_this{$p};
	my $ra = $files{"e/heap-$p"};
	next if not $ra;
	foreach (@$ra) {
	    my ($rnd, $value) = split(':' , $_, 2);
	    $heap_sum_others[$rnd] += $value;
	}
    }
    for (my $ii = 0; $ii < @dirs; $ii++) {
	if ($heap_sum_others[$ii]) {
	    value_store_zeropad("e/heap-sum-others", $ii, $heap_sum_others[$ii]);
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_heap{$a} <=> $sumdev_heap{$b} } keys %sum_heap) {
	next unless $show_this{$p};
	one_plot_set(fn => "e/heap-$p", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    one_plot_set(fn => "e/heap-sum-others", plot => $plot,
	cnt => \$cnt, emit_zeroes => 1, title => "(sum of rest heaps)");
    close_plot($cnt, $plot, $graph_appmem_heap);
}

sub generate_plot_heap
{
    use constant MAX_HEAP_PLOTS => 5;
    use constant MAX_HEAP_PER_PLOT => 10;
    use constant MAX_HEAP_SPLIT_CONSTANT => 5;
    my %show_this = ();
    my $cnt = 0;
    foreach my $p (reverse sort {$sum_heap{$a} <=> $sum_heap{$b} } keys %sum_heap) {
	if (!$sumdev_heap{$p}) {
	    next;
	}
	if (!changes_found_ignore_zeroes("e/heap-$p")) {
	    next;
	}
	# if one sample and under 1 MB, do not show
	if (($num_heap_samples{$p} < 2) && ($avg_heap{$p} < 1024)) {
	    next;
	}
	$show_this{$p} = 1;
	$cnt += 1;
    }
    my %max_heap_to_plot = %max_heap;
    foreach my $plot_idx (1 .. MAX_HEAP_PLOTS) {
	my $graph_appmem_heap_lines = "1001_appmem_heap_lines_${plot_idx}";
	$legend{$graph_appmem_heap_lines} = "process heap mapping virtual size";
	$unit{$graph_appmem_heap_lines} = "MB";
	my $plot = start_plotfile_linespoints($graph_appmem_heap_lines);
	my $prev_max = 0;
	my $cnt_this_round = 0;
	my @plotted_this_round;
	foreach my $p (reverse sort { $max_heap{$a} <=> $max_heap{$b} } keys %max_heap_to_plot) {
	    next unless $show_this{$p};
	    if (not $prev_max) {
		$prev_max = $max_heap{$p};
	    }
	    if ($plot_idx < MAX_HEAP_PLOTS and $prev_max >= (MAX_HEAP_SPLIT_CONSTANT * $max_heap{$p})) {
		last;
	    }
	    my $fn = "e/heap-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot,
		cnt => \$cnt_this_round, title => $p);
	    delete_zero_lines($fn);
	    push(@plotted_this_round, $p);
	    if ($plot_idx < MAX_HEAP_PLOTS and $cnt_this_round > MAX_HEAP_PER_PLOT) {
		last;
	    }
	}
	foreach (@plotted_this_round) {
	    delete $max_heap_to_plot{$_};
	}
	$thumblegend{$graph_appmem_heap_lines} = "HEAP &mdash; MAX " . ceil($prev_max / 1024) . "MB";
	close_plot($cnt_this_round, $plot, $graph_appmem_heap_lines);
    }
}

sub generate_plot_sysvshared
{
    my $plot = start_plotfile_histogram($graph_appmem_sysvshared);
    my $cnt = 0;
    my %show_this = ();
    foreach my $p (reverse sort {$app_cumul_sysv_shared{$a} <=> $app_cumul_sysv_shared{$b} } keys %app_cumul_sysv_shared) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
#	print "sysvshared: $p: sumdev=$sumdev_sysv_shared{$p}\n";
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_sysv_shared) {
	if ($show_this{$p}) {
	    $sumdev_sysv_shared{$p} /= $devcount_sysv_shared{$p};
	    $sumdev_sysv_shared{$p} += (10000*(scalar(@dirs) - $devcount_sysv_shared{$p}));
#	    print "sysvshared-adj: $p: sumdev=$sumdev_sysv_shared{$p} count=$devcount_sysv_shared{$p}\n";
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_sysv_shared{$a} <=> $sumdev_sysv_shared{$b} } keys %app_cumul_sysv_shared) {
	next unless $show_this{$p};
	one_plot_set(fn => "e/sysvshm-$p", plot => $plot,
	    cnt => \$cnt, emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_appmem_sysvshared);
}

sub generate_plot_posixshared
{
    my $plot = start_plotfile_histogram($graph_appmem_posixshared);
    my $cnt = 0;
    my %show_this = ();
    foreach my $p (reverse sort {$app_cumul_posix_shared{$a} <=> $app_cumul_posix_shared{$b} } keys %app_cumul_posix_shared) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
#	print "posixshared: $p: sumdev=$sumdev_posix_shared{$p}\n";
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_posix_shared) {
	if ($show_this{$p}) {
	    $sumdev_posix_shared{$p} /= $devcount_posix_shared{$p};
	    $sumdev_posix_shared{$p} += (10000*(scalar(@dirs) - $devcount_posix_shared{$p}));
#	    print "posixshared-adj: $p: sumdev=$sumdev_posix_shared{$p} count=$devcount_posix_shared{$p}\n";
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_posix_shared{$a} <=> $sumdev_posix_shared{$b} } keys %app_cumul_posix_shared) {
	next unless $show_this{$p};
	one_plot_set(fn => "e/posixshm-$p", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_appmem_posixshared);
}

sub generate_plot_dev_pvr
{
    my $plot = start_plotfile_histogram($graph_appmem_devpvr);
    my $cnt = 0;
    my %show_this = ();
    foreach my $p (reverse sort {$app_cumul_dev_pvr{$a} <=> $app_cumul_dev_pvr{$b} } keys %app_cumul_dev_pvr) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
#	print "sysvshared: $p: sumdev=$sumdev_sysv_shared{$p}\n";
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_dev_pvr) {
	if ($show_this{$p}) {
	    $sumdev_dev_pvr{$p} /= $devcount_dev_pvr{$p};
	    $sumdev_dev_pvr{$p} += (10000*(scalar(@dirs) - $devcount_dev_pvr{$p}));
#	    print "dev_pvr-adj: $p: sumdev=$sumdev_dev_pvr{$p} count=$devcount_dev_pvr{$p}\n";
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_dev_pvr{$a} <=> $sumdev_dev_pvr{$b} } keys %app_cumul_dev_pvr) {
	next unless $show_this{$p};
	one_plot_set(fn => "e/devpvr-$p", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_appmem_devpvr);
}

sub generate_plot_dev_pvr_count
{
    my $plot = start_plotfile_linespoints($graph_devpvr_count);
    my $cnt = 0;
    foreach my $process (keys %app_dev_pvr) {
	my $fn = "e/devpvr-count-$process";
	next unless changes_found($fn);
	next unless count_nonzero_entries($fn);
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt, title => $process);
    }
    close_plot($cnt, $plot, $graph_devpvr_count);
}

sub generate_plot_write_exec
{
    my $plot = start_plotfile_histogram($graph_appmem_wx);
    my $cnt = 0;
    foreach my $p (reverse sort {$app_cumul_rwxp{$a} <=> $app_cumul_rwxp{$b} } keys %app_cumul_rwxp) {
	if ($cnt > $max_per_graph_onecolumn -1 ) {
	    last;
	} 
	one_plot_set(fn => "e/$p-wx", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_appmem_wx);
}

sub generate_plot_swap_event
{
    my $cnt;
    my $plot;
############# SWAP EVENT COUNTS ######################
    if (($swapused_total + $swap_pgout_total) > 0) {
	my $n = 0;
	$plot = start_plotfile_lines($graph_events_swap);
	if (value_emit($pswp_in_plot_file_name, 1)) {
	    print $plot "'$pswp_in_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($pswp_out_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$pswp_out_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($pgscan_kswapd_normal_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$pgscan_kswapd_normal_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($pgscan_direct_normal_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$pgscan_direct_normal_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($slabs_scanned_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$slabs_scanned_plot_file_name' lw 3";
	    $n += 1;
	}
	if (value_emit($kswapd_steal_plot_file_name, 1)) {
	    if ($n > 0) {
		print $plot ", ";
	    }
	    print $plot "'$kswapd_steal_plot_file_name' lw 3";
	    $n += 1;
	}
	close_plot($n, $plot, $graph_events_swap);
	
############### Histogram of processes swapped #################
	$plot = start_plotfile_histogram($graph_appmem_swapped);

	$cnt = 0;
	%show_this = ();

	foreach my $p (reverse sort {$app_cumul_swp{$a} <=> $app_cumul_swp{$b} } keys %app_cumul_swp) {
	    if ($cnt > ($max_per_graph_onecolumn - 1)) {
		last;
	    } 
	    $show_this{$p} = 1;
	    $cnt += 1;
	}
	foreach my $p (sort keys %app_cumul_swp) {
	    if ($show_this{$p}) {
		$sumdev_swp{$p} /= $devcount_swp{$p};
		$sumdev_swp{$p} += (100*(scalar(@dirs) - $devcount_swp{$p}));
	    }
	}
	$cnt = 0;
	foreach my $p (sort {$sumdev_swp{$a} <=> $sumdev_swp{$b} } keys %app_cumul_swp) {
	    next unless $show_this{$p};
	    one_plot_set(fn => "e/swp-$p", plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => $p);
	}
	close_plot($cnt, $plot, $graph_appmem_swapped);

############### Histogram of processes PSS+SWAP #################
	$plot = start_plotfile_histogram($graph_appmem_pss_swap);

	$cnt = 0;
	%show_this = ();
	foreach my $p (reverse sort {$app_cumul_pss_swp{$a} <=> $app_cumul_pss_swp{$b} } keys %app_cumul_pss_swp) {
	    if ($cnt > $max_per_graph_onecolumn) {
		last;
	    } 
	    $show_this{$p} = 1;
	    $cnt += 1;
	}
	foreach my $p (sort keys %app_cumul_pss_swp) {
	    if ($show_this{$p}) {
		$sumdev_pss_swp_adj{$p} = $sumdev_pss_swp{$p} / $devcount_pss_swp{$p};
		$sumdev_pss_swp_adj{$p} += (100*(scalar(@dirs) - $devcount_pss_swp{$p}));
	    }
	}
	$cnt = 0;
	foreach my $p (sort {$sumdev_pss_swp_adj{$a} <=> $sumdev_pss_swp_adj{$b} } keys %app_cumul_pss_swp) {
	    next unless $show_this{$p};
	    one_plot_set(fn => "e/pswp-$p", plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => $p);
	}
	close_plot($cnt, $plot, $graph_appmem_pss_swap);
    }
}

sub generate_plot_private_dirty
{
############### Histogram of processes private dirty #################
#    print "privdirty ";
#    $plot = start_plotfile_histogram($graph_appmem_private_dirty);
#
#    $cnt = 0;
#    %show_this = ();
#
#    foreach my $p (reverse sort {$app_cumul_private_dirty{$a} <=> $app_cumul_private_dirty{$b} } keys %app_cumul_private_dirty) {
#	if ($cnt > ($max_per_graph_onecolumn - 1)) {
#	    last;
#	} 
#	$show_this{$p} = 1;
#	$cnt += 1;
##    print "1:cnt=$cnt p=$p\n";
#    }
#    foreach my $p (sort keys %app_cumul_private_dirty) {
#	if ($show_this{$p}) {
#	    $sumdev_private_dirty{$p} /= $devcount_private_dirty{$p};
#	    $sumdev_private_dirty{$p} += (100*(scalar(@dirs) - $devcount_private_dirty{$p}));
#	}
#    }
#    $cnt = 0;
#    foreach my $p (sort {$sumdev_private_dirty{$a} <=> $sumdev_private_dirty{$b} } keys %app_cumul_private_dirty) {
#	if ($show_this{$p} != 1) {
#	    next;
#	} 
#	if ($cnt > 0) {
#	    print $plot ", ";
#	}
#	print $plot "'e/$p-pdirty' using 2";
#	$cnt += 1;
#    }
#    close_plot($cnt, $plot, $graph_appmem_private_dirty);
}

sub generate_plot_pss
{
    my $plot = start_plotfile_histogram($graph_appmem_pss);
    my $cnt = 0;
    my %show_this = ();
    foreach my $p (reverse sort {$app_cumul_pss{$a} <=> $app_cumul_pss{$b} } keys %app_cumul_pss) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	$show_this{$p} = 1;
	$cnt += 1;
    }
    foreach my $p (sort keys %app_cumul_pss) {
	if ($show_this{$p}) {
	    $sumdev_pss{$p} /= $devcount_pss{$p};
	    $sumdev_pss{$p} += (100*(scalar(@dirs) - $devcount_pss{$p}));
	}
    }
    $cnt = 0;
    foreach my $p (sort {$sumdev_pss{$a} <=> $sumdev_pss{$b} } keys %app_cumul_pss) {
	next unless $show_this{$p};
#    print "pss:$p: sumdev=$sumdev_pss{$p} devcount=$devcount_pss{$p}\n";
	one_plot_set(fn => "e/p-$p", plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $p);
    }
    close_plot($cnt, $plot, $graph_appmem_pss);
}

sub generate_plot_pss_swap
{
############### Lines of processes PSS+SWAP, 4 graphs #################
# find out how many %app_cumul_pss_swp are there and what are dynamic split points
# to show them on 4 graphs
    my $cnt;
    my $num_of_pss_swp = 0;
    my %show_this = ();
    foreach my $p (keys %app_cumul_pss_swp) {
	if (($pss_swap_num_samples{$p} < 1) || ($sumdev_pss_swp{$p} < 1)) {
	    next;
	} 
	$show_this{$p} = 1;
	$num_of_pss_swp += 1;
    }
    use integer;
    my $elems_per_graph = $num_of_pss_swp / 4;
#print "num_of_pss_swp_elems = $num_of_pss_swp elems_per_graph=$elems_per_graph\n";
    if ($elems_per_graph == 0) {
	$elems_per_graph = 1;
    }
    if ($elems_per_graph > $max_per_graph_onecolumn) {
	$elems_per_graph = $max_per_graph_onecolumn;
    }
    my $divpoint_1 = 1*$elems_per_graph;
    my $divpoint_2 = 2*$elems_per_graph;
    my $divpoint_3 = 3*$elems_per_graph;
    no integer;
#print "div_1=$divpoint_1 div_2=$divpoint_2 div_3=$divpoint_3\n";
    $cnt = 0;
    my $pss_txt = 'PSS';
    if (($swapused_total + $swap_pgout_total) > 0) {
	$pss_txt = 'PSS+SWP';
    }
	
    foreach my $p (reverse sort {$avg_pss_swp{$a} <=> $avg_pss_swp{$b} } keys %avg_pss_swp) {
	if ($show_this{$p}) {
	    $cnt += 1;
	    if ($cnt == $divpoint_1) {
		my $div = $avg_pss_swp{$p};
		my $sdiv = sprintf("%2.1f", $div);
#	print "div(1)=$div, sdiv(1)=$sdiv\n";
		$legend{$graph_appmem_pss_swap_lines_big} = "apps $pss_txt > $sdiv MB";
		$thumblegend{$graph_appmem_pss_swap_lines_big} = "$pss_txt &gt; $sdiv MB";

		$legend{$graph_appmem_pss_swap_lines_small} = "apps $pss_txt < $sdiv MB";
		$thumblegend{$graph_appmem_pss_swap_lines_small} = "$pss_txt &lt; $sdiv MB";
	    } elsif ($cnt == $divpoint_2) {
		my $div = $avg_pss_swp{$p};
		my $sdiv = sprintf("%2.1f", $div);
#	print "div(2)=$div, sdiv(2)=$sdiv\n";
		$legend{$graph_appmem_pss_swap_lines_smaller} = "apps $pss_txt < $sdiv MB";
		$thumblegend{$graph_appmem_pss_swap_lines_smaller} = "$pss_txt &lt; $sdiv MB";
	    } elsif ($cnt == $divpoint_3) {
		my $div = $avg_pss_swp{$p};
		my $sdiv = sprintf("%2.1f", $div);
#	print "div(3)=$div, sdiv(3)=$sdiv\n";
		$legend{$graph_appmem_pss_swap_lines_smallest} = "apps $pss_txt < $sdiv MB";
		$thumblegend{$graph_appmem_pss_swap_lines_smallest} = "$pss_txt &lt; $sdiv MB";
	    }
	} 
    }

############### Lines of processes PSS+SWAP >= $lines_pss_swap_divider_1 MB #################
    $cnt = 0;
    my $plot_1 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_big);
    my $plot_2 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_small);
    my $plot_3 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_smaller);
    my $plot_4 = start_plotfile_linespoints($graph_appmem_pss_swap_lines_smallest);
    my %cnt_per_file = (
	$plot_1 => 0,
	$plot_2 => 0,
	$plot_3 => 0,
	$plot_4 => 0,
    );
    foreach my $p (reverse sort {$avg_pss_swp{$a} <=> $avg_pss_swp{$b} } keys %avg_pss_swp) {
	if ($show_this{$p}) {
	    my $handle;
	    if ($cnt < (1*$elems_per_graph)) {
		$handle = $plot_1;
	    } elsif ($cnt < (2*$elems_per_graph)) {
		$handle = $plot_2;
	    } elsif ($cnt < (3*$elems_per_graph)) {
		$handle = $plot_3;
#	    } elsif ($cnt < (4*$elems_per_graph)) {
	    } elsif (1) {
		$handle = $plot_4;
	    } else {
		print "graph_appmem_lines: no handle...p=[$p] cnt=$cnt\n";
		next;
	    }
	    my $fn = "e/pswp-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $handle,
		cnt => \$cnt_per_file{$handle}, title => $p);
	    delete_zero_lines($fn);
	    $cnt += 1;
	}
    }
    close_plot($cnt_per_file{$plot_1}, $plot_1, $graph_appmem_pss_swap_lines_big);
    close_plot($cnt_per_file{$plot_2}, $plot_2, $graph_appmem_pss_swap_lines_small);
    close_plot($cnt_per_file{$plot_3}, $plot_3, $graph_appmem_pss_swap_lines_smaller);
    close_plot($cnt_per_file{$plot_4}, $plot_4, $graph_appmem_pss_swap_lines_smallest);
}

sub generate_plot_threads
{
    my $plot = start_plotfile_histogram($graph_threads_count);
    my $cnt = 0;
    foreach my $p ( reverse sort {$has_threads{$a} <=> $has_threads{$b} } keys %has_threads) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	if ($has_threads{$p} && ($has_threads_samples{$p} > 1)) {
	    my $fn = "e/thr-$p";
	    one_plot_set(fn => $fn, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => $p);
	}
    }
    close_plot($cnt, $plot, $graph_threads_count);
}

sub generate_plot_threads_changes
{
    my $plot = start_plotfile_linespoints($graph_threads_changes);
    my $cnt = 0;
    foreach my $p (reverse sort { $has_threads{$a} <=> $has_threads{$b} } keys %has_threads) {
	my $fn = "e/thr-$p";
	next unless $has_threads{$p};
	next unless changes_found($fn);
	next unless count_nonzero_entries($fn);
	one_plot_set(fn => $fn, plot => $plot, lw => 3, cnt => \$cnt, title => $p);
    }
    close_plot($cnt, $plot, $graph_threads_changes);
}

sub generate_plot_xres
{
    my $plot;
    my $cnt;

############# X resource counts ######################
    $plot = start_plotfile_linespoints($graph_xresource_cnt);

    $cnt = 0;
    foreach my $p ( reverse sort {$xresource_latest_cnt{$a} <=> $xresource_latest_cnt{$b} } keys %xresource_latest_cnt) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
	if ($xres_samples{$p} < $samples_required) {
	    next;
	}
	my $fn = "e/xres-cnt-$p";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    title => $p);
    }
    close_plot($cnt, $plot, $graph_xresource_cnt);

############# X resource sizes, pixmaps ######################
    $plot = start_plotfile_linespoints($graph_xresource_sz_pxm);

    $cnt = 0;
    foreach my $p ( reverse sort {$xresource_latest_sz_pxm{$a} <=> $xresource_latest_sz_pxm{$b} } keys %xresource_latest_sz_pxm) {
	if ($cnt > $max_per_graph_onecolumn) {
	    last;
	} 
#	if ($xres_samples{$p} < $samples_required) {
#	    next;
#	}
	if (!$xres_pxm_size_total{$p}) {
	    next;
	}
	my $fn = "e/xres-pxm-$p";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    title => $p);
    }
    close_plot($cnt, $plot, $graph_xresource_sz_pxm);

############# X resource atom counts ######################

    foreach my $resource_atom (keys %xres_atoms_seen) {
	my $omit = 1;
	foreach my $Identifier (keys %xres_samples) {
	    if ($xres_samples{$Identifier} < 2) { next; }
	    my $fn = "e/xres-cnt-$Identifier-${resource_atom}";
	    if (count_nonzero_entries($fn) <= 0) { next; }
	    if (!changes_found($fn)) { next; }
	    $omit = 0;
	    last;
	}
	if ($omit) { next; }
	my $graph_xresource_atom_cnt = "1075_xresource_${resource_atom}";
	$legend{$graph_xresource_atom_cnt} = "X resource count: ${resource_atom}";
	$thumblegend{$graph_xresource_atom_cnt} = "X-RESOURCES-${resource_atom}";
	$unit{$graph_xresource_atom_cnt} = "X resource atom count";
	$cnt = 0;
	$plot = start_plotfile_linespoints($graph_xresource_atom_cnt);
	foreach my $Identifier (keys %xres_samples) {
	    if ($xres_samples{$Identifier} < 2) { next; }
	    my $fn = "e/xres-cnt-$Identifier-${resource_atom}";
	    if (count_nonzero_entries($fn) <= 0) { next; }
	    if (!changes_found($fn)) { next; }
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => $Identifier);
	}
	close_plot($cnt, $plot, $graph_xresource_atom_cnt);
    }

############# X resource sizes, misc ######################
#$plot = start_plotfile_linespoints($graph_xresource_sz_misc);
#
#$cnt = 0;
#foreach my $p ( reverse sort {$xresource_latest_sz_misc{$a} <=> $xresource_latest_sz_misc{$b} } keys %xresource_latest_sz_misc) {
#    if ($cnt > 0) {
#	print $plot ", ";
#    }
#    print $plot "'e/$p-xres-mem-misc' lw 3";
#    $cnt += 1;
#}
#close_plot($cnt, $plot, $graph_xresource_sz_misc);
}

sub generate_plot_df
{
    my $plot = start_plotfile_lines($graph_diskspace);
    my $cnt = 0;
    foreach my $p ( reverse sort {$filesystem_names{$a} <=> $filesystem_names{$b} } keys %filesystem_names) {
	one_plot_set(fn => "e/fs-used-$p", lw => 3, plot => $plot,
	    cnt => \$cnt, emit_zeroes => 1, title => $filesystem_demangle{$p});
    }
    one_plot_set(fn => $fd_perc_file_name, lw => 5, plot => $plot, cnt => \$cnt);
    close_plot($cnt, $plot, $graph_diskspace);
}

sub generate_plot_fd
{
    my $plot;
    my $cnt;
    my $fn;
    my %show_this;

############# fd_count for processes #####################
    $plot = start_plotfile_lines($graph_fdcount);
    $cnt = 0;
    foreach my $p (reverse sort {$fd_count{$a} <=> $fd_count{$b} } keys %fd_count) {
	if ($fd_count_samples{$p} < $samples_required) {
	    next;
	}
	if ($fd_count_diff{$p} < 1) {
	    next;
	}
	$fn = "e/fd-$p";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt, title => $p);
    }
    close_plot($cnt, $plot, $graph_fdcount);

############# fd_count_inotify for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_inotify{$a} <=> $fd_inotify{$b} } keys %fd_inotify) {
	$fn = "e/fd_inotify-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$cnt = 0;
	$plot = start_plotfile_linespoints($graph_fdcount_inotify);
	foreach my $p (reverse sort {$fd_inotify{$a} <=> $fd_inotify{$b} } keys %fd_inotify) {
	    next unless $show_this{$p};
	    $fn = "e/fd_inotify-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_inotify);
    }

############# fd_count_pipe for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_pipe{$a} <=> $fd_pipe{$b} } keys %fd_pipe) {
	$fn = "e/fd_pipe-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$cnt = 0;
	$plot = start_plotfile_linespoints($graph_fdcount_pipe);
	foreach my $p (reverse sort {$fd_pipe{$a} <=> $fd_pipe{$b} } keys %fd_pipe) {
	    next unless $show_this{$p};
	    $fn = "e/fd_pipe-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_pipe);
    }

############# fd_count_socket for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_socket{$a} <=> $fd_socket{$b} } keys %fd_socket) {
	$fn = "e/fd_socket-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_socket);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_socket{$a} <=> $fd_socket{$b} } keys %fd_socket) {
	    next unless $show_this{$p};
	    $fn = "e/fd_socket-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_socket);
    }

############# fd_count_tmpfs for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_tmpfs{$a} <=> $fd_tmpfs{$b} } keys %fd_tmpfs) {
	$fn = "e/fd_tmpfs-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_tmpfs);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_tmpfs{$a} <=> $fd_tmpfs{$b} } keys %fd_tmpfs) {
	    next unless $show_this{$p};
	    $fn = "e/fd_tmpfs-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_tmpfs);
    }

############# fd_count_eventfd for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_eventfd{$a} <=> $fd_eventfd{$b} } keys %fd_eventfd) {
	$fn = "e/fd_eventfd-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_eventfd);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_eventfd{$a} <=> $fd_eventfd{$b} } keys %fd_eventfd) {
	    next unless $show_this{$p};
	    $fn = "e/fd_eventfd-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_eventfd);
    }

############# fd_count_epoll for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_epoll{$a} <=> $fd_epoll{$b} } keys %fd_epoll) {
	$fn = "e/fd_epoll-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_epoll);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_epoll{$a} <=> $fd_epoll{$b} } keys %fd_epoll) {
	    next unless $show_this{$p};
	    $fn = "e/fd_epoll-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_epoll);
    }

############# fd_count_signalfd for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_signalfd{$a} <=> $fd_signalfd{$b} } keys %fd_signalfd) {
	$fn = "e/fd_signalfd-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_signalfd);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_signalfd{$a} <=> $fd_signalfd{$b} } keys %fd_signalfd) {
	    next unless $show_this{$p};
	    $fn = "e/fd_signalfd-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_signalfd);
    }

############# fd_count_timerfd for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_timerfd{$a} <=> $fd_timerfd{$b} } keys %fd_timerfd) {
	$fn = "e/fd_timerfd-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_timerfd);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_timerfd{$a} <=> $fd_timerfd{$b} } keys %fd_timerfd) {
	    next unless $show_this{$p};
	    $fn = "e/fd_timerfd-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_timerfd);
    }

############# fd_count_disk for processes #####################
    %show_this = ();
    foreach my $p (reverse sort {$fd_disk{$a} <=> $fd_disk{$b} } keys %fd_disk) {
	$fn = "e/fd_disk-$name_by_pid{$p}-$p";
	if (count_nonzero_entries($fn) <= 0) { next; }
	$show_this{$p} = changes_found($fn);
    }
    if (%show_this) {
	$plot = start_plotfile_linespoints($graph_fdcount_disk);
	$cnt = 0;
	foreach my $p (reverse sort {$fd_disk{$a} <=> $fd_disk{$b} } keys %fd_disk) {
	    next unless $show_this{$p};
	    $fn = "e/fd_disk-$name_by_pid{$p}-$p";
	    one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => "$name_by_pid{$p}-$p");
	}
	close_plot($cnt, $plot, $graph_fdcount_disk);
    }
}

sub generate_plot_interrupts
{
    my $plot = start_plotfile_lines_2axes($graph_interrupts);
    my $cnt = 0;
    foreach my $p ( reverse sort {$int_total{$a} <=> $int_total{$b} } keys %int_total) {
	if ($int_total{$p} < 1) {
	    next;
	}
	my $fn = "e/int-$p";
	one_plot_set(fn => $fn, plot => $plot, lw => 2, axes => 'x1y1',
	    cnt => \$cnt, title => $p);
    }
    one_plot_set(fn => 'e/count-int', plot => $plot, lw => 4, axes => 'x2y2',
	cnt => \$cnt, title => 'Total count');
    close_plot($cnt, $plot, $graph_interrupts);
}

sub generate_plot_diskstats
{
    if (not $have_diskstats) {
	return;
    }
    my $plot_1;
    my $plot_2;
    my $plot_3;
    my $cnt_1;
    my $cnt_2;
    my $cnt_3;

############# diskstats, reads #####################
    $plot_1 = start_plotfile_lines($graph_diskstats_reads_mb_per_second);
    $plot_2 = start_plotfile_lines($graph_diskstats_read_time);
    $plot_3 = start_plotfile_lines($graph_diskstats_reads_mb);

    $cnt_1 = 0;
    $cnt_2 = 0;
    $cnt_3 = 0;
    foreach my $device (reverse sort { $dev_reads_total{$a} <=> $dev_reads_total{$b} } keys %dev_reads_total) {
	my $title = $device;
	my $fs = device_to_filesystem($device);
	$title = $device . ': ' . $fs if $fs;
	one_plot_set(fn => "e/devreads-$device", lw => 3, plot => $plot_1,
	    cnt => \$cnt_1, emit_zeroes => 1, title => $title);
	one_plot_set(fn => "e/devreadtime-$device", lw => 3, plot => $plot_2,
	    cnt => \$cnt_2, emit_zeroes => 1, title => $title);
	one_plot_set(fn => "e/devreads-mb-$device", lw => 3, plot => $plot_3,
	    cnt => \$cnt_3, emit_zeroes => 1, title => $title);
    }
    close_plot($cnt_1, $plot_1, $graph_diskstats_reads_mb_per_second);
    close_plot($cnt_2, $plot_2, $graph_diskstats_read_time);
    close_plot($cnt_3, $plot_3, $graph_diskstats_reads_mb);

############# diskstats, writes #####################
    $plot_1 = start_plotfile_lines($graph_diskstats_writes_mb_per_second);
    $plot_2 = start_plotfile_lines($graph_diskstats_write_time);
    $plot_3 = start_plotfile_lines($graph_diskstats_writes_mb);

    $cnt_1 = 0;
    $cnt_2 = 0;
    $cnt_3 = 0;
    foreach my $device (reverse sort { $dev_writes_total{$a} <=> $dev_writes_total{$b} } keys %dev_writes_total) {
	my $title = $device;
	my $fs = device_to_filesystem($device);
	$title = $device . ': ' . $fs if $fs;
	one_plot_set(fn => "e/devwrites-$device", lw => 3, plot => $plot_1,
	    cnt => \$cnt_1, emit_zeroes => 1, title => $title);
	one_plot_set(fn => "e/devwritetime-$device", lw => 3, plot => $plot_2,
	    cnt => \$cnt_2, emit_zeroes => 1, title => $title);
	one_plot_set(fn => "e/devwrites-mb-$device", lw => 3, plot => $plot_3,
	    cnt => \$cnt_3, emit_zeroes => 1, title => $title);
    }
    close_plot($cnt_1, $plot_1, $graph_diskstats_writes_mb_per_second);
    close_plot($cnt_2, $plot_2, $graph_diskstats_write_time);
    close_plot($cnt_3, $plot_3, $graph_diskstats_writes_mb);
}

sub generate_plot_battery
{
    if (not $have_bme) {
	return;
    }
    my $plot = start_plotfile_lines_2axes($graph_battery);
    my $cnt = 0;
    one_plot_set(fn => $batt_charge_left_file_name, plot => $plot, lw => 4,
	axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1, title => 'Charge % left');
    one_plot_set(fn => $batt_temperature_file_name, plot => $plot, lw => 2,
	axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1, title => 'Temperature');
    one_plot_set(fn => $batt_voltage_file_name, plot => $plot, lw => 2,
	axes => 'x2y2', cnt => \$cnt, emit_zeroes => 1, title => 'Voltage');
    foreach my $backlight_dev (sort keys %sysfs_backlight_devices) {
	my $fn = "e/sysfs-backlight-$backlight_dev-percentage";
	next unless value_exists($fn);
	one_plot_set(fn => $fn, plot => $plot, lw => 3,
	    emit_zeroes => 1, cnt => \$cnt, axes => 'x1y1',
	    title => "Backlight $backlight_dev brightness %");
    }
    close_plot($cnt, $plot, $graph_battery);
}

sub generate_plot_ramzswap
{
    if (not $have_ramzswap) {
	return;
    }
    my $plot = start_plotfile_lines_2axes($graph_ramzswap);
    my $cnt = 0;
    if (count_nonzero_entries($ramzswap_bdreads_file_name) > 0) {
	one_plot_set(fn => $ramzswap_bdreads_file_name, plot => $plot, lw => 2,
	    axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1);
    }
    one_plot_set(fn => $ramzswap_reads_file_name, plot => $plot, lw => 2,
	axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1);
    if (count_nonzero_entries($ramzswap_bdwrites_file_name) > 0) {
	one_plot_set(fn => $ramzswap_bdwrites_file_name, plot => $plot, lw => 2,
	    axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1);
    }
    one_plot_set(fn => $ramzswap_writes_file_name, plot => $plot, lw => 2,
	axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1);
    one_plot_set(fn => $ramzswap_zerop_file_name, plot => $plot, lw => 4,
	axes => 'x2y2', cnt => \$cnt, emit_zeroes => 1);
    one_plot_set(fn => $ramzswap_used_file_name, plot => $plot, lw => 4,
	axes => 'x2y2', cnt => \$cnt, emit_zeroes => 1);
    close_plot($cnt, $plot, $graph_ramzswap);
}

sub generate_plot_cgroups
{
    if (not %cgroups) {
	return;
    }
    my $omit;
    my @grouplist = sort keys %cgroups;
    my $cnt;
    my $plot;
    # mem:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_mem);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-mem";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    # Plot the limits to the same graph. We want the colors to match the
    # groups, so start counting from the beginning.
    $cnt = 0;
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-memlimit";
	if (count_nonzero_entries($fn) > 0) {
	    one_plot_set(fn => $fn, lw => 5, plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
	} else {
	    $cnt++;
	}
    }
    close_plot($cnt, $plot, $graph_cgroups_mem);
    # swap:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_swap);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-swap";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_swap);
    # mem + swap:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_memsw);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-memsw";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_memsw);
    # cache:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_cache);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-cache";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_cache);
    # rss:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_rss);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-rss";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_rss);
    # mapped_file:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_mapped_file);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-mapped_file";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_mapped_file);
    # unevictable:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_unevictable);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-unevictable";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_unevictable);
    # inactive_anon:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_inactive_anon);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-inactive_anon";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_inactive_anon);
    # active_anon:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_active_anon);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-active_anon";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_active_anon);
    # inactive_file:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_inactive_file);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-inactive_file";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_inactive_file);
    # active_file:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_active_file);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-active_file";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_active_file);
    # pgpgin:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_pgpgin);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-pgpgin";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_pgpgin);
    # pgpgout:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_pgpgout);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-pgpgout";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_pgpgout);
    # process-cnt:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_process_cnt);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-process-cnt";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_process_cnt);
    # task-cnt:
    $cnt = 0;
    $plot = start_plotfile_lines($graph_cgroups_task_cnt);
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-task-cnt";
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
    }
    close_plot($cnt, $plot, $graph_cgroups_task_cnt);
    # mem-failcnt:
    $cnt = 0;
    $omit = 1;
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-mem-failcnt";
	if (count_nonzero_entries($fn) > 0) {
	    $omit = 0;
	    last;
	}
    }
    if (!$omit) {
	$plot = start_plotfile_lines($graph_cgroups_mem_failcnt);
	foreach my $cgroup (@grouplist) {
	    my $fn = "e/cgroup-${cgroup}-mem-failcnt";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
	    }
	}
	close_plot($cnt, $plot, $graph_cgroups_mem_failcnt);
    }
    # memsw-failcnt:
    $cnt = 0;
    $omit = 1;
    foreach my $cgroup (@grouplist) {
	my $fn = "e/cgroup-${cgroup}-memsw-failcnt";
	if (count_nonzero_entries($fn) > 0) {
	    $omit = 0;
	    last;
	}
    }
    if (!$omit) {
	$plot = start_plotfile_lines($graph_cgroups_memsw_failcnt);
	foreach my $cgroup (@grouplist) {
	    my $fn = "e/cgroup-${cgroup}-memsw-failcnt";
	    if (count_nonzero_entries($fn) > 0) {
		one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
		    emit_zeroes => 1, title => $cgroups_demangle{$cgroup});
	    }
	}
	close_plot($cnt, $plot, $graph_cgroups_memsw_failcnt);
    }
}

sub generate_plot_networking
{
    foreach my $interface (keys %interfaces_seen) {
	my $graph_networking_bytes = '2090_networking-bytes-' . $interface;
	$legend{$graph_networking_bytes} = 'RX and TX bytes in kB for ' . $interface;
	$thumblegend{$graph_networking_bytes} = 'NET RX/TX BYTES &mdash; ' . $interface;
	$unit{$graph_networking_bytes} = 'kB';
	my $fn_rx_kb = "e/iface-$interface-rx-kB";
	my $fn_tx_kb = "e/iface-$interface-tx-kB";
	if (count_nonzero_entries($fn_rx_kb) > 0 or count_nonzero_entries($fn_tx_kb) > 0) {
	    my $plot = start_plotfile_lines($graph_networking_bytes);
	    my $cnt = 0;
	    if (count_nonzero_entries($fn_rx_kb) > 0) {
		one_plot_set(fn => $fn_rx_kb, lw => 3, plot => $plot,
		    cnt => \$cnt, emit_zeroes => 1, title => "RX kB: $interface");
	    }
	    if (count_nonzero_entries($fn_tx_kb) > 0) {
		one_plot_set(fn => $fn_tx_kb, lw => 3, plot => $plot,
		    cnt => \$cnt, emit_zeroes => 1, title => "TX kB: $interface");
	    }
	    close_plot($cnt, $plot, $graph_networking_bytes);
	}
	my $graph_networking_packets = '2090_networking-packets-' . $interface;
	$legend{$graph_networking_packets} = 'RX and TX packets for ' . $interface;
	$thumblegend{$graph_networking_packets} = 'NET RX/TX PACKETS &mdash; ' . $interface;
	$unit{$graph_networking_packets} = 'packets';
	my $fn_rx_packets = "e/iface-$interface-rx-packets";
	my $fn_tx_packets = "e/iface-$interface-tx-packets";
	if (count_nonzero_entries($fn_rx_packets) > 0 or count_nonzero_entries($fn_tx_packets) > 0) {
	    my $plot = start_plotfile_lines($graph_networking_packets);
	    my $cnt = 0;
	    if (count_nonzero_entries($fn_rx_packets) > 0) {
		one_plot_set(fn => $fn_rx_packets, lw => 3, plot => $plot,
		    cnt => \$cnt, emit_zeroes => 1,
		    title => "RX packets/s: $interface");
	    }
	    if (count_nonzero_entries($fn_tx_packets) > 0) {
		one_plot_set(fn => $fn_tx_packets, lw => 3, plot => $plot,
		    cnt => \$cnt, emit_zeroes => 1,
		    title => "TX packets/s: $interface");
	    }
	    close_plot($cnt, $plot, $graph_networking_packets);
	}
    }
}

sub generate_plot_pagetypeinfo
{
    return unless $have_pagetypeinfo;
    foreach my $pagetype (qw/unmovable reclaimable movable reserve isolate/) {
	my $skip = 1;
	foreach my $ordernum (0 .. 10) {
	    my $fn = "e/pt-$pagetype-$ordernum";
	    if (count_nonzero_entries($fn)) {
		$skip = 0;
		last;
	    }
	}
	next if $skip;
	my $graph_pagetypeinfo = "2274_pagetypeinfo_$pagetype";
	$legend{$graph_pagetypeinfo} = "Free memory in $pagetype migrate type block pool (from /proc/pagetypeinfo)";
	$thumblegend{$graph_pagetypeinfo} = 'PAGETYPE &mdash; ' . uc($pagetype);
	$unit{$graph_pagetypeinfo} = 'MB';
	my $cnt = 0;
	my $plot = start_plotfile_histogram($graph_pagetypeinfo);
	foreach my $ordernum (0 .. 10) {
	    one_plot_set(fn => "e/pt-$pagetype-$ordernum", plot => $plot, cnt => \$cnt,
		emit_zeroes => 1, title => ucfirst($pagetype) . " order 2^$ordernum");
	}
	close_plot($cnt, $plot, $graph_pagetypeinfo);
    }
}

sub generate_plot_powertop
{
    if (not $powertop_data_found) {
	return;
    }
    my $plot;
    my $cnt;
############# powertop C-states, freq-states to same multiplot #####################
    $plot = start_plotfile_histogram_multi($graph_powertop_cf_states);
    print_cf_states_plot_cmds($plot);
    close_plot($cnt, $plot, $graph_powertop_cf_states);
############# powertop powerdomain core, neon, periph states #####################
    $plot = start_plotfile_histogram_multi($graph_powertop_domain_states_1);
    print_domain_plot_cmds($plot, "core", 0.3, 0.0);
    print_domain_plot_cmds($plot, "neon", 0.3, 0.35);
    print_domain_plot_cmds($plot, "periph", 0.3, 0.7);
    close_plot(scalar(@dirs), $plot, $graph_powertop_domain_states_1);
############# powertop powerdomain sgx, dss, mpu states #####################
    $plot = start_plotfile_histogram_multi($graph_powertop_domain_states_2);
    print_domain_plot_cmds($plot, "sgx", 0.3, 0.0);
    print_domain_plot_cmds($plot, "dss", 0.3, 0.35);
    print_domain_plot_cmds($plot, "mpu", 0.3, 0.7);
    close_plot(scalar(@dirs), $plot, $graph_powertop_domain_states_2);
############# powertop wakeups #####################
    $plot = start_plotfile_lines($graph_powertop_wakeups);
    value_emit("e/p-wakeups", 1);
    value_emit("e/p-timers", 1);
    print $plot "'e/p-wakeups' lw 2, ";
    print $plot "'e/p-timers' lw 2 ";
    close_plot(scalar(@dirs), $plot, $graph_powertop_wakeups);
############# powertop activity #####################
    $cnt = 0;
    %show_this = ();
    foreach my $p (keys %p_activity) {
	if ($num_activity_samples{$p} <= 1) {
	    next;
	}
	$show_this{$p} = 1;
	$cnt += 1;
    }
    my $split_point = $cnt/4;
    if($split_point > $max_per_graph_onecolumn) {
	$split_point = $max_per_graph_onecolumn;
    }
    my $plot_1 = start_plotfile_linespoints($graph_powertop_activity_1);
    my $plot_2 = start_plotfile_linespoints($graph_powertop_activity_2);
    my $plot_3 = start_plotfile_linespoints($graph_powertop_activity_3);
    my $plot_4 = start_plotfile_linespoints($graph_powertop_activity_4);
    my $cnt_1 = 0;
    my $cnt_2 = 0;
    my $cnt_3 = 0;
    my $cnt_4 = 0;
    foreach my $p ( reverse sort {$p_activity_max{$a} <=> $p_activity_max{$b} } keys %p_activity) {
	if (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) > 4*$max_per_graph_onecolumn) {
	    last;
	}
	next unless $show_this{$p};
	if (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= $split_point) {
	    one_plot_set(fn => "e/$p-activity", lw => 2, plot => $plot_1, cnt => \$cnt_1);
	} elsif (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= 2 * $split_point) {
	    one_plot_set(fn => "e/$p-activity", lw => 2, plot => $plot_2, cnt => \$cnt_2);
	} elsif (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= 3 * $split_point) {
	    one_plot_set(fn => "e/$p-activity", lw => 2, plot => $plot_3, cnt => \$cnt_3);
	} elsif (($cnt_1 + $cnt_2 + $cnt_3 + $cnt_4) <= 4 * $split_point) {
	    one_plot_set(fn => "e/$p-activity", lw => 2, plot => $plot_4, cnt => \$cnt_4);
	}
    }
    close_plot($cnt_1, $plot_1, $graph_powertop_activity_1);
    close_plot($cnt_2, $plot_2, $graph_powertop_activity_2);
    close_plot($cnt_3, $plot_2, $graph_powertop_activity_3);
    close_plot($cnt_4, $plot_2, $graph_powertop_activity_4);
}

sub generate_plot_process_state_count
{
    my %state_desc = (
	D => " (Uninterruptible disk sleep)",
	R => " (Running)",
	T => " (Traced or stopped)",
	W => " (Paging)",
	Z => " (Zombie)",
    );
    my $cnt = 0;
    my $plot = start_plotfile_histogram($graph_nonsleeping_process_count);
    foreach my $state (reverse sort keys %process_states_seen) {
	next if $state =~ /S/;
	one_plot_set(fn => "e/process-state-count-$state",
	    plot => $plot, cnt => \$cnt, emit_zeroes => 1,
	    title => $state . $state_desc{$state});
    }
    close_plot($cnt, $plot, $graph_nonsleeping_process_count);
}

sub wchan_title
{
    my ($wchan) = @_;
    if ($wchan eq '0') {
	return "0 (in user space)";
    } else {
	return $wchan;
    }
}

sub generate_plot_wchan_count
{
    return unless %wchan_seen;
    my $cnt = 0;
    my $plot = start_plotfile_histogram($graph_wchan_count);
    foreach my $wchan (reverse sort { $wchan_seen{$a} <=> $wchan_seen{$b} } keys %wchan_seen) {
	one_plot_set(fn => "e/wchan-$wchan",
	    plot => $plot, cnt => \$cnt, emit_zeroes => 1,
	    title => wchan_title($wchan));
    }
    close_plot($cnt, $plot, $graph_wchan_count);
}

sub generate_plot_wchan_changes
{
    return unless %wchan_seen;
    my $cnt = 0;
    my $plot = start_plotfile_linespoints($graph_wchan_changes);
    foreach my $wchan (reverse sort { $wchan_seen{$a} <=> $wchan_seen{$b} } keys %wchan_seen) {
	my $fn = "e/wchan-$wchan";
	next unless changes_found($fn);
	next unless count_nonzero_entries($fn);
	one_plot_set(fn => $fn, lw => 3, plot => $plot, cnt => \$cnt,
	    emit_zeroes => 1, title => wchan_title($wchan));
    }
    close_plot($cnt, $plot, $graph_wchan_changes);
}

sub generate_plot_power_supply
{
    foreach my $dev (keys %sysfs_power_supply_devices) {
	my $model_name = $sysfs_power_supply_device_model_name{$dev};
	$model_name = ": $model_name" if length $model_name;
	my $manufacturer = $sysfs_power_supply_device_manufacturer{$dev};
	$manufacturer = ": $manufacturer" if length $manufacturer;
	my $graph_ps = "2000_power_supply-$dev";
	$legend{$graph_ps} = "Battery ${dev}${model_name}${manufacturer}";
	$thumblegend{$graph_ps} = "POWER SUPPLY &mdash; $dev";
	$unit_1{$graph_ps} = 'charge-percent, temp-C';
	$unit_2{$graph_ps} = 'V';
	my $plot = start_plotfile_lines_2axes($graph_ps);
	my $cnt = 0;
	if (value_exists("e/power_supply-$dev-capacity")) {
	    one_plot_set(fn => "e/power_supply-$dev-capacity", lw => 5,
		plot => $plot, axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1,
		title => 'Charge % left');
	}
	if (value_exists("e/power_supply-$dev-temp")) {
	    one_plot_set(fn => "e/power_supply-$dev-temp", lw => 3,
		plot => $plot, axes => 'x1y1', cnt => \$cnt, emit_zeroes => 1,
		title => 'Temperature');
	}
	if (value_exists("e/power_supply-$dev-voltage_now")) {
	    one_plot_set(fn => "e/power_supply-$dev-voltage_now", lw => 3,
		plot => $plot, axes => 'x2y2', cnt => \$cnt, emit_zeroes => 1,
		title => 'Voltage');
	}
	foreach my $backlight_dev (sort keys %sysfs_backlight_devices) {
	    my $fn = "e/sysfs-backlight-$backlight_dev-percentage";
	    next unless value_exists($fn);
	    one_plot_set(fn => $fn, plot => $plot, lw => 3,
		emit_zeroes => 1, cnt => \$cnt, axes => 'x1y1',
		title => "Backlight $backlight_dev brightness %");
	}
	close_plot($cnt, $plot, $graph_ps);
    }
}

sub generate_plots()
{
    generate_plot_system_memory_1();
    generate_plot_system_memory_2();
    generate_plot_slab();
    generate_plot_ctx();
    generate_plot_loadavg();
    generate_plot_processes_global();
    generate_plot_pagefaults();
    generate_plot_cpu();
    generate_plot_cpu_freq();
    generate_plot_cputime();
    generate_plot_shmem();
    generate_plot_mlocked();
    generate_plot_vmsize();
    generate_plot_memory_map_count();
    generate_plot_heap_histogram();
    generate_plot_heap();
    generate_plot_sysvshared();
    generate_plot_posixshared();
    generate_plot_dev_pvr();
    generate_plot_dev_pvr_count();
    generate_plot_write_exec();
    generate_plot_swap_event();
    generate_plot_private_dirty();
    generate_plot_pss();
    generate_plot_pss_swap();
    generate_plot_threads();
    generate_plot_threads_changes();
    generate_plot_xres();
    generate_plot_df();
    generate_plot_fd();
    generate_plot_interrupts();
    generate_plot_diskstats();
    generate_plot_battery();
    generate_plot_ramzswap();
    generate_plot_cgroups();
    generate_plot_networking();
    generate_plot_pagetypeinfo();
    generate_plot_powertop();
    generate_plot_process_state_count();
    generate_plot_fs_written();
    generate_plot_wchan_count();
    generate_plot_wchan_changes();
    generate_plot_power_supply();
}
################ Start ######################################################

sub usage
{
    print STDERR "Usage: endurance_plot [OPTS] <DIR> <DIR> [<DIR>...]\n";
    print STDERR "\n";
    print STDERR "endurance_plot generates variety of process and system level graphs\n";
    print STDERR "based on the endurance data. The graphs may be used for discovering\n";
    print STDERR "issues in applications and in the system.\n";
    print STDERR "\n";
    print STDERR "endurance_plot creates index.html suitable for viewing in a web browser.\n";
    print STDERR "\n";
    print STDERR "Options:\n";
    print STDERR "   --gnuplot-terminal=pngcairo      Use gnuplot terminal 'pngcairo'.\n";
    print STDERR "                                    This is the default.\n";
    print STDERR "   --gnuplot-terminal=png           Use gnuplot terminal 'png'.\n";
    print STDERR "   -j N                             Run N copies of gnuplot and thumbnail\n";
    print STDERR "                                    generators in parallel. The Perl\n";
    print STDERR "                                    Parallel::ForkManager module must be\n";
    print STDERR "                                    available for this feature to work.\n";
    print STDERR "\n";
    print STDERR "Examples:\n";
    print STDERR "\n";
    print STDERR "   # Create graphs including directories 101, 102 and 103:\n";
    print STDERR "   endurance_plot 101 102 103\n";
    print STDERR "\n";
    print STDERR "   # Create graphs including all directories (101, ..., 999):\n";
    print STDERR "   endurance_plot ???\n";
    print STDERR "\n";
    print STDERR "   # Create graphs including every other directory (101, 103, 105, ...):\n";
    print STDERR "   endurance_plot ??[13579]\n";
}

my $flag_h;
my $flag_terminal;
my $flag_j;

# The -e flag is intentionally undocumented. When specified, the 'e' directory
# is not cleared after running the script.
my $flag_e;

exit(1) if not GetOptions(
	'h' => \$flag_h,
	'help' => \$flag_h,
	'gnuplot-terminal=s' => \$flag_terminal,
	'j=i' => \$flag_j,
	'e' => \$flag_e,
);

if ($flag_h) {
    usage();
    exit(1);
}

if ($flag_terminal) {
    if ($flag_terminal eq 'pngcairo') {
	$gnuplot_terminal = 'pngcairo';
    } elsif ($flag_terminal eq 'png') {
	$gnuplot_terminal = 'png';
    } else {
	print STDERR "ERROR: terminal type '$flag_terminal' not supported. Try png or pngcairo.\n";
	exit(1);
    }
} else {
    # pngcairo segfaults in Harmattan ARMv7 scratchbox target due to
    # /proc/pid/auxv emulation limitation. Switch to png terminal to avoid it.
    if (-e "/targets/links/scratchbox.config") {
	$gnuplot_terminal = 'png';
    }
}

if ($flag_j > 1) {
    require Parallel::ForkManager;
    $forkmanager = new Parallel::ForkManager($flag_j);
}

@dirs = @ARGV;

if (@dirs < 2) {
    usage();
    exit(1);
}

#
# note: this is global rounds counter! (name not well chosen..)
#
$i = 0;
# first pass, get version, scan uptime lines to determine periods
$cnt = 0;
foreach $d (@dirs) {
#
# get HW version only from first one
#
    if(!$hw_build) {
	parse_component_version();
    }
    my $fn = "$d/usage.csv";
    unless (open(CSV, $fn)) {
	print STDERR "ERROR: unable to open $fn: $!\n";
	exit(1);
    }
    while (<CSV>) {
	if( m/SW-version/) {
	    chop;
	    my @flds = split(' ', $_);
	    my $swver;
	    if (@flds == 3) {
# SW-version = DFL61_HARMATTAN_0.2011.03-2_RD_001
		(undef, undef, $swver) = split(' ', $_, 3);
		(undef, $swver) = split('_', $swver, 2);
	    } else {
# SW-version = Linux 2.6.35.3-10.3-n900 armv7l
		(undef, undef, $swver) = split(' ', $_, 3);
	    }
	    if($sw_version && ($sw_version ne $swver)) {
		print "** NOTE: at $d version changes [$sw_version]->[$swver]; Reflash in sequence??\n"
	    } 
	    $sw_version = $swver;
	    next;
	} 
	if( m/date = (.*)/) {
	    $round_date{$d} = $1;
	    $secval{$d} = date2seconds($1);
	    next;
	}
 	if( m/Uptime,Idletime /) {
	    my $line = <CSV>;
	    chop $line;
	    my ($uptime, undef) = split(',', $line, 2);
	    if (@uptimes) {
		$lapsed_time{$cnt} = int($uptime) - int($uptimes[-1]);
		if ($uptime < $uptimes[-1]) {
		    print "** NOTE: at $d uptime steps back. Reboot in sequence? Duration calc will have no sense..\n"
		}
	    } else {
		$lapsed_time{$cnt} = 0;
	    }
	    $uptimes[$cnt] = int($uptime);
	    $cnt += 1;
	    last;
	} 
    }
    close(CSV);
    my $dfn = "$d/step.txt";
    if (-e $dfn) {
	$steps_files += 1;
    }
}

if ($cnt < 2) {
    print STDERR "ERROR: need at least 2 rounds\n";
    exit(1);
}

if ($cnt > 25) {
    $samples_required = int($cnt / 5);
} elsif ($cnt < 5) {
    $samples_required = 2;
} else {
    $samples_required = 5;
}

$total_duration = $uptimes[-1] - $uptimes[0];
$secs_per_round = int($total_duration/($cnt - 1));

if (!$secs_per_round) {
    print STDERR "ERROR: zero duration, can not calculate much\n";
    exit(1);
}

print  "endurance_plot\n";
print  " - rounds: " . scalar @dirs . "\n";;
print  "   - first round date: $round_date{$dirs[0]}\n" if ($round_date{$dirs[0]});
print  "   - last round date:  $round_date{$dirs[-1]}\n" if ($round_date{$dirs[-1]});
print  " - total duration: " . duration_to_str($total_duration) . "\n";
printf "   - average  snapshot interval: %s\n" .
       "   - longest  snapshot interval: %s\n" .
       "   - shortest snapshot interval: %s\n",
       round_duration_stats();

system("rm -f e/* $graphs_dir/1???_* $graphs_dir/2???_* $html_name");

mkdir "e";
if (not -d 'e') {
    print STDERR "ERROR: unable to create directory 'e'.\n";
    exit(1);
}

mkdir $graphs_dir;
if (not -d $graphs_dir) {
    print STDERR "ERROR: unable to create directory '$graphs_dir'.\n";
    exit(1);
}

print "input: ";
foreach $d (@dirs) {
    my $fn = "$d/usage.csv";
    my $f;
    unless (open($f, $fn)) {
	print STDERR "ERROR: unable to open $fn: $!\n";
	exit(1);
    }
    print "$d ";
    %shared_lpid = ();
    %shared_cpid = ();
    %shared_lpid_cnt_oneround = ();
    %shared_cpid_cnt_oneround = ();
    %shared_num = ();
    %shared_size = ();
    while (<$f>) {
	if( (index($_, "Loadavg ") != -1)) {
	    my $line = <$f>;
	    chop $line;
	    my ($load_1,$load_5,$load_15,$running_all,$lastpid) = split(',' , $line, 5);
	    value_store($load_1_file_name, $i, $load_1);
	    value_store($load_5_file_name, $i, $load_5);
	    value_store($load_15_file_name, $i, $load_15);
	    my ($running,$all) = split('/' , $running_all, 2);
	    value_store("e/num-processes", $i, $all);
	    next;
	} 
	if( (index($_, "Allocated FDs,") != -1)) {
	    my $line = <$f>;
	    chop $line;
	    my ($Allocated_FDs,$Freed_FDs,$Max_FDs) = split(',' , $line, 3);
	    my $perc_fd = (100 * $Allocated_FDs) / $Max_FDs;
	    value_store($fd_perc_file_name, $round, $perc_fd);
	    next;
	} 
	if( index($_, "Name,State") != -1) {
	    parse_name_state_block($f);
	    next;
	} 
	if( index($_, "Shared memory segments:") != -1) {
	    parse_shmem_block($f);
	    next;
	} 
	if( index($_, "PID,FD count,Command") != -1) {
	    parse_pid_fd_block($f);
	    next;
	} 
	if( index($_, "Process status:") != -1) {
	    parse_process_status_block($f);
	    next;
	}
	if( index($_, "res-base,") != -1) {
	    parse_xresource_block($f, $_);
	    next;
	}
	if( index($_, "Filesystem,") != -1) {
	    parse_filesystem_block($f);
	    next;
	}
	if( index($_, "MemTotal") != -1) {
	    parse_memtotal_block($f);
	    next;
	} 
	if( index($_, "nr_free_pages") != -1) {
	    parse_pages_block($f);
	    next;
	} 
	if (/^PID,wchan:/) {
	    parse_wchan_block($f);
	    next;
	}
    }
    close $f;

    process_df();
    process_slabinfo();
    process_smaps();
    process_interrupts();
    process_diskstats();
    process_stat();
    process_powertop();
    process_bme();
    process_ramzswap();
    process_pagetypeinfo();
    process_openfds();
    process_cgroups();
    process_ifconfig();
    process_sysfs_cpu();
    process_sysfs_fs();
    process_xmeminfo();
    process_wchan();
    process_sysfs_power_supply();
    process_sysfs_backlight();

    loop_over_all_apps();
#    $total_shared_num = 0;
    for (my $z = 0; $z <= $max_nattach ; $z++) {
	$fn = "e/nattach-$z-shm";
	value_store($fn, $i, $shared_num{$z});
	if ($z > 0) {
	    $fn = "e/nattach-$z-shm-sz";
	    if (defined $shared_size{$z}) {
		value_store($fn, $i, $shared_size{$z});
	    } else {
		value_store($fn, $i, 0);
	    }
	}
    }

    $i++;
}
print "\n";

$plot_width = scalar(@dirs) * 13 + 200;
#print "desired plot_width $plot_width\n";
if ($plot_width < 1000) {
    $plot_width = 1000;
}
if ($plot_width > 1920) {
    $plot_width = 1920;
}
#print "plot_width $plot_width\n";

print "generating graph input for gnuplot...\n";
generate_plots();

print "plotting:\n";
run_gnuplot();

print "generating $html_name...\n";
my @html_images = gen_html_page();

print "generating thumbnails...\n";
gen_thumbnails(@html_images);

if (not -e 'endurance-report.html') {
    print STDERR "NOTE: generate also the endurance report (with endurance_report.py),"
	. " and save it in current directory as 'endurance-report.html'.\n";
}

if (not $flag_e) {
    system("rm -rf e");
}

print "endurance_plot done.\n";
